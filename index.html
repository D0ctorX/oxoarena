<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OXO Arena</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F0F2F5; /* Couleur de fond générale, gris très clair */
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Assure que le body prend au moins toute la hauteur du viewport */
            padding: 1rem; /* p-4 md:p-8 de Tailwind */
            overflow-x: hidden; /* Empêche le défilement horizontal */
            overflow-y: auto; /* Permet le défilement vertical si le contenu dépasse la hauteur du viewport */
        }
        /* Style pour le motif de fond subtil */
        .background-pattern {
            background-image:
                linear-gradient(45deg, rgba(26, 43, 60, 0.05) 25%, transparent 25%, transparent 75%, rgba(26, 43, 60, 0.05) 75%, rgba(26, 43, 60, 0.05) 100%),
                linear-gradient(-45deg, rgba(26, 43, 60, 0.05) 25%, transparent 25%, transparent 75%, rgba(26, 43, 60, 0.05) 75%, rgba(26, 43, 60, 0.05) 100%);
            background-size: 40px 40px; /* Taille de chaque carré du motif */
            background-position: 0 0, 20px 20px; /* Décalage pour un motif en damier */
            position: fixed; /* Fixe le motif en arrière-plan */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Assure que le motif est derrière le contenu */
        }

        /* Styles personnalisés pour le plateau de jeu */
        .board-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 colonnes de taille égale */
            grid-template-rows: repeat(5, 1fr);    /* 5 lignes de taille égale */
            width: 90vw; /* Largeur fluide basée sur la largeur du viewport */
            height: 90vw; /* Hauteur fluide pour maintenir le ratio */
            max-width: 400px; /* Largeur maximale pour les grands écrans */
            max-height: 400px; /* Hauteur maximale pour les grands écrans */
            border: 2px solid #1A2B3C; /* Bordure foncée du thème */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Ombre plus prononcée */
            border-radius: 0.75rem; /* Coins arrondis */
            background-color: #ffffff; /* Fond blanc pour le plateau */
            overflow: hidden; /* Assure que les coins arrondis des cellules sont contenus */
        }

        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem; /* Taille du symbole X/O par défaut (mobile) */
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #e0e0e0; /* Bordure de cellule plus claire */
            transition: background-color 0.2s ease-in-out;
            color: #1A2B3C; /* Couleur par default du texte (sombre du thème) */
            user-select: none; /* Empêche la sélection du texte */
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .cell {
                font-size: 2.5rem;
            }
        }
        @media (min-width: 768px) { /* md breakpoint */
            .cell {
                font-size: 3rem; /* Plus grand pour les écrans de bureau */
            }
        }

        .cell:hover {
            background-color: #f5f5f5; /* Léger survol */
        }

        /* Couleurs des joueurs basées sur le thème OXO Arena */
        .cell.x {
            color: #FFD700; /* Jaune doré pour X */
        }

        .cell.o {
            color: #1A2B3C; /* Bleu foncé pour O */
        }

        /* Styles pour les coins arrondis des cellules (pour les cellules du coin du plateau) */
        .cell:nth-child(1) { border-top-left-radius: 0.75rem; }
        .cell:nth-child(5) { border-top-right-radius: 0.75rem; }
        .cell:nth-child(21) { border-bottom-left-radius: 0.75rem; }
        .cell:nth-child(25) { border-bottom-right-radius: 0.75rem; }

        /* Styles pour les boutons de réinitialisation et de retour */
        .game-button {
            background-color: #1A2B3C; /* Couleur principale du thème */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Ombre pour le bouton */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem; /* Equivalent de space-x-3 */
        }

        .game-button:hover {
            background-color: #334a60; /* Couleur plus claire au survol */
            transform: translateY(-2px); /* Léger effet de soulèvement */
        }

        .game-button:active {
            transform: translateY(0); /* Retour à la position normale au clic */
        }

        /* Couleurs spécifiques pour les boutons de difficulté, adaptées au thème OXO Arena */
        #easy-button { background-color: #60A5FA; } /* Bleu clair */
        #easy-button:hover { background-color: #3B82F6; }

        #medium-button { background-color: #FBBF24; } /* Jaune/Orange */
        #medium-button:hover { background-color: #F59E0B; }

        #hard-button { background-color: #EF4444; } /* Rouge */
        #hard-button:hover { background-color: #DC2626; }

        /* Style pour la boîte de message */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            max-width: 90%;
            text-align: center;
        }
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        /* Style pour la difficulté sélectionnée */
        .selected-difficulty {
            border: 3px solid #FFD700; /* Bordure jaune dorée pour indiquer la sélection */
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); /* Ombre lumineuse */
        }

        /* Styles pour l'animation de chargement */
        .loader {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #FFD700; /* Yellow */
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles for the NEW game end overlay (banner) */
        .game-end-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 998; /* Below message box, above game */
            background-color: transparent; /* Initially transparent */
        }

        .game-end-banner {
            background-color: rgba(26, 43, 60, 0.8); /* Semi-transparent dark blue */
            color: white;
            padding: 1.5rem 3rem; /* Increased padding */
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5); /* Stronger shadow */
            max-width: 90%; /* Allow more width */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Increased gap */
            pointer-events: auto; /* Allow clicks on buttons within the banner */
        }

        .game-end-banner h2 {
            font-size: 2.5rem; /* Adjusted font size */
            font-weight: bold;
            color: #FFD700; /* Yellow accent */
            margin-bottom: 0.5rem;
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .game-end-banner h2 {
                font-size: 3rem;
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            .game-end-banner h2 {
                font-size: 4rem;
            }
        }


        .game-end-banner p {
            font-size: 1.25rem; /* Adjusted font size */
            margin-bottom: 1rem;
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .game-end-banner p {
                font-size: 1.5rem;
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            .game-end-banner p {
                font-size: 1.8rem;
            }
        }

        .game-end-banner .button-group {
            display: flex;
            gap: 1.5rem; /* Increased gap */
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Styles spécifiques pour le classement */
        .leaderboard-list {
            width: 100%;
            max-width: 500px;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            font-size: 1.125rem;
            cursor: pointer; /* Rendre les éléments cliquables */
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-item .rank {
            font-weight: bold;
            color: #1A2B3C;
            width: 30px;
            text-align: center;
        }

        .leaderboard-item .username {
            flex-grow: 1;
            font-weight: 600;
            color: #334a60;
            text-align: left;
            padding-left: 1rem;
        }

        .leaderboard-item .elo {
            font-weight: bold;
            color: #FFD700;
            width: 60px;
            text-align: right;
        }

        .leaderboard-item.top-3 {
            background-color: #FFFBEB; /* Light yellow background for top 3 */
        }
        .leaderboard-item.top-1 {
            background-color: #FFD700; /* Gold for rank 1 */
            color: #1A2B3C;
        }
        .leaderboard-item.top-1 .rank, .leaderboard-item.top-1 .username, .leaderboard-item.top-1 .elo {
            color: #1A2B3C;
        }

        /* Custom scrollbar for game history */
        #games-history-list::-webkit-scrollbar {
            width: 8px;
        }
        #games-history-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        #games-history-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        #games-history-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Styles for game history detail screen */
        .history-detail-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 100%;
        }

        .history-detail-info {
            width: 100%;
            background-color: #f8f8f8;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
        }
        .history-detail-info p {
            margin-bottom: 0.5rem;
        }
        .history-detail-info p span {
            font-weight: 600;
        }

        .history-detail-board-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .history-detail-board-controls button {
            background-color: #1A2B3C;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .history-detail-board-controls button:hover {
            background-color: #334a60;
        }
        .history-detail-board-controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Styles pour le bouton de notification (cloche) */
        #notification-button {
            position: relative;
            background-color: transparent;
            border: none;
            color: #1A2B3C;
            font-size: 1.8rem; /* Taille de l'icône */
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        #notification-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        #notification-count {
            position: absolute;
            top: 0;
            right: 0;
            background-color: #EF4444; /* Rouge */
            color: white;
            border-radius: 50%;
            padding: 0.2em 0.5em;
            font-size: 0.7rem;
            font-weight: bold;
            line-height: 1;
            min-width: 1.5em; /* Pour les nombres à deux chiffres */
            text-align: center;
            transform: translate(25%, -25%);
            display: none; /* Caché par default */
        }

        /* Styles pour les modals génériques (profil, chat, notifications) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            overflow-y: auto; /* Permet le défilement si le contenu est trop grand */
            padding: 1rem;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            max-width: 90%;
            max-height: 90vh; /* Limite la hauteur du modal */
            overflow-y: auto; /* Rend le contenu du modal défilable */
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative; /* Pour le bouton de fermeture */
        }
        .modal-close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #1A2B3C;
            cursor: pointer;
        }

        /* Styles spécifiques pour la liste d'amis/recherche */
        .user-list-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .user-list-item:hover {
            background-color: #f5f5f5;
        }
        .user-list-item:last-child {
            border-bottom: none;
        }
        .user-list-item .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: gray; /* Offline */
        }
        .user-list-item .status-indicator.online {
            background-color: #22C55E; /* Vert */
        }
        .user-list-item .username-display {
            font-weight: 600;
            color: #1A2B3C;
        }
        .user-list-item .user-id-display {
            font-size: 0.8rem;
            color: #6B7280;
            flex-grow: 1; /* Prend l'espace restant */
            text-align: right;
            padding-left: 0.5rem; /* Petit espace */
            word-break: break-all; /* Empêche l'ID de déborder */
        }

        /* Styles pour le chat */
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 0.5rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            background-color: #f8f8f8;
            min-height: 200px; /* Hauteur minimale pour la zone de chat */
            max-height: 400px; /* Hauteur maximale pour la zone de chat */
        }
        .chat-message {
            max-width: 70%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.75rem;
            word-wrap: break-word;
        }
        .chat-message.self {
            align-self: flex-end;
            background-color: #1A2B3C;
            color: white;
            border-bottom-right-radius: 0;
        }
        .chat-message.other {
            align-self: flex-start;
            background-color: #E5E7EB;
            color: #1A2B3C;
            border-bottom-left-radius: 0;
        }
        .chat-message .timestamp {
            font-size: 0.7rem;
            color: #9CA3AF;
            margin-top: 0.2rem;
            text-align: right;
        }
        .chat-input-area {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .chat-input-area input {
            flex-grow: 1;
            padding: 0.75rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.5rem;
        }
        .chat-input-area button {
            background-color: #FFD700;
            color: #1A2B3C;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .chat-input-area button:hover {
            background-color: #F59E0B;
        }

        /* Styles pour les demandes d'amis et invitations de partie dans le modal de notifications */
        .notification-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e0e0e0;
        }
        .notification-item:last-child {
            border-bottom: none;
        }
        .notification-item .actions button {
            margin-left: 0.5rem;
            padding: 0.4rem 0.8rem;
            border-radius: 0.3rem;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .notification-item .actions .accept-button {
            background-color: #22C55E;
            color: white;
        }
        .notification-item .actions .accept-button:hover {
            background-color: #16A34A;
        }
        .notification-item .actions .decline-button {
            background-color: #EF4444;
            color: white;
        }
        .notification-item .actions .decline-button:hover {
            background-color: #DC2626;
        }
    </style>
</head>
<body class="background-pattern">
    <div class="w-full max-w-6xl flex flex-col items-center justify-center">

        <div id="home-screen" class="bg-white rounded-xl shadow-2xl w-full flex flex-col md:flex-row max-h-[calc(100vh-2rem)] overflow-y-auto">
            <div class="w-full md:w-1/3 p-6 md:p-10 flex flex-col items-center justify-center bg-[#1A2B3C] text-white rounded-t-xl md:rounded-l-xl md:rounded-tr-none flex-shrink-0">
                <h1 class="text-4xl md:text-5xl font-extrabold mb-8 text-center tracking-tight">
                    OXO Arena
                </h1>
                <nav class="w-full space-y-4">
                    <button id="playOnlineButton" class="w-full py-3 px-6 bg-[#FFD700] text-[#1A2B3C] font-semibold rounded-lg shadow-md hover:bg-yellow-400 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                        <span>Jouer en Ligne</span>
                    </button>
                    <button id="playLocalButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M17 20h2a2 2 0 002-2V4a2 2 0 00-2-2H5a2 2 0 00-2 2v14a2 2 0 002 2h2m10 0v2m0-2h-3m-2 0h-2M9 16H5a2 2 0 00-2 2v2h10v-2a2 2 0 00-2-2z" />
                        </svg>
                        <span>Jouer en Local</span>
                    </button>
                    <button id="playAIButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 7h14a2 2 0 002-2V3a2 2 0 00-2-2H5a2 2 0 00-2 2v2a2 2 0 002 2zm0 14h14a2 2 0 002-2v-2a2 2 0 00-2-2H5a2 2 0 00-2 2v2a2 2 0 002 2zM12 11h.01M12 15h.01" />
                        </svg>
                        <span>Jouer Contre IA</span>
                    </button>
                    <button id="showLeaderboardButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        <span>Classement</span>
                    </button>
                    <button id="showFriendsButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <i class="fas fa-users h-6 w-6"></i> <span>Amis</span>
                    </button>
                </nav>
            </div>

            <div class="w-full md:w-2/3 p-6 md:p-10 flex flex-col justify-center items-center text-[#1A2B3C] flex-grow overflow-y-auto">
                <div class="w-full flex justify-between items-center mb-6">
                    <h2 class="text-3xl md:text-4xl font-bold text-center flex-grow">Votre Profil</h2>
                    <button id="notification-button" class="relative">
                        <i class="fas fa-bell"></i>
                        <span id="notification-count" class="absolute top-0 right-0 bg-red-500 text-white rounded-full px-2 py-1 text-xs font-bold -mt-2 -mr-2 hidden">0</span>
                    </button>
                </div>
                <div id="profile-loading" class="text-xl text-gray-500">Chargement du profil...</div>
                <div id="profile-content" class="bg-gray-100 p-4 rounded-xl shadow-inner w-full max-w-sm md:max-w-md space-y-3 text-base md:text-lg hidden">
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">ID Utilisateur :</span>
                        <span id="user-id-display" class="text-gray-700 font-medium break-all text-sm md:text-base"></span>
                    </p>
                    <div class="flex flex-col items-start w-full">
                        <div class="flex justify-between items-center w-full">
                            <span class="font-semibold">Pseudo :</span>
                            <span id="profile-username" class="text-gray-700 font-medium"></span>
                            <button id="change-username-button" class="ml-2 px-2 py-1 bg-[#FFD700] text-[#1A2B3C] text-xs rounded-md hover:bg-yellow-400 transition-colors">Modifier</button>
                        </div>
                        <div id="username-edit-section" class="hidden mt-2 w-full">
                            <input type="text" id="new-username-input" class="w-full p-2 border border-gray-300 rounded-md text-gray-800" placeholder="Nouveau pseudo (3-20 caractères)">
                            <button id="save-username-button" class="mt-2 w-full py-2 bg-[#1A2B3C] text-white rounded-md hover:bg-gray-800">Sauvegarder</button>
                            <button id="cancel-username-button" class="mt-2 w-full py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500">Annuler</button>
                        </div>
                        <p id="username-cooldown-message" class="text-xs text-red-600 mt-1 text-center w-full hidden"></p>
                    </div>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Elo :</span>
                        <span id="profile-elo" class="text-[#FFD700] font-bold"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Niveau :</span>
                        <span id="profile-level" class="text-[#FFD700] font-bold"></span>
                    </p>
                    <div class="border-t border-gray-300 pt-4 mt-4"></div>
                    <h3 class="text-xl font-bold mb-2 text-center">Statistiques</h3>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Parties jouées :</span>
                        <span id="profile-games-played" class="font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Victoires :</span>
                        <span id="profile-wins" class="text-green-600 font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Défaites :</span>
                        <span id="profile-losses" class="text-red-600 font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span id="profile-draws" class="text-gray-500 font-medium"></span>
                    </p>
                </div>
                <button id="showHistoryButton" class="mt-8 py-3 px-8 bg-[#1A2B3C] text-white font-semibold rounded-lg shadow-lg hover:bg-gray-800 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>Historique des Parties</span>
                </button>
            </div>
        </div>

        <div id="leaderboard-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-6 text-center">Classement des Joueurs</h1>
            <div id="leaderboard-list" class="leaderboard-list">
                <div class="text-center p-4 text-gray-500">Chargement du classement...</div>
            </div>
            <button id="leaderboard-back-to-home-button" class="game-button mt-8">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                </svg>
                <span>Retour à l'Accueil</span>
            </button>
        </div>

        <div id="local-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - Local</h1>
            <p class="text-center text-gray-600 mb-6 italic">
                Les parties jouées en local n'impactent pas vos statistiques (Elo, niveau, nombre de parties, etc.).
            </p>
            <div id="local-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]">Au tour de : X</div>

            <div id="local-board" class="board-grid">
                </div>

            <div class="mt-8 flex flex-wrap justify-center gap-4">
                <button id="local-reset-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                    </svg>
                    <span>Nouvelle partie</span>
                </button>
                <button id="local-back-to-home-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                    </svg>
                    <span>Retour à l'Accueil</span>
                </button>
            </div>
        </div>

        <div id="ai-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - Contre IA</h1>
            <p class="text-center text-gray-600 mb-6 italic">
                Les parties jouées contre l'IA en mode Facile et Moyen n'impactent pas vos statistiques (Elo, niveau, nombre de parties, etc.). Seules les parties en mode Difficile sont prises en compte.
            </p>
            <div id="ai-difficulty-buttons" class="flex flex-wrap justify-center gap-4 mb-8">
                <button id="easy-button" class="game-button">Facile</button>
                <button id="medium-button" class="game-button">Moyen</button>
                <button id="hard-button" class="game-button">Difficile</button>
            </div>
            <div id="ai-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]">Sélectionnez une difficulté pour commencer</div>

            <div id="ai-board" class="board-grid">
                </div>

            <div class="mt-8 flex flex-wrap justify-center gap-4">
                <button id="ai-reset-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                    </svg>
                    <span>Nouvelle partie</span>
                </button>
                <button id="ai-back-to-home-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                        </svg>
                    <span>Retour à l'Accueil</span>
                </button>
            </div>
        </div>

        <div id="online-searching-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-4 text-center">Recherche de partie...</h1>
            <p class="text-lg text-gray-600 mb-8 text-center">
                Veuillez patienter pendant que nous trouvons un adversaire pour vous.
            </p>
            <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32 mb-8" style="border-top-color: #FFD700;"></div>
            <button id="cancelSearchButton" class="game-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
                <span>Annuler la recherche</span>
            </button>
        </div>

        <div id="online-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - En Ligne</h1>
            <p class="text-center text-gray-600 mb-2 italic">
                Votre ID de partie : <span id="online-game-id-display" class="font-semibold break-all text-sm"></span>
            </p>
            <p class="text-center text-gray-600 mb-2 italic">
                Vous êtes le joueur : <span id="online-player-role" class="font-bold"></span>
            </p>
            <div class="text-center text-gray-600 mb-6 italic">
                <p>Adversaire : <span id="online-opponent-username" class="font-semibold text-sm"></span></p>
                <p>Elo : <span id="online-opponent-elo" class="font-semibold text-sm"></span> | Niveau : <span id="online-opponent-level" class="font-semibold text-sm"></span></p>
            </div>
            <div id="online-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]"></div>

            <div id="online-board" class="board-grid"></div>

            <div class="mt-8 flex flex-wrap justify-center gap-4">
                <button id="online-leave-game-button" class="game-button bg-red-600 hover:bg-red-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                    </svg>
                    <span>Quitter la partie</span>
                </button>
            </div>
        </div>

    </div>

    <div id="game-end-overlay" class="game-end-overlay hidden">
        <div id="game-end-banner" class="game-end-banner hidden">
            <h2 id="game-end-title" class="text-2xl sm:text-3xl lg:text-4xl"></h2>
            <p id="game-end-message" class="text-lg sm:text-xl lg:text-2xl"></p>
            <div class="button-group">
                <button id="game-end-replay-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                    </svg>
                    <span>Rejouer</span>
                </button>
                <button id="game-end-home-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                    </svg>
                    <span>Retour à l'Accueil</span>
                </button>
            </div>
        </div>
    </div>


    <div id="message-box-overlay" class="message-box-overlay hidden"></div>
    <div id="message-box" class="message-box hidden">
        <p id="message-box-text" class="text-xl font-semibold text-[#1A2B3C]"></p>
        <button id="message-box-close" class="game-button">OK</button>
    </div>

    <div id="history-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
        <h1 class="text-4xl font-extrabold mb-6 text-center">Historique des Parties</h1>
        <div id="games-history-list" class="space-y-4 overflow-y-auto max-h-[60vh] w-full custom-scrollbar">
            </div>
        <button id="history-back-button" class="game-button mt-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
            </svg>
            <span>Retour à l'Accueil</span>
        </button>
    </div>

    <div id="history-detail-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
        <h1 class="text-4xl font-extrabold mb-6 text-center">Détails de la Partie</h1>
        <div class="history-detail-container">
            <div id="detail-game-info" class="history-detail-info">
                <p>Mode: <span id="detail-mode"></span></p>
                <p>Date: <span id="detail-date"></span></p>
                <p>Adversaire: <span id="detail-opponent"></span></p>
                <p>Statut: <span id="detail-status"></span></p>
            </div>
            <div id="detail-board" class="board-grid">
                </div>
            <div class="history-detail-board-controls">
                <button id="prev-move-button" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 17l-5-5m0 0l5-5m-5 5h12" />
                    </svg>
                </button>
                <span id="move-counter">Coup 0/0</span>
                <button id="next-move-button" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M13 7l5 5m0 0l-5 5m5-5H6" />
                    </svg>
                </button>
            </div>
        </div>
        <button id="detail-back-button" class="game-button mt-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
            </svg>
            <span>Retour à l'Historique</span>
        </button>
    </div>

    <div id="friends-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
        <h1 class="text-4xl font-extrabold mb-6 text-center">Vos Amis</h1>

        <div class="w-full mb-6">
            <h2 class="text-2xl font-bold mb-4 text-center">Rechercher un utilisateur</h2>
            <div class="flex gap-2 mb-4">
                <input type="text" id="user-search-input" placeholder="Pseudo ou ID utilisateur" class="flex-grow p-2 border border-gray-300 rounded-md text-gray-800">
                <button id="user-search-button" class="game-button px-4 py-2">
                    <i class="fas fa-search"></i>
                </button>
            </div>
            <div id="user-search-results" class="bg-gray-50 rounded-md shadow-inner max-h-48 overflow-y-auto hidden">
                <p class="p-4 text-gray-500 text-center">Aucun résultat.</p>
            </div>
        </div>

        <div class="w-full mb-6">
            <h2 class="text-2xl font-bold mb-4 text-center">Mes Amis</h2>
            <div id="friends-list" class="bg-gray-50 rounded-md shadow-inner max-h-64 overflow-y-auto">
                <p class="p-4 text-gray-500 text-center">Vous n'avez pas encore d'amis.</p>
            </div>
        </div>

        <button id="friends-back-to-home-button" class="game-button mt-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
            </svg>
            <span>Retour à l'Accueil</span>
        </button>
    </div>

    <div id="user-profile-modal-overlay" class="modal-overlay hidden">
        <div id="user-profile-modal-content" class="modal-content">
            <button class="modal-close-button" id="user-profile-modal-close"><i class="fas fa-times"></i></button>
            <h2 id="modal-profile-username" class="text-3xl font-bold text-center text-[#1A2B3C] mb-4"></h2>
            <p class="text-center text-gray-600 text-sm">ID: <span id="modal-profile-id" class="break-all"></span></p>
            <p class="text-center text-gray-600 text-sm">Dernière activité: <span id="modal-profile-last-online"></span></p>

            <div class="bg-gray-100 p-4 rounded-xl shadow-inner w-full space-y-3 text-base">
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Elo :</span>
                    <span id="modal-profile-elo" class="text-[#FFD700] font-bold"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Niveau :</span>
                    <span id="modal-profile-level" class="text-[#FFD700] font-bold"></span>
                </p>
                <div class="border-t border-gray-300 pt-4 mt-4"></div>
                <h3 class="text-xl font-bold mb-2 text-center">Statistiques</h3>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Parties jouées :</span>
                    <span id="modal-profile-games-played" class="font-medium"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Victoires :</span>
                    <span id="modal-profile-wins" class="text-green-600 font-medium"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Défaites :</span>
                    <span id="modal-profile-losses" class="text-red-600 font-medium"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Nuls :</span>
                    <span id="modal-profile-draws" class="text-gray-500 font-medium"></span>
                </p>
            </div>

            <div class="flex flex-wrap justify-center gap-4 mt-4">
                <button id="send-friend-request-button" class="game-button px-4 py-2 text-sm bg-blue-600 hover:bg-blue-700 hidden">
                    <i class="fas fa-user-plus mr-2"></i> Envoyer Demande
                </button>
                <button id="cancel-friend-request-button" class="game-button px-4 py-2 text-sm bg-yellow-600 hover:bg-yellow-700 hidden">
                    <i class="fas fa-user-minus mr-2"></i> Annuler Demande
                </button>
                <button id="accept-friend-request-button" class="game-button px-4 py-2 text-sm bg-green-600 hover:bg-green-700 hidden">
                    <i class="fas fa-check mr-2"></i> Accepter Demande
                </button>
                <button id="decline-friend-request-button" class="game-button px-4 py-2 text-sm bg-red-600 hover:bg-red-700 hidden">
                    <i class="fas fa-times mr-2"></i> Refuser Demande
                </button>
                <button id="unfriend-button" class="game-button px-4 py-2 text-sm bg-gray-600 hover:bg-gray-700 hidden">
                    <i class="fas fa-user-slash mr-2"></i> Défriender
                </button>
                <button id="block-user-button" class="game-button px-4 py-2 text-sm bg-red-800 hover:bg-red-900 hidden">
                    <i class="fas fa-ban mr-2"></i> Bloquer
                </button>
                <button id="unblock-user-button" class="game-button px-4 py-2 text-sm bg-green-800 hover:bg-green-900 hidden">
                    <i class="fas fa-unlock mr-2"></i> Débloquer
                </button>
                <button id="propose-game-button" class="game-button px-4 py-2 text-sm bg-purple-600 hover:bg-purple-700 hidden">
                    <i class="fas fa-gamepad mr-2"></i> Proposer Partie
                </button>
                <button id="open-chat-button" class="game-button px-4 py-2 text-sm bg-blue-800 hover:bg-blue-900 hidden">
                    <i class="fas fa-comment mr-2"></i> Chatter
                </button>
            </div>
        </div>
    </div>

    <div id="notification-modal-overlay" class="modal-overlay hidden">
        <div id="notification-modal-content" class="modal-content">
            <button class="modal-close-button" id="notification-modal-close"><i class="fas fa-times"></i></button>
            <h2 class="text-3xl font-bold text-center text-[#1A2B3C] mb-4">Notifications</h2>
            <div id="notification-list" class="space-y-3">
                <p class="p-4 text-gray-500 text-center">Aucune notification.</p>
            </div>
        </div>
    </div>

    <div id="chat-modal-overlay" class="modal-overlay hidden">
        <div id="chat-modal-content" class="modal-content max-w-xl w-full">
            <button class="modal-close-button" id="chat-modal-close"><i class="fas fa-times"></i></button>
            <h2 id="chat-partner-name" class="text-3xl font-bold text-center text-[#1A2B3C] mb-4">Chat avec ...</h2>
            <div id="chat-messages" class="flex-grow overflow-y-auto">
                </div>
            <div class="chat-input-area">
                <input type="text" id="chat-message-input" placeholder="Écrivez votre message..." class="p-2 border rounded-md">
                <button id="send-chat-message-button">Envoyer</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Corrected: Added addDoc to the import list
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, where, getDocs, onSnapshot, serverTimestamp, arrayUnion, arrayRemove, or, and, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-functions.js";


        // --- Firebase Initialization ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'oxoarena';
        let firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; // Fixed: initialAuthToken was not defined

        if (Object.keys(firebaseConfig).length === 0) {
            console.warn("Firebase: Exécution locale. Utilisation de la configuration Firebase fournie par l'utilisateur.");
            firebaseConfig = {
                apiKey: "AIzaSyCTAax7cKcxL29HwwVgRxD8AfqDzx8tG6A",
                authDomain: "oxoarena-2476d.firebaseapp.com",
                projectId: "oxoarena-2476d",
                storageBucket: "oxoarena-2476d.firebasestorage.app",
                messagingSenderId: "1071875114714",
                appId: "1:1071875114714:web:0658dedac66047438f07e3",
                measurementId: "G-3N7C3R5HYV"
            };
        }

        let app;
        let db;
        let auth;
        let currentUserId = null;
        let isAuthReady = false;
        let userProfileData = null; // Stores current user's profile data
        let userProfileListenerUnsubscribe = null; // Listener for current user's profile

        // Online Game Variables
        let currentOnlineGameId = null;
        let currentOnlinePlayerRole = null;
        let onlineBoard = Array(25).fill('');
        let onlineCurrentTurn = 'X';
        let onlineGameActive = false;
        let onlineCells;
        let onlineGameListenerUnsubscribe = null;
        let onlineOpponentUserId = null; // Store opponent's user ID
        let onlineOpponentProfile = null; // Store opponent's profile data

        // Friend System Variables
        let friendsListenerUnsubscribe = null;
        let pendingRequestsListenerUnsubscribe = null;
        let chatListenerUnsubscribe = null;
        let currentChatPartnerId = null;
        let currentChatPartnerUsername = null;
        let currentFriendshipDocId = null; // Stores the document ID of the current friendship being viewed/managed

        // Global variable to store all user profiles for quick lookup (e.g., by ID or username)
        // This will be populated by fetching all profiles, primarily for search and display.
        let allUserProfiles = {};

        if (Object.keys(firebaseConfig).length > 0 && firebaseConfig.apiKey) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    isAuthReady = true;
                    console.log("Firebase: User signed in:", currentUserId);
                    userProfileData = await fetchUserProfile(currentUserId);
                    displayUserProfile(currentUserId, userProfileData);
                    document.getElementById('profile-loading').classList.add('hidden');
                    document.getElementById('profile-content').classList.remove('hidden');

                    // Start listening to friends and pending requests
                    setupFriendshipListeners();
                    // Fetch all user profiles for search functionality
                    fetchAllUserProfiles();
                    // Set up presence (lastOnline) listener
                    setupPresenceListener();

                } else {
                    console.log("Firebase: No user signed in. Attempting sign-in...");
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Firebase: Signed in with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Firebase: Signed in anonymously.");
                        }
                    } catch (error) {
                        console.error("Firebase: Authentication error:", error);
                        if (error.code !== 'permission-denied') {
                            showMessage("Erreur de connexion Firebase: " + error.message);
                        } else {
                            console.warn("Firebase: Erreur de permission lors de l'authentification/profil, mais le jeu peut continuer.");
                        }
                    }
                    isAuthReady = true;
                    document.getElementById('profile-loading').classList.add('hidden');
                    document.getElementById('profile-content').classList.remove('hidden');
                    document.getElementById('user-id-display').textContent = 'Non connecté (Firebase désactivé)';
                    document.getElementById('profile-username').textContent = 'Invité'; // Default for anonymous
                    document.getElementById('profile-elo').textContent = 'N/A';
                    document.getElementById('profile-level').textContent = 'N/A';
                    document.getElementById('profile-games-played').textContent = 'N/A';
                    document.getElementById('profile-wins').textContent = 'N/A';
                    document.getElementById('profile-losses').textContent = 'N/A';
                    document.getElementById('profile-draws').textContent = 'N/A';
                    document.getElementById('playOnlineButton').disabled = true;
                    document.getElementById('playOnlineButton').textContent = 'Jouer en Ligne (Hors ligne)';
                    document.getElementById('showFriendsButton').disabled = true; // Disable friends button
                    document.getElementById('showFriendsButton').classList.add('opacity-50', 'cursor-not-allowed');
                    document.getElementById('notification-button').disabled = true; // Disable notification button
                    document.getElementById('notification-button').classList.add('opacity-50', 'cursor-not-allowed');
                    document.getElementById('change-username-button').disabled = true;
                    document.getElementById('change-username-button').classList.add('opacity-50', 'cursor-not-allowed');
                }
            });
        } else {
            console.warn("Firebase: La configuration Firebase est incomplète ou introuvable. Exécution sans les fonctionnalités Firebase.");
            isAuthReady = true;
            document.getElementById('profile-loading').classList.add('hidden');
            document.getElementById('profile-content').classList.remove('hidden');
            document.getElementById('user-id-display').textContent = 'Non connecté (Firebase désactivé)';
            document.getElementById('profile-elo').textContent = 'N/A';
            document.getElementById('profile-level').textContent = 'N/A';
            document.getElementById('profile-games-played').textContent = 'N/A';
            document.getElementById('profile-wins').textContent = 'N/A';
            document.getElementById('profile-losses').textContent = 'N/A';
            document.getElementById('profile-draws').textContent = 'N/A';
            document.getElementById('playOnlineButton').disabled = true;
            document.getElementById('playOnlineButton').textContent = 'Jouer en Ligne (Hors ligne)';
            document.getElementById('showFriendsButton').disabled = true;
            document.getElementById('showFriendsButton').classList.add('opacity-50', 'cursor-not-allowed');
            document.getElementById('notification-button').disabled = true;
            document.getElementById('notification-button').classList.add('opacity-50', 'cursor-not-allowed');
            document.getElementById('change-username-button').disabled = true;
            document.getElementById('change-username-button').classList.add('opacity-50', 'cursor-not-allowed');
        }

        // --- Message Box Elements ---
        const messageBoxOverlay = document.getElementById('message-box-overlay');
        const messageBox = document.getElementById('message-box');
        const messageBoxText = document.getElementById('message-box-text');
        const messageBoxCloseButton = document.getElementById('message-box-close');

        messageBoxCloseButton.addEventListener('click', () => {
            messageBox.classList.add('hidden');
            messageBoxOverlay.classList.add('hidden');
        });

        function showMessage(message, callback = null) {
            messageBoxText.textContent = message;
            messageBox.classList.remove('hidden');
            messageBoxOverlay.classList.remove('hidden');
            if (callback) {
                messageBoxCloseButton.onclick = () => {
                    messageBox.classList.add('hidden');
                    messageBoxOverlay.classList.add('hidden');
                    callback();
                    messageBoxCloseButton.onclick = null;
                };
            } else {
                messageBoxCloseButton.onclick = () => {
                    messageBox.classList.add('hidden');
                    messageBoxOverlay.classList.add('hidden');
                    messageBoxCloseButton.onclick = null;
                };
            }
        }

        // --- User Profile Functions ---
        const defaultUserProfile = {
            elo: 0,
            level: 0,
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            username: 'Joueur' + Math.floor(Math.random() * 10000), // Default username
            lastUsernameChange: null, // No previous change
            lastOnline: serverTimestamp() // New field for presence
        };
        const MAX_LEVEL = 50;

        async function fetchUserProfile(userIdToFetch) {
            if (!db || !userIdToFetch) {
                console.error("Firebase: Firestore ou userId non disponible pour le profil.");
                return { ...defaultUserProfile };
            }

            const userProfileRef = doc(db, `artifacts/${appId}/users/${userIdToFetch}/profile`, 'data');
            const userDocRef = doc(db, `artifacts/${appId}/users`, userIdToFetch); // Référence au document parent de l'utilisateur

            try {
                // Ensure the parent user document exists and update its lastActive timestamp
                // This is important for security rules that might rely on the existence of the user document
                await setDoc(userDocRef, { lastActive: serverTimestamp() }, { merge: true });
                console.log(`Firebase: Document parent utilisateur pour ${userIdToFetch} assuré.`);

                const docSnap = await getDoc(userProfileRef);
                let profileData = {};

                if (docSnap.exists()) {
                    profileData = docSnap.data();
                    // Ensure all default fields are present if profile was created before they existed
                    for (const key in defaultUserProfile) {
                        if (profileData[key] === undefined) {
                            profileData[key] = defaultUserProfile[key];
                        }
                    }
                    console.log("Firebase: Profil utilisateur récupéré :", profileData);
                } else {
                    console.log("Firebase: Pas de profil utilisateur trouvé, création par défaut.");
                    profileData = { ...defaultUserProfile };
                    await setDoc(userProfileRef, profileData);
                    console.log("Firebase: Profil par défaut créé.");
                }
                return profileData;
            } catch (error) {
                console.error("Firebase: Erreur lors de la récupération ou la création du profil utilisateur :", error);
                if (error.code !== 'permission-denied') {
                    showMessage("Erreur lors du chargement du profil: " + error.message);
                } else {
                    console.warn("Firebase: Erreur de permission lors de la récupération/création du profil, mais le jeu peut continuer.");
                }
                return { ...defaultUserProfile };
            }
        }

        async function updateUserProfileStats(userId, gameResult, opponentElo = null) {
            if (!db || !userId || !isAuthReady) {
                console.error("Firebase: Firestore, userId, ou auth non prêt pour la mise à jour.");
                return;
            }
            const userProfileRef = doc(db, `artifacts/${appId}/users/${userId}/profile`, 'data');

            try {
                const docSnap = await getDoc(userProfileRef);
                let currentProfile = docSnap.exists() ? docSnap.data() : { ...defaultUserProfile };

                currentProfile.gamesPlayed = (currentProfile.gamesPlayed || 0) + 1;

                let eloChange = 0;
                if (gameResult === 'win') {
                    currentProfile.wins = (currentProfile.wins || 0) + 1;
                    if (opponentElo !== null) {
                        // K-factor logic for Elo change based on opponent's Elo
                        if (currentProfile.elo >= opponentElo) {
                            eloChange = 8; // Smaller gain for winning against lower/equal Elo
                        } else {
                            eloChange = 15; // Larger gain for winning against higher Elo
                        }
                    } else {
                        eloChange = 10; // Default gain for AI hard mode or if opponent Elo is unknown
                    }
                } else if (gameResult === 'loss') {
                    currentProfile.losses = (currentProfile.losses || 0) + 1;
                    if (opponentElo !== null) {
                        // K-factor logic for Elo change based on opponent's Elo
                        if (currentProfile.elo >= opponentElo) {
                            eloChange = -15; // Larger loss for losing against lower/equal Elo
                        } else {
                            eloChange = -8; // Smaller loss for losing against higher Elo
                        }
                    } else {
                        eloChange = -5; // Default loss for AI hard mode or if opponent Elo is unknown
                    }
                } else if (gameResult === 'draw') {
                    currentProfile.draws = (currentProfile.draws || 0) + 1;
                    eloChange = 1; // Small Elo gain for a draw
                }

                currentProfile.elo = Math.max(0, (currentProfile.elo || 0) + eloChange);
                currentProfile.level = Math.min(MAX_LEVEL, Math.floor((currentProfile.elo || 0) / 25));

                await setDoc(userProfileRef, currentProfile);
                console.log("Firebase: User profile updated successfully.", currentProfile);
                if (userId === currentUserId) {
                    userProfileData = currentProfile; // Update global user profile data
                    displayUserProfile(userId, currentProfile); // Update UI immediately
                }
            } catch (error) {
                console.error("Firebase: Erreur lors de la mise à jour du profil utilisateur :", error);
                showMessage("Erreur lors de la mise à jour du profil: " + error.message);
            }
        }

        // --- Presence / Last Online ---
        async function setupPresenceListener() {
            if (!db || !currentUserId) return;

            const userProfileRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data');

            // Update lastOnline timestamp every minute
            setInterval(async () => {
                if (currentUserId) { // Ensure user is still signed in
                    try {
                        await updateDoc(userProfileRef, { lastOnline: serverTimestamp() });
                    } catch (e) {
                        console.error("Erreur lors de la mise à jour de lastOnline:", e);
                    }
                }
            }, 60 * 1000); // Every 60 seconds (1 minute)

            // Update lastOnline when user closes/leaves the page (best effort)
            window.addEventListener('beforeunload', async () => {
                if (currentUserId) {
                    try {
                        await updateDoc(userProfileRef, { lastOnline: serverTimestamp() });
                    } catch (e) {
                        console.error("Erreur lors de la mise à jour de lastOnline à la fermeture:", e);
                    }
                }
            });
        }

        function displayUserProfile(userId, profile) {
            document.getElementById('user-id-display').textContent = userId;
            profileUsername.textContent = profile.username;
            document.getElementById('profile-elo').textContent = profile.elo;
            document.getElementById('profile-level').textContent = `${profile.level}/${MAX_LEVEL}`;
            document.getElementById('profile-games-played').textContent = profile.gamesPlayed;
            document.getElementById('profile-wins').textContent = profile.wins;
            document.getElementById('profile-losses').textContent = profile.losses;
            document.getElementById('profile-draws').textContent = profile.draws;

            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            // Check if lastUsernameChange exists and is a Firestore Timestamp
            if (profile.lastUsernameChange && profile.lastUsernameChange instanceof Object && 'toDate' in profile.lastUsernameChange) {
                const lastChangeDate = profile.lastUsernameChange.toDate();
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;

                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    usernameCooldownMessage.textContent = `Prochain changement dans ${days} jour${days > 1 ? 's' : ''}.`;
                    usernameCooldownMessage.classList.remove('hidden');
                    changeUsernameButton.disabled = true;
                    changeUsernameButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    usernameCooldownMessage.classList.add('hidden');
                    changeUsernameButton.disabled = false;
                    changeUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            } else {
                // If lastUsernameChange is null or not a valid timestamp, allow change
                usernameCooldownMessage.classList.add('hidden');
                changeUsernameButton.disabled = false;
                changeUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        // --- Username Change Functions ---
        const profileUsername = document.getElementById('profile-username');
        const changeUsernameButton = document.getElementById('change-username-button');
        const usernameEditSection = document.getElementById('username-edit-section');
        const newUsernameInput = document.getElementById('new-username-input');
        const saveUsernameButton = document.getElementById('save-username-button');
        const cancelUsernameButton = document.getElementById('cancel-username-button');
        const usernameCooldownMessage = document.getElementById('username-cooldown-message');

        function showUsernameEditForm() {
            changeUsernameButton.classList.add('hidden');
            usernameEditSection.classList.remove('hidden');
            newUsernameInput.value = profileUsername.textContent;

            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            if (userProfileData && userProfileData.lastUsernameChange && userProfileData.lastUsernameChange instanceof Object && 'toDate' in userProfileData.lastUsernameChange) {
                const lastChangeDate = userProfileData.lastUsernameChange.toDate();
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;
                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    usernameCooldownMessage.textContent = `Vous devez attendre ${days} jour${days > 1 ? 's' : ''} avant de changer de pseudo.`;
                    usernameCooldownMessage.classList.remove('hidden');
                    newUsernameInput.disabled = true;
                    saveUsernameButton.disabled = true;
                    saveUsernameButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    usernameCooldownMessage.classList.add('hidden');
                    newUsernameInput.disabled = false;
                    saveUsernameButton.disabled = false;
                    saveUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            } else {
                usernameCooldownMessage.classList.add('hidden');
                newUsernameInput.disabled = false;
                saveUsernameButton.disabled = false;
                saveUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        async function handleSaveUsername() {
            const newUsername = newUsernameInput.value.trim();

            if (!newUsername || newUsername.length < 3 || newUsername.length > 20) {
                showMessage("Le pseudo doit contenir entre 3 et 20 caractères.");
                return;
            }

            if (newUsername === profileUsername.textContent) {
                showMessage("Le nouveau pseudo est identique au pseudo actuel.");
                usernameEditSection.classList.add('hidden');
                changeUsernameButton.classList.remove('hidden');
                return;
            }

            await updateUsername(newUsername);
        }

        function cancelUsernameEdit() {
            usernameEditSection.classList.add('hidden');
            changeUsernameButton.classList.remove('hidden');
            displayUserProfile(currentUserId, userProfileData); // Re-display current profile data
        }

        async function updateUsername(newUsername) {
            if (!db || !currentUserId || !isAuthReady) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }

            const userProfileRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data');

            const docSnap = await getDoc(userProfileRef);
            let currentProfile = docSnap.exists() ? docSnap.data() : { ...defaultUserProfile };

            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            if (currentProfile.lastUsernameChange && currentProfile.lastUsernameChange instanceof Object && 'toDate' in currentProfile.lastUsernameChange) {
                const lastChangeDate = currentProfile.lastUsernameChange.toDate();
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;
                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    showMessage(`Vous devez attendre ${days} jour${days > 1 ? 's' : ''} avant de changer de pseudo.`);
                    return;
                }
            }

            try {
                await updateDoc(userProfileRef, {
                    username: newUsername,
                    lastUsernameChange: serverTimestamp() // Set timestamp for cooldown
                });
                showMessage("Pseudo mis à jour avec succès !");
                userProfileData = await fetchUserProfile(currentUserId); // Re-fetch to update local cache
                displayUserProfile(currentUserId, userProfileData); // Update UI
            } catch (error) {
                console.error("Erreur lors de la mise à jour du pseudo:", error);
                showMessage("Erreur lors de la mise à jour du pseudo: " + error.message);
            } finally {
                usernameEditSection.classList.add('hidden');
                changeUsernameButton.classList.remove('hidden');
            }
        }


        // --- Éléments du DOM et variables d'état pour l'application globale ---
        const homeScreen = document.getElementById('home-screen');
        const localGameScreen = document.getElementById('local-game-screen');
        const aiGameScreen = document.getElementById('ai-game-screen');
        const onlineSearchingScreen = document.getElementById('online-searching-screen');
        const onlineGameScreen = document.getElementById('online-game-screen');
        const gameEndOverlay = document.getElementById('game-end-overlay');
        const gameEndBanner = document.getElementById('game-end-banner');
        const gameEndTitle = document.getElementById('game-end-title');
        const gameEndMessage = document.getElementById('game-end-message');
        const gameEndReplayButton = document.getElementById('game-end-replay-button');
        const gameEndHomeButton = document.getElementById('game-end-home-button');
        const leaderboardScreen = document.getElementById('leaderboard-screen');
        const leaderboardList = document.getElementById('leaderboard-list');
        const historyScreen = document.getElementById('history-screen');
        const gamesHistoryList = document.getElementById('games-history-list');
        const historyDetailScreen = document.getElementById('history-detail-screen');
        const detailGameInfo = document.getElementById('detail-game-info');
        const detailBoardElement = document.getElementById('detail-board');
        const prevMoveButton = document.getElementById('prev-move-button');
        const nextMoveButton = document.getElementById('next-move-button');
        const moveCounter = document.getElementById('move-counter');
        const detailBackButton = document.getElementById('detail-back-button');

        // NOUVEAUX ÉLÉMENTS DU DOM POUR LE SYSTÈME D'AMIS ET CHAT
        const showFriendsButton = document.getElementById('showFriendsButton');
        const friendsScreen = document.getElementById('friends-screen');
        const friendsBackToHomeButton = document.getElementById('friends-back-to-home-button');
        const userSearchInput = document.getElementById('user-search-input');
        const userSearchButton = document.getElementById('user-search-button');
        const userSearchResults = document.getElementById('user-search-results');
        const friendsListElement = document.getElementById('friends-list');

        const userProfileModalOverlay = document.getElementById('user-profile-modal-overlay');
        const userProfileModalCloseButton = document.getElementById('user-profile-modal-close');
        const modalProfileUsername = document.getElementById('modal-profile-username');
        const modalProfileId = document.getElementById('modal-profile-id');
        const modalProfileLastOnline = document.getElementById('modal-profile-last-online');
        const modalProfileElo = document.getElementById('modal-profile-elo');
        const modalProfileLevel = document.getElementById('modal-profile-level');
        const modalProfileGamesPlayed = document.getElementById('modal-profile-games-played');
        const modalProfileWins = document.getElementById('modal-profile-wins');
        const modalProfileLosses = document.getElementById('modal-profile-losses');
        const modalProfileDraws = document.getElementById('modal-profile-draws');

        const sendFriendRequestButton = document.getElementById('send-friend-request-button');
        const cancelFriendRequestButton = document.getElementById('cancel-friend-request-button');
        const acceptFriendRequestButton = document.getElementById('accept-friend-request-button');
        const declineFriendRequestButton = document.getElementById('decline-friend-request-button');
        const unfriendButton = document.getElementById('unfriend-button');
        const blockUserButton = document.getElementById('block-user-button');
        const unblockUserButton = document.getElementById('unblock-user-button');
        const proposeGameButton = document.getElementById('propose-game-button');
        const openChatButton = document.getElementById('open-chat-button');

        const notificationButton = document.getElementById('notification-button');
        const notificationCount = document.getElementById('notification-count');
        const notificationModalOverlay = document.getElementById('notification-modal-overlay');
        const notificationModalCloseButton = document.getElementById('notification-modal-close');
        const notificationList = document.getElementById('notification-list');

        const chatModalOverlay = document.getElementById('chat-modal-overlay');
        const chatModalCloseButton = document.getElementById('chat-modal-close');
        const chatPartnerName = document.getElementById('chat-partner-name');
        const chatMessagesDiv = document.getElementById('chat-messages');
        const chatMessageInput = document.getElementById('chat-message-input');
        const sendChatMessageButton = document.getElementById('send-chat-message-button');


        const playOnlineButton = document.getElementById('playOnlineButton');
        const playLocalButton = document.getElementById('playLocalButton');
        const playAIButton = document.getElementById('playAIButton');
        const showHistoryButton = document.getElementById('showHistoryButton');
        const showLeaderboardButton = document.getElementById('showLeaderboardButton');
        const leaderboardBackToHomeButton = document.getElementById('leaderboard-back-to-home-button');
        const historyBackButton = document.getElementById('history-back-button');


        // --- Variables et éléments du DOM pour le jeu local ---
        const localStatusDisplay = document.getElementById('local-game-status');
        const localBoardElement = document.getElementById('local-board');
        const localResetButton = document.getElementById('local-reset-button');
        const localBackToHomeButton = document.getElementById('local-back-to-home-button');

        let localBoard = Array(25).fill('');
        let localCurrentPlayer = 'X';
        let localGameActive = true;
        let localCells;
        let localMovesHistory = [];

        // --- Variables et éléments du DOM pour le jeu IA ---
        const aiStatusDisplay = document.getElementById('ai-game-status');
        const aiBoardElement = document.getElementById('ai-board');
        const aiResetButton = document.getElementById('ai-reset-button');
        const aiBackToHomeButton = document.getElementById('ai-back-to-home-button');
        const easyButton = document.getElementById('easy-button');
        const mediumButton = document.getElementById('medium-button');
        const hardButton = document.getElementById('hard-button');
        const difficultyButtons = [easyButton, mediumButton, hardButton];

        let aiBoard = Array(25).fill('');
        let humanPlayer = 'X';
        let aiPlayer = 'O';
        let aiCurrentPlayer = humanPlayer;
        let aiGameActive = false;
        let aiDifficulty = null;
        const MINIMAX_MAX_DEPTH = 4;
        let aiCells;
        let aiMovesHistory = [];

        // --- Constantes de jeu communes ---
        const BOARD_SIZE = 5;
        const WIN_LENGTH = 4;

        const generateWinningCombinations = () => {
            const combinations = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col <= BOARD_SIZE - WIN_LENGTH; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i));
                }
            }
            for (let col = 0; col < BOARD_SIZE; col++) {
                for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * BOARD_SIZE));
                }
            }
            for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                for (let col = 0; col <= BOARD_SIZE - WIN_LENGTH; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * (BOARD_SIZE + 1)));
                }
            }
            for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                for (let col = WIN_LENGTH - 1; col < BOARD_SIZE; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * (BOARD_SIZE - 1)));
                }
            }
            return combinations;
        };
        const winningCombinations = generateWinningCombinations();

        const updateStatus = (message, gameType) => {
            if (gameType === 'local') {
                localStatusDisplay.innerHTML = message;
            } else if (gameType === 'ai') {
                aiStatusDisplay.innerHTML = message;
            } else if (gameType === 'online') {
                document.getElementById('online-game-status').innerHTML = message;
            }
        };

        const createCells = (boardElementId, clickHandler) => {
            const currentBoardElement = document.getElementById(boardElementId);
            currentBoardElement.innerHTML = '';
            for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                if (clickHandler) { // Only add if a handler is provided
                    cell.addEventListener('click', clickHandler);
                }
                currentBoardElement.appendChild(cell);
            }
            if (boardElementId === 'local-board') {
                localCells = Array.from(document.querySelectorAll('#local-board .cell'));
            } else if (boardElementId === 'ai-board') {
                aiCells = Array.from(document.querySelectorAll('#ai-board .cell'));
            } else if (boardElementId === 'online-board') {
                onlineCells = Array.from(document.querySelectorAll('#online-board .cell'));
            } else if (boardElementId === 'detail-board') {
                // No specific cells array for detail board, it's temporary
            }
        };

        const checkForWin = (player, currentBoard) => {
            for (let i = 0; i < winningCombinations.length; i++) {
                const combination = winningCombinations[i];
                let allMatch = true;
                for (let j = 0; j < WIN_LENGTH; j++) {
                    if (currentBoard[combination[j]] !== player) {
                        allMatch = false;
                        break;
                    }
                }
                if (allMatch) {
                    return true;
                }
            }
            return false;
        };

        const checkForDraw = (currentBoard) => {
            return !currentBoard.includes('');
        };

        // --- Fonctions communes pour les écrans de fin de partie ---
        let currentEndGameType = '';
        let currentOpponentName = '';
        const playerXMarker = 'X';

        function showGameEndScreen(status, winner, gameType, finalBoardState, movesHistory) {
            localGameScreen.classList.add('hidden');
            aiGameScreen.classList.add('hidden');
            onlineGameScreen.classList.add('hidden');
            onlineSearchingScreen.classList.add('hidden');

            gameEndOverlay.classList.remove('hidden');
            gameEndBanner.classList.remove('hidden');

            gameEndTitle.textContent = '';
            gameEndMessage.textContent = '';
            currentEndGameType = gameType;

            let title = '';
            let message = '';
            let historyStatus = '';

            if (gameType === 'local') {
                if (status === 'win') {
                    title = 'PARTIE TERMINÉE !';
                    message = `Le joueur ${winner} a gagné !`;
                    historyStatus = (winner === playerXMarker) ? 'won' : 'lost';
                } else {
                    title = 'MATCH NUL !';
                    message = 'Aucun vainqueur.';
                    historyStatus = 'draw';
                }
                currentOpponentName = 'Joueur Local';
            } else if (gameType === 'ai') {
                if (status === 'win') {
                    title = 'VICTOIRE !';
                    message = `Vous avez gagné !`;
                    historyStatus = 'won';
                } else if (status === 'loss') {
                    title = 'DÉFAITE !';
                    message = `L'IA a gagné.`;
                    historyStatus = 'lost';
                } else {
                    title = 'MATCH NUL !';
                    message = 'Aucun vainqueur.';
                    historyStatus = 'draw';
                }
                currentOpponentName = `IA ${aiDifficulty === 'easy' ? 'Facile' : (aiDifficulty === 'medium' ? 'Moyenne' : 'Difficile')}`;
            } else if (gameType === 'online') {
                if (status === 'win') {
                    title = 'VICTOIRE !';
                    message = `Vous avez gagné !`;
                    historyStatus = 'won';
                } else if (status === 'loss') {
                    title = 'DÉFAITE !';
                    message = `${onlineOpponentProfile ? onlineOpponentProfile.username : 'Votre adversaire'} a gagné.`;
                    historyStatus = 'lost';
                } else {
                    title = 'MATCH NUL !';
                    message = 'Aucun vainqueur.';
                    historyStatus = 'draw';
                }
                currentOpponentName = onlineOpponentProfile ? onlineOpponentProfile.username : 'Joueur en ligne';
            }

            gameEndTitle.textContent = title;
            gameEndMessage.textContent = message;

            // Update user stats for online games and hard AI games
            if (isAuthReady && currentUserId) {
                if (gameType === 'ai' && aiDifficulty === 'hard') {
                    updateUserProfileStats(currentUserId, status);
                } else if (gameType === 'online') {
                    updateUserProfileStats(currentUserId, status, onlineOpponentProfile ? onlineOpponentProfile.elo : null);
                }
            }

            saveGameToHistory(gameType, historyStatus, currentOpponentName, finalBoardState, movesHistory, BOARD_SIZE, currentOnlineGameId);
        }

        // --- Fonctions spécifiques au jeu local ---
        const handleLocalCellClick = (event) => {
            const clickedCell = event.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            if (localBoard[clickedCellIndex] !== '' || !localGameActive) {
                return;
            }
            localBoard[clickedCellIndex] = localCurrentPlayer;
            localCells[clickedCellIndex].innerHTML = localCurrentPlayer;
            localCells[clickedCellIndex].classList.add(localCurrentPlayer.toLowerCase());
            localMovesHistory.push({ index: clickedCellIndex, player: localCurrentPlayer });

            const hasWon = checkForWin(localCurrentPlayer, localBoard);
            if (hasWon) {
                showGameEndScreen('win', localCurrentPlayer, 'local', [...localBoard], [...localMovesHistory]);
                localGameActive = false;
                return;
            }

            const hasDraw = checkForDraw(localBoard);
            if (hasDraw) {
                showGameEndScreen('draw', null, 'local', [...localBoard], [...localMovesHistory]);
                localGameActive = false;
                return;
            }

            localCurrentPlayer = localCurrentPlayer === 'X' ? 'O' : 'X';
            updateStatus(`Au tour de : ${localCurrentPlayer}`, 'local');
        };

        const resetLocalGame = () => {
            localBoard = Array(25).fill('');
            localCurrentPlayer = 'X';
            localGameActive = true;
            localMovesHistory = [];
            updateStatus(`Au tour de : ${localCurrentPlayer}`, 'local');
            localCells.forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('x', 'o');
            });
            localGameScreen.classList.remove('hidden');
        };

        const leaveLocalGame = () => {
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        };

        // --- Fonctions spécifiques au jeu IA ---
        const handleAICellClick = (event) => {
            const clickedCell = event.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            if (aiBoard[clickedCellIndex] !== '' || !aiGameActive || aiCurrentPlayer !== humanPlayer) {
                return;
            }

            makeAIMoveInternal(clickedCellIndex, humanPlayer);
            aiMovesHistory.push({ index: clickedCellIndex, player: humanPlayer });
            checkAIGameStatus();
        };

        const makeAIMoveInternal = (index, player) => {
            aiBoard[index] = player;
            aiCells[index].innerHTML = player;
            aiCells[index].classList.add(player.toLowerCase());
        };

        const checkAIGameStatus = async () => {
            const humanWon = checkForWin(humanPlayer, aiBoard);
            const aiWon = checkForWin(aiPlayer, aiBoard);
            const isDraw = checkForDraw(aiBoard);

            if (humanWon) {
                showGameEndScreen('win', humanPlayer, 'ai', [...aiBoard], [...aiMovesHistory]);
                aiGameActive = false;
            } else if (aiWon) {
                showGameEndScreen('loss', aiPlayer, 'ai', [...aiBoard], [...aiMovesHistory]);
                aiGameActive = false;
            } else if (isDraw) {
                showGameEndScreen('draw', null, 'ai', [...aiBoard], [...aiMovesHistory]);
                aiGameActive = false;
            } else {
                aiCurrentPlayer = aiCurrentPlayer === humanPlayer ? aiPlayer : humanPlayer;
                updateStatus(`Au tour de : ${aiCurrentPlayer}`, 'ai');
                if (aiCurrentPlayer === aiPlayer && aiGameActive) {
                    setTimeout(makeAIPlayerMove, 700);
                }
            }
        };

        const getEmptyCells = (currentBoard) => {
            return currentBoard.map((cell, index) => cell === '' ? index : null).filter(index => index !== null);
        };

        const findWinningMove = (player, currentBoard) => {
            const emptyCells = getEmptyCells(currentBoard);
            for (let i = 0; i < emptyCells.length; i++) {
                const move = emptyCells[i];
                currentBoard[move] = player;
                if (checkForWin(player, currentBoard)) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }
            return null;
        };

        const findBlockingMove = (playerToBlock, currentBoard) => {
            return findWinningMove(playerToBlock, currentBoard);
        };

        const countThreats = (player, count, currentBoard) => {
            let numThreats = 0;
            for (const combination of winningCombinations) {
                let playerCount = 0;
                let emptyCount = 0;
                for (const index of combination) {
                    if (currentBoard[index] === player) playerCount++;
                    else if (currentBoard[index] === '') emptyCount++;
                }
                if (playerCount === count && emptyCount === WIN_LENGTH - count) {
                    numThreats++;
                }
            }
            return numThreats;
        };

        const easyAI = (currentBoard) => {
            const winningMove = findWinningMove(aiPlayer, currentBoard);
            if (winningMove !== null) {
                return winningMove;
            }

            const blockingMove = findBlockingMove(humanPlayer, currentBoard);
            if (blockingMove !== null) {
                return blockingMove;
            }

            const emptyCells = getEmptyCells(currentBoard);
            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            if (emptyCells.length > 0) {
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                return emptyCells[randomIndex];
            }
            return null;
        };

        const mediumAI = (currentBoard) => {
            const winningMove = findWinningMove(aiPlayer, currentBoard);
            if (winningMove !== null) {
                return winningMove;
            }

            const blockingMove = findBlockingMove(humanPlayer, currentBoard);
            if (blockingMove !== null) {
                return blockingMove;
            }

            const emptyCells = getEmptyCells(currentBoard);
            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) >= 2) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) >= 2) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            if (currentBoard[12] === '') {
                return 12;
            }

            const corners = [0, 4, 20, 24];
            const availableCorners = corners.filter(index => currentBoard[index] === '');
            if (availableCorners.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableCorners.length);
                return availableCorners[randomIndex];
            }

            return easyAI(currentBoard);
        };

        const hardAI = (currentBoard) => {
            const emptyCells = getEmptyCells(currentBoard);
            if (emptyCells.length === 0) return null;

            let bestMove = -1;
            let bestScore = -Infinity;

            const minimax = (boardState, depth, isMaximizingPlayer) => {
                if (checkForWin(aiPlayer, boardState)) {
                    return 10000 - depth;
                }
                if (checkForWin(humanPlayer, boardState)) {
                    return -10000 + depth;
                }
                if (getEmptyCells(boardState).length === 0) {
                    return 0;
                }

                if (depth >= MINIMAX_MAX_DEPTH) {
                    return evaluateBoard(boardState);
                }

                const tempEmptyCells = getEmptyCells(boardState);

                if (isMaximizingPlayer) {
                    let maxEval = -Infinity;
                    for (const move of tempEmptyCells) {
                        boardState[move] = aiPlayer;
                        const evaluation = minimax(boardState, depth + 1, false);
                        boardState[move] = '';
                        maxEval = Math.max(maxEval, evaluation);
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of tempEmptyCells) {
                        boardState[move] = humanPlayer;
                        const evaluation = minimax(boardState, depth + 1, true);
                        boardState[move] = '';
                        minEval = Math.min(minEval, evaluation);
                    }
                    return minEval;
                }
            };

            const evaluateBoard = (boardState) => {
                let score = 0;

                for (const combination of winningCombinations) {
                    let aiCount = 0;
                    let humanCount = 0;
                    let emptyCount = 0;

                    for (const index of combination) {
                        if (boardState[index] === aiPlayer) aiCount++;
                        else if (boardState[index] === humanPlayer) humanCount++;
                        else emptyCount++;
                    }

                    if (humanCount === 0) {
                        if (aiCount === WIN_LENGTH - 1 && emptyCount >= 1) score += 1000;
                        if (aiCount === WIN_LENGTH - 2 && emptyCount >= 2) score += 100;
                        if (aiCount === WIN_LENGTH - 3 && emptyCount >= 3) score += 10;
                    }

                    if (aiCount === 0) {
                        if (humanCount === WIN_LENGTH - 1 && emptyCount >= 1) score -= 900;
                        if (humanCount === WIN_LENGTH - 2 && emptyCount >= 2) score -= 90;
                        if (humanCount === WIN_LENGTH - 3 && emptyCount >= 3) score -= 9;
                    }
                }
                return score;
            };

            for (const move of emptyCells) {
                aiBoard[move] = aiPlayer;
                const score = minimax(aiBoard, 0, false);
                aiBoard[move] = '';

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            if (bestMove === -1 || (emptyCells.length === BOARD_SIZE * BOARD_SIZE && bestScore <= 0)) {
                if (aiBoard[12] === '') {
                    return 12;
                }
                const corners = [0, 4, 20, 24];
                const availableCorners = corners.filter(index => aiBoard[index] === '');
                if (availableCorners.length > 0) {
                    const randomIndex = Math.floor(Math.random() * availableCorners.length);
                    return availableCorners[randomIndex];
                }
                return easyAI(aiBoard);
            }

            return bestMove;
        };

        const makeAIPlayerMove = () => {
            if (!aiGameActive) return;

            let move = null;
            if (aiDifficulty === 'easy') {
                move = easyAI(aiBoard);
            } else if (aiDifficulty === 'medium') {
                move = mediumAI(aiBoard);
            } else if (aiDifficulty === 'hard') {
                move = hardAI(aiBoard);
            }

            if (move !== null) {
                makeAIMoveInternal(move, aiPlayer);
                aiMovesHistory.push({ index: move, player: aiPlayer });
                checkAIGameStatus();
            }
        };

        const resetAIGame = () => {
            aiBoard = Array(25).fill('');
            aiCurrentPlayer = humanPlayer;
            aiGameActive = true;
            aiMovesHistory = [];
            updateStatus(`Au tour de : ${aiCurrentPlayer}`, 'ai');
            aiCells.forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('x', 'o');
            });
            aiGameScreen.classList.remove('hidden');
            if (aiDifficulty) {
                document.getElementById(`${aiDifficulty}-button`).classList.add('selected-difficulty');
            }
        };

        const leaveAIGame = () => {
            aiDifficulty = null;
            difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        };

        const handleDifficultySelection = (difficulty) => {
            aiDifficulty = difficulty;
            difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
            document.getElementById(`${difficulty}-button`).classList.add('selected-difficulty');
            resetAIGame();
        };

        // --- Online Game Logic ---

        let matchmakingListenerUnsubscribe = null;

        async function findOnlineMatch() {
            if (!db || !currentUserId || !isAuthReady) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }

            hideAllScreens();
            onlineSearchingScreen.classList.remove('hidden');

            const queueCollectionRef = collection(db, 'matchmaking_queue');

            try {
                const q = query(queueCollectionRef);
                const querySnapshot = await getDocs(q);

                let foundOpponentId = null;
                let foundOpponentDocRef = null;

                for (const docSnapshot of querySnapshot.docs) {
                    if (docSnapshot.id !== currentUserId) {
                        const queueEntry = docSnapshot.data();
                        if (queueEntry.status === 'searching' && queueEntry.gameId === null && queueEntry.opponentId === null) {
                            foundOpponentId = docSnapshot.id;
                            foundOpponentDocRef = doc(db, 'matchmaking_queue', foundOpponentId);
                            break;
                        }
                    }
                }

                if (foundOpponentId) {
                    console.log("Matchmaking: Opponent found:", foundOpponentId);
                    const gameRef = doc(collection(db, 'games'));
                    const gameId = gameRef.id;

                    await setDoc(gameRef, {
                        playerXId: foundOpponentId,
                        playerOId: currentUserId,
                        board: Array(25).fill(''),
                        currentPlayer: 'X',
                        status: 'active',
                        winner: null,
                        createdAt: serverTimestamp(),
                        lastMoveTime: serverTimestamp(),
                        moves: []
                    });

                    await updateDoc(foundOpponentDocRef, {
                        status: 'matched',
                        gameId: gameId,
                        opponentId: currentUserId
                    });

                    await deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {});

                    console.log(`Matchmaking: Game ${gameId} created. Player X: ${foundOpponentId}, Player O: ${currentUserId}`);
                    startGameOnline(gameId, 'O', foundOpponentId);

                } else {
                    console.log("Matchmaking: No opponent found, entering queue.");
                    await setDoc(doc(queueCollectionRef, currentUserId), {
                        timestamp: serverTimestamp(),
                        status: 'searching',
                        opponentId: null,
                        gameId: null
                    });
                    console.log(`Matchmaking: User ${currentUserId} added to queue.`);

                    matchmakingListenerUnsubscribe = onSnapshot(doc(queueCollectionRef, currentUserId), (docSnap) => {
                        if (docSnap.exists() && docSnap.data().gameId) {
                            const data = docSnap.data();
                            console.log("Matchmaking: Our queue entry updated. Game found:", data.gameId, "Opponent:", data.opponentId);
                            if (matchmakingListenerUnsubscribe) {
                                matchmakingListenerUnsubscribe();
                                matchmakingListenerUnsubscribe = null;
                            }
                            startGameOnline(data.gameId, 'X', data.opponentId);
                            deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {});
                        } else if (!docSnap.exists()) {
                            console.warn("Matchmaking: Notre entrée dans la file a été retirée. Si la partie ne démarre pas, il y a un problème.");
                            if (!currentOnlineGameId) {
                                showMessage("La recherche de partie a été annulée ou a échoué. Veuillez réessayer.", () => {
                                    hideAllScreens();
                                    homeScreen.classList.remove('hidden');
                                    if (isAuthReady && currentUserId) {
                                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                                    }
                                });
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("Matchmaking error:", error);
                showMessage("Erreur lors de la recherche de partie: " + error.message, () => {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
                if (currentUserId) {
                    deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {});
                }
            }
        }

        async function cancelOnlineSearch() {
            if (matchmakingListenerUnsubscribe) {
                matchmakingListenerUnsubscribe();
                matchmakingListenerUnsubscribe = null;
            }
            if (currentUserId) {
                await deleteDoc(doc(db, 'matchmaking_queue', currentUserId)).catch(e => console.error("Error deleting queue entry:", e));
            }
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            showMessage("Recherche de partie annulée.");
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        }

        async function startGameOnline(gameId, playerRole, opponentId) {
            console.log(`Starting online game: ${gameId} as player ${playerRole} against ${opponentId}`);
            currentOnlineGameId = gameId;
            currentOnlinePlayerRole = playerRole;
            onlineOpponentUserId = opponentId;
            onlineGameActive = true;
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';

            hideAllScreens();
            onlineGameScreen.classList.remove('hidden');
            document.getElementById('online-game-id-display').textContent = gameId;
            document.getElementById('online-player-role').textContent = playerRole;

            // Fetch opponent's profile to display their username, Elo, and level
            onlineOpponentProfile = await fetchUserProfile(onlineOpponentUserId);
            if (onlineOpponentProfile) {
                document.getElementById('online-opponent-username').textContent = onlineOpponentProfile.username || 'Inconnu';
                document.getElementById('online-opponent-elo').textContent = onlineOpponentProfile.elo || 'N/A';
                document.getElementById('online-opponent-level').textContent = onlineOpponentProfile.level || 'N/A';
            } else {
                document.getElementById('online-opponent-username').textContent = 'Chargement...';
                document.getElementById('online-opponent-elo').textContent = 'N/A';
                document.getElementById('online-opponent-level').textContent = 'N/A';
            }


            createCells('online-board', handleOnlineCellClick);
            updateStatus(`Au tour de : X`, 'online');
            resetOnlineBoardUI();

            const gameRef = doc(db, 'games', gameId);
            onlineGameListenerUnsubscribe = onSnapshot(gameRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    console.log("Online game update received:", gameData);
                    console.log("Received gameData.moves:", gameData.moves);
                    console.log("Current User ID (in listener):", currentUserId);
                    console.log("Current Player Role (in listener):", currentOnlinePlayerRole);

                    onlineBoard = gameData.board;
                    onlineCurrentTurn = gameData.currentPlayer;
                    onlineGameActive = gameData.status === 'active';

                    for (let i = 0; i < onlineBoard.length; i++) {
                        const cell = onlineCells[i];
                        cell.innerHTML = onlineBoard[i];
                        cell.classList.remove('x', 'o');
                        if (onlineBoard[i] !== '') {
                            cell.classList.add(onlineBoard[i].toLowerCase());
                        }
                    }

                    if (gameData.status === 'finished' || gameData.status === 'abandoned') {
                        onlineGameActive = false;
                        if (onlineGameListenerUnsubscribe) {
                            onlineGameListenerUnsubscribe();
                            onlineGameListenerUnsubscribe = null;
                        }

                        // Fetch the final game data one last time to ensure we have the complete moves history
                        const finalGameDocSnap = await getDoc(gameRef);
                        const finalGameData = finalGameDocSnap.exists() ? finalGameDocSnap.data() : gameData;

                        let statusToShow = '';
                        if (gameData.winner === currentOnlinePlayerRole) {
                            statusToShow = 'win';
                        } else if (gameData.winner === 'draw') {
                            statusToShow = 'draw';
                        } else {
                            statusToShow = 'loss';
                        }

                        showGameEndScreen(statusToShow, gameData.winner, 'online', [...finalGameData.board], finalGameData.moves);

                    } else {
                        updateStatus(`Au tour de : ${onlineCurrentTurn}`, 'online');
                    }

                } else {
                    console.log("Online game document deleted.");
                    showMessage("La partie a été annulée ou l'adversaire a quitté.", () => {
                        leaveOnlineGame();
                    });
                }
            }, (error) => {
                console.error("Error listening to online game:", error);
                showMessage("Erreur de connexion à la partie en ligne: " + error.message, () => {
                    leaveOnlineGame();
                });
            });
        }

        async function handleOnlineCellClick(event) {
            const clickedCellIndex = parseInt(event.target.dataset.index);

            if (!onlineGameActive || onlineBoard[clickedCellIndex] !== '' || onlineCurrentTurn !== currentOnlinePlayerRole) {
                return;
            }

            const newBoard = [...onlineBoard];
            newBoard[clickedCellIndex] = currentOnlinePlayerRole;

            const hasWon = checkForWin(currentOnlinePlayerRole, newBoard);
            const hasDraw = checkForDraw(newBoard);

            let nextPlayer = currentOnlinePlayerRole === 'X' ? 'O' : 'X';
            let gameStatus = 'active';
            let winner = null;

            if (hasWon) {
                gameStatus = 'finished';
                winner = currentOnlinePlayerRole;
            } else if (hasDraw) {
                gameStatus = 'finished';
                winner = 'draw';
            }

            try {
                await updateDoc(doc(db, 'games', currentOnlineGameId), {
                    board: newBoard,
                    currentPlayer: nextPlayer,
                    status: gameStatus,
                    winner: winner,
                    lastMoveTime: serverTimestamp(),
                    moves: arrayUnion({ index: clickedCellIndex, player: currentOnlinePlayerRole }) // Add move to history
                });
                console.log("Firestore mis à jour avec le mouvement.");
            } catch (error) {
                console.error("Erreur lors de l'envoi du mouvement:", error);
                showMessage("Erreur lors de l'envoi du mouvement: " + error.message);
            }
        }

        function resetOnlineBoardUI() {
            if (onlineCells) {
                onlineCells.forEach(cell => {
                    cell.innerHTML = '';
                    cell.classList.remove('x', 'o');
                });
            }
        }

        async function resetOnlineGame() {
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';
            onlineGameActive = true;
            resetOnlineBoardUI();
            updateStatus(`Au tour de : X`, 'online');
            findOnlineMatch(); // Start a new matchmaking search
        }

        async function leaveOnlineGame() {
            if (onlineGameListenerUnsubscribe) {
                onlineGameListenerUnsubscribe();
                onlineGameListenerUnsubscribe = null;
            }
            if (currentOnlineGameId && db) {
                try {
                    const gameDoc = await getDoc(doc(db, 'games', currentOnlineGameId));
                    if (gameDoc.exists() && gameDoc.data().status === 'active') {
                        // Mark game as abandoned and assign win to opponent
                        await updateDoc(doc(db, 'games', currentOnlineGameId), {
                            status: 'abandoned',
                            winner: currentOnlinePlayerRole === 'X' ? 'O' : 'X', // Opponent wins
                            lastMoveTime: serverTimestamp()
                        });
                        console.log("Partie en ligne marquée comme abandonnée.");
                        // Update current user's stats for a loss
                        updateUserProfileStats(currentUserId, 'loss', onlineOpponentProfile ? onlineOpponentProfile.elo : null);
                    }
                } catch (error) {
                    console.error("Erreur lors de la tentative d'abandon de partie:", error);
                }
            }

            // Reset online game state variables
            currentOnlineGameId = null;
            currentOnlinePlayerRole = null;
            onlineOpponentUserId = null;
            onlineOpponentProfile = null;
            onlineGameActive = false;
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';

            hideAllScreens();
            homeScreen.classList.remove('hidden');
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        }


        // --- Fonctions de gestion du classement ---
        async function fetchLeaderboard() {
            if (!db || !isAuthReady) {
                leaderboardList.innerHTML = '<div class="text-center p-4 text-red-500">Erreur: Impossible de charger le classement. Firebase non prêt.</div>';
                return;
            }

            leaderboardList.innerHTML = '<div class="text-center p-4 text-gray-500">Chargement du classement...</div>';

            try {
                const usersCollectionRef = collection(db, `artifacts/${appId}/users`);
                const usersSnapshot = await getDocs(usersCollectionRef);
                console.log("Firebase: Nombre de documents parents utilisateur trouvés :", usersSnapshot.docs.length);

                const users = [];

                for (const userDoc of usersSnapshot.docs) {
                    const profileDocRef = doc(userDoc.ref, 'profile', 'data');
                    const profileSnap = await getDoc(profileDocRef);

                    if (profileSnap.exists()) {
                        const profileData = profileSnap.data();
                        users.push({
                            id: userDoc.id,
                            username: profileData.username || 'Joueur Inconnu',
                            elo: profileData.elo || 0
                        });
                    }
                }

                users.sort((a, b) => b.elo - a.elo); // Sort by Elo descending

                displayLeaderboard(users);

            } catch (error) {
                console.error("Erreur lors de la récupération du classement:", error);
                leaderboardList.innerHTML = '<div class="text-center p-4 text-red-500">Erreur lors du chargement du classement.</div>';
                showMessage("Erreur lors du chargement du classement: " + error.message);
            }
        }

        function displayLeaderboard(users) {
            leaderboardList.innerHTML = '';

            if (users.length === 0) {
                leaderboardList.innerHTML = '<div class="text-center p-4 text-gray-500">Aucun joueur dans le classement pour le moment.</div>';
                return;
            }

            users.forEach((user, index) => {
                const rank = index + 1;
                const listItem = document.createElement('div');
                listItem.classList.add('leaderboard-item');
                listItem.dataset.userId = user.id; // Store user ID for click handler

                if (rank === 1) {
                    listItem.classList.add('top-1');
                } else if (rank <= 3) {
                    listItem.classList.add('top-3');
                }

                listItem.innerHTML = `
                    <span class="rank">${rank}.</span>
                    <span class="username">${user.username}</span>
                    <span class="elo">${user.elo} Elo</span>
                `;
                listItem.addEventListener('click', () => showUserProfileModal(user.id));
                leaderboardList.appendChild(listItem);
            });
        }

        function showLeaderboardScreen() {
            hideAllScreens();
            leaderboardScreen.classList.remove('hidden');
            fetchLeaderboard();
        }

        // --- Fonctions de gestion de l'historique des parties ---
        const HISTORY_STORAGE_KEY = 'oxoArenaGameHistory';
        const MAX_HISTORY_ITEMS = 10;

        function saveGameToHistory(mode, finalStatus, opponent, finalBoardState, movesHistory, boardSize, gameId = null) {
            let history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '[]');

            // Prevent duplicate entries for online games if they are already saved by the listener
            if (gameId) {
                if (history.some(game => game.gameId === gameId)) {
                    console.log(`Partie en ligne ${gameId} déjà sauvegardée dans l'historique local. Ignoré.`);
                    return;
                }
            }

            const newGame = {
                id: gameId || Date.now().toString(), // Use gameId for online, timestamp for local/AI
                mode: mode,
                date: new Date().toLocaleString(),
                opponent: opponent,
                status: finalStatus,
                finalBoard: finalBoardState,
                moves: movesHistory,
                boardSize: boardSize,
                gameId: gameId // Store gameId for online games
            };
            history.unshift(newGame); // Add to the beginning
            history = history.slice(0, MAX_HISTORY_ITEMS); // Keep only the last MAX_HISTORY_ITEMS
            localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
            console.log("Partie sauvegardée dans l'historique local:", newGame);
        }

        function showGameHistoryScreen() {
            hideAllScreens();
            historyScreen.classList.remove('hidden');
            renderGameHistory();
        }

        function renderGameHistory() {
            gamesHistoryList.innerHTML = '';
            const history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '[]');

            if (history.length === 0) {
                gamesHistoryList.innerHTML = '<p class="text-center p-4 text-gray-600">Aucune partie jouée pour le moment.</p>';
                return;
            }

            history.forEach(game => {
                const gameItem = document.createElement('div');
                gameItem.className = 'bg-gray-50 p-4 rounded-lg shadow flex flex-col items-start space-y-2 cursor-pointer hover:bg-gray-100 transition-colors';
                gameItem.dataset.gameId = game.id;

                gameItem.addEventListener('click', () => showHistoryDetail(game));

                let statusClass = '';
                let statusText = '';
                if (game.status === 'won') {
                    statusClass = 'text-green-600';
                    statusText = 'Victoire';
                } else if (game.status === 'lost') {
                    statusClass = 'text-red-600';
                    statusText = 'Défaite';
                } else {
                    statusClass = 'text-blue-600';
                    statusText = 'Nul';
                }

                gameItem.innerHTML = `
                    <div class="w-full flex justify-between items-center">
                        <span class="text-sm text-gray-500">${game.date}</span>
                        <span class="font-semibold ${statusClass}">${statusText}</span>
                    </div>
                    <div class="text-lg font-medium text-gray-800">Mode: ${game.mode === 'local' ? 'Local' : (game.mode === 'ai' ? 'Vs IA' : 'En ligne')}</div>
                    <div class="text-md text-gray-700">Adversaire: ${game.opponent}</div>
                    <div class="w-full flex justify-center mt-2">
                        ${createMiniBoardHTML(game.finalBoard, game.boardSize)}
                    </div>
                `;
                gamesHistoryList.appendChild(gameItem);
            });
        }

        function createMiniBoardHTML(boardState, boardSize) {
            const cellSizePx = 20;
            const gapPx = 1;

            let boardHTML = `<div class="grid w-full aspect-square bg-gray-300 border border-gray-400 rounded-sm overflow-hidden" style="grid-template-columns: repeat(${boardSize}, 1fr); gap: ${gapPx}px;">`;
            boardState.forEach(cell => {
                let content = '';
                let cellClass = '';
                if (cell === 'X') {
                    content = 'X';
                    cellClass = 'text-[#FFD700]';
                } else if (cell === 'O') {
                    content = 'O';
                    cellClass = 'text-[#1A2B3C]';
                }
                boardHTML += `<div class="flex items-center justify-center bg-white font-bold ${cellClass}" style="font-size: ${cellSizePx * 0.8}px;">${content}</div>`;
            });
            boardHTML += `</div>`;
            return boardHTML;
        }

        // --- History Detail Screen Logic ---
        let currentDetailGameMoves = [];
        let currentDetailMoveIndex = -1;

        function showHistoryDetail(gameData) {
            hideAllScreens();
            historyDetailScreen.classList.remove('hidden');

            document.getElementById('detail-mode').textContent = gameData.mode === 'local' ? 'Local' : (gameData.mode === 'ai' ? 'Vs IA' : 'En ligne');
            document.getElementById('detail-date').textContent = gameData.date;
            document.getElementById('detail-opponent').textContent = gameData.opponent;
            let statusText = '';
            if (gameData.status === 'won') statusText = 'Victoire';
            else if (gameData.status === 'lost') statusText = 'Défaite';
            else statusText = 'Nul';
            document.getElementById('detail-status').textContent = statusText;

            createCells('detail-board', null); // Create cells without click handler
            currentDetailGameMoves = gameData.moves || [];
            currentDetailMoveIndex = -1; // Start before the first move
            updateDetailBoardDisplay();
        }

        function updateDetailBoardDisplay() {
            const tempBoard = Array(BOARD_SIZE * BOARD_SIZE).fill('');
            for (let i = 0; i <= currentDetailMoveIndex; i++) {
                const move = currentDetailGameMoves[i];
                if (move) {
                    tempBoard[move.index] = move.player;
                }
            }

            const detailCells = Array.from(document.querySelectorAll('#detail-board .cell'));
            detailCells.forEach((cell, index) => {
                cell.innerHTML = tempBoard[index];
                cell.classList.remove('x', 'o');
                if (tempBoard[index] === 'X') {
                    cell.classList.add('x');
                } else if (tempBoard[index] === 'O') {
                    cell.classList.add('o');
                }
            });

            moveCounter.textContent = `Coup ${currentDetailMoveIndex + 1}/${currentDetailGameMoves.length}`;
            prevMoveButton.disabled = currentDetailMoveIndex <= -1;
            nextMoveButton.disabled = currentDetailMoveIndex >= currentDetailGameMoves.length - 1;
        }


        // --- Helper for screen management ---
        function hideAllScreens() {
            homeScreen.classList.add('hidden');
            localGameScreen.classList.add('hidden');
            aiGameScreen.classList.add('hidden');
            onlineSearchingScreen.classList.add('hidden');
            onlineGameScreen.classList.add('hidden');
            gameEndOverlay.classList.add('hidden');
            gameEndBanner.classList.add('hidden');
            leaderboardScreen.classList.add('hidden');
            historyScreen.classList.add('hidden');
            historyDetailScreen.classList.add('hidden');
            friendsScreen.classList.add('hidden'); // Hide friends screen
            userProfileModalOverlay.classList.add('hidden'); // Hide profile modal
            notificationModalOverlay.classList.add('hidden'); // Hide notification modal
            chatModalOverlay.classList.add('hidden'); // Hide chat modal
        }

        // --- FRIEND SYSTEM FUNCTIONS ---

        // Utility to get ordered user IDs for consistent document IDs
        function getOrderedUserIds(userId1, userId2) {
            return userId1 < userId2 ? { user1Id: userId1, user2Id: userId2 } : { user1Id: userId2, user2Id: userId1 };
        }

        // Function to fetch all user profiles (for search and friends list display)
        async function fetchAllUserProfiles() {
            if (!db || !isAuthReady) {
                console.warn("Firebase non prêt pour la récupération des profils.");
                return;
            }
            try {
                const usersCollectionRef = collection(db, `artifacts/${appId}/users`);
                const querySnapshot = await getDocs(usersCollectionRef);
                allUserProfiles = {}; // Clear previous data
                for (const userDoc of querySnapshot.docs) {
                    const profileDocRef = doc(userDoc.ref, 'profile', 'data');
                    const profileSnap = await getDoc(profileDocRef);
                    if (profileSnap.exists()) {
                        allUserProfiles[userDoc.id] = { id: userDoc.id, ...profileSnap.data() };
                    }
                }
                console.log("Tous les profils utilisateurs chargés:", Object.keys(allUserProfiles).length);
            } catch (error) {
                console.error("Erreur lors du chargement de tous les profils utilisateurs:", error);
                showMessage("Erreur lors du chargement des profils pour la recherche: " + error.message);
            }
        }

        // Function to display a user's profile in the modal
        async function showUserProfileModal(targetUserId) {
            if (!db || !currentUserId || !isAuthReady || targetUserId === currentUserId) {
                // If trying to view own profile, or not ready, just show main profile or do nothing
                if (targetUserId === currentUserId) {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    return;
                }
                showMessage("Impossible d'afficher le profil. Connexion ou ID invalide.");
                return;
            }

            // Try to get profile from cache, otherwise fetch
            const targetProfile = allUserProfiles[targetUserId] || await fetchUserProfile(targetUserId);
            if (!targetProfile) {
                showMessage("Profil utilisateur introuvable.");
                return;
            }

            // Update modal content
            modalProfileUsername.textContent = targetProfile.username || 'Inconnu';
            modalProfileId.textContent = targetUserId;
            modalProfileElo.textContent = targetProfile.elo || 0;
            modalProfileLevel.textContent = `${targetProfile.level || 0}/${MAX_LEVEL}`;
            modalProfileGamesPlayed.textContent = targetProfile.gamesPlayed || 0;
            modalProfileWins.textContent = targetProfile.wins || 0;
            modalProfileLosses.textContent = targetProfile.losses || 0;
            modalProfileDraws.textContent = targetProfile.draws || 0;

            // Display last online status
            if (targetProfile.lastOnline && targetProfile.lastOnline instanceof Object && 'toDate' in targetProfile.lastOnline) {
                const lastOnlineDate = targetProfile.lastOnline.toDate();
                const now = new Date();
                const diffMs = now.getTime() - lastOnlineDate.getTime();
                const minutes = Math.floor(diffMs / (1000 * 60));
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);

                let statusText = '';
                if (minutes < 5) {
                    statusText = 'En ligne';
                    modalProfileLastOnline.classList.add('text-green-600');
                    modalProfileLastOnline.classList.remove('text-gray-500');
                } else if (minutes < 60) {
                    statusText = `Il y a ${minutes} minute${minutes > 1 ? 's' : ''}`;
                    modalProfileLastOnline.classList.remove('text-green-600');
                    modalProfileLastOnline.classList.add('text-gray-500');
                } else if (hours < 24) {
                    statusText = `Il y a ${hours} heure${hours > 1 ? 's' : ''}`;
                    modalProfileLastOnline.classList.remove('text-green-600');
                    modalProfileLastOnline.classList.add('text-gray-500');
                } else {
                    statusText = `Il y a ${days} jour${days > 1 ? 's' : ''}`;
                    modalProfileLastOnline.classList.remove('text-green-600');
                    modalProfileLastOnline.classList.add('text-gray-500');
                }
                modalProfileLastOnline.textContent = statusText;
            } else {
                modalProfileLastOnline.textContent = 'Non disponible';
                modalProfileLastOnline.classList.add('text-gray-500');
                modalProfileLastOnline.classList.remove('text-green-600');
            }


            // Hide all action buttons initially
            sendFriendRequestButton.classList.add('hidden');
            cancelFriendRequestButton.classList.add('hidden');
            acceptFriendRequestButton.classList.add('hidden');
            declineFriendRequestButton.classList.add('hidden');
            unfriendButton.classList.add('hidden');
            blockUserButton.classList.add('hidden');
            unblockUserButton.classList.add('hidden');
            proposeGameButton.classList.add('hidden');
            openChatButton.classList.add('hidden');

            // Determine friendship status and show relevant buttons
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, targetUserId);
            const q = query(
                collection(db, "friendships"),
                where("user1Id", "==", user1Id),
                where("user2Id", "==", user2Id)
            );
            const querySnapshot = await getDocs(q);

            let friendshipStatus = null;
            let friendshipDocId = null;

            if (!querySnapshot.empty) {
                const docData = querySnapshot.docs[0].data();
                friendshipStatus = docData.status;
                friendshipDocId = querySnapshot.docs[0].id;
                currentFriendshipDocId = friendshipDocId; // Store for later use
            } else {
                currentFriendshipDocId = null;
            }

            // Display buttons based on status
            if (friendshipStatus === 'pending') {
                if (querySnapshot.docs[0].data().senderId === targetUserId) { // Target sent request to current user
                    acceptFriendRequestButton.classList.remove('hidden');
                    declineFriendRequestButton.classList.remove('hidden');
                } else { // Current user sent request to target
                    cancelFriendRequestButton.classList.remove('hidden');
                }
            } else if (friendshipStatus === 'accepted') {
                unfriendButton.classList.remove('hidden');
                proposeGameButton.classList.remove('hidden');
                openChatButton.classList.remove('hidden');
                blockUserButton.classList.remove('hidden'); // Can block an accepted friend
            } else if (friendshipStatus === 'blocked') {
                if (querySnapshot.docs[0].data().senderId === currentUserId) { // Current user blocked target
                    unblockUserButton.classList.remove('hidden');
                } else { // Target blocked current user (cannot unblock from here)
                    showMessage(`${targetProfile.username} vous a bloqué.`);
                }
            } else { // No existing friendship
                sendFriendRequestButton.classList.remove('hidden');
                blockUserButton.classList.remove('hidden'); // Can block someone not yet a friend
            }

            // Show the modal
            userProfileModalOverlay.classList.remove('hidden');
        }

        // --- Friend System Firebase Operations ---

        async function sendFriendRequest(receiverId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, receiverId);
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id));
            const querySnapshot = await getDocs(q);

            try {
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    const currentStatus = querySnapshot.docs[0].data().status;
                    const senderOfExisting = querySnapshot.docs[0].data().senderId;

                    if (currentStatus === 'pending') {
                        if (senderOfExisting === currentUserId) {
                            showMessage("Vous avez déjà envoyé une demande à cet utilisateur.");
                        } else { // Receiver sent request to current user, now current user sends back -> accept
                            await updateDoc(docRef, { status: "accepted", timestamp: serverTimestamp() });
                            showMessage("Demande d'ami acceptée !");
                        }
                    } else if (currentStatus === 'accepted') {
                        showMessage("Vous êtes déjà amis.");
                    } else if (currentStatus === 'blocked') {
                        if (senderOfExisting === currentUserId) { // Current user blocked target
                            showMessage("Vous avez bloqué cet utilisateur. Débloquez-le d'abord.");
                        } else { // Target blocked current user
                            showMessage("Cet utilisateur vous a bloqué. Impossible d'envoyer une demande.");
                        }
                    }
                } else {
                    // Use addDoc to let Firestore generate a unique ID for the friendship document
                    await addDoc(collection(db, "friendships"), {
                        user1Id: user1Id,
                        user2Id: user2Id,
                        status: "pending",
                        senderId: currentUserId, // Store who sent the request
                        timestamp: serverTimestamp()
                    });
                    showMessage("Demande d'ami envoyée !");
                }
            } catch (error) {
                console.error("Erreur lors de l'envoi de la demande d'ami:", error);
                showMessage("Erreur lors de l'envoi de la demande: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden'); // Close modal after action
            }
        }

        async function acceptFriendRequest(requesterId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, requesterId);
            // Query for the pending request where the current user is the receiver
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id), where("status", "==", "pending"));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await updateDoc(docRef, { status: "accepted", timestamp: serverTimestamp() });
                    showMessage("Demande d'ami acceptée !");
                } else {
                    showMessage("Aucune demande en attente trouvée.");
                }
            } catch (error) {
                console.error("Erreur lors de l'acceptation de la demande d'ami:", error);
                showMessage("Erreur lors de l'acceptation: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
                notificationModalOverlay.classList.add('hidden'); // Also close notification modal
            }
        }

        async function declineFriendRequest(requesterId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, requesterId);
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id), where("status", "==", "pending"));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await deleteDoc(docRef); // Simply delete the pending request
                    showMessage("Demande d'ami refusée.");
                } else {
                    showMessage("Aucune demande en attente trouvée.");
                }
            } catch (error) {
                console.error("Erreur lors du refus de la demande d'ami:", error);
                showMessage("Erreur lors du refus: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
                notificationModalOverlay.classList.add('hidden');
            }
        }

        async function unfriend(targetId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, targetId);
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id), where("status", "==", "accepted"));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await deleteDoc(docRef);
                    showMessage(`Vous n'êtes plus ami avec ${allUserProfiles[targetId]?.username || targetId}.`);
                } else {
                    showMessage("Vous n'êtes pas ami avec cet utilisateur.");
                }
            } catch (error) {
                console.error("Erreur lors du défriending:", error);
                showMessage("Erreur lors du défriending: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
            }
        }

        async function blockUser(targetId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, targetId);
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await updateDoc(docRef, { status: "blocked", senderId: currentUserId, timestamp: serverTimestamp() });
                    showMessage(`Vous avez bloqué ${allUserProfiles[targetId]?.username || targetId}.`);
                } else {
                    // If no existing friendship, create a new one with blocked status
                    await addDoc(collection(db, "friendships"), {
                        user1Id: user1Id,
                        user2Id: user2Id,
                        status: "blocked",
                        senderId: currentUserId, // Store who initiated the block
                        timestamp: serverTimestamp()
                    });
                    showMessage(`Vous avez bloqué ${allUserProfiles[targetId]?.username || targetId}.`);
                }
            } catch (error) {
                console.error("Erreur lors du blocage de l'utilisateur:", error);
                showMessage("Erreur lors du blocage: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
            }
        }

        async function unblockUser(targetId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, targetId);
            // Only unblock if current user was the one who blocked
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id), where("status", "==", "blocked"), where("senderId", "==", currentUserId));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await deleteDoc(docRef); // Remove the block entry
                    showMessage(`Vous avez débloqué ${allUserProfiles[targetId]?.username || targetId}.`);
                } else {
                    showMessage("Cet utilisateur n'est pas bloqué par vous.");
                }
            } catch (error) {
                console.error("Erreur lors du déblocage de l'utilisateur:", error);
                showMessage("Erreur lors du déblocage: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
            }
        }

        // --- Friend List and Search UI ---

        function showFriendsScreen() {
            hideAllScreens();
            friendsScreen.classList.remove('hidden');
            renderFriendsList(); // Render current friends
            userSearchResults.classList.add('hidden'); // Hide search results initially
            userSearchInput.value = ''; // Clear search input
        }

        async function renderFriendsList() {
            if (!db || !currentUserId || !isAuthReady) {
                friendsListElement.innerHTML = '<p class="p-4 text-red-500 text-center">Connexion Firebase non établie.</p>';
                return;
            }

            friendsListElement.innerHTML = '<p class="p-4 text-gray-500 text-center">Chargement de vos amis...</p>';

            try {
                // Query for friendships where current user is either user1Id or user2Id AND status is 'accepted'
                // FIX: Wrap or() and where() in an and() statement
                const q = query(
                    collection(db, "friendships"),
                    and(
                        or(
                            where("user1Id", "==", currentUserId),
                            where("user2Id", "==", currentUserId)
                        ),
                        where("status", "==", "accepted")
                    )
                );
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    friendsListElement.innerHTML = '<p class="p-4 text-gray-500 text-center">Vous n\'avez pas encore d\'amis.</p>';
                    return;
                }

                friendsListElement.innerHTML = ''; // Clear loading message

                const friends = [];
                for (const docSnap of querySnapshot.docs) {
                    const data = docSnap.data();
                    const friendId = data.user1Id === currentUserId ? data.user2Id : data.user1Id;
                    // Try to get friend profile from cached allUserProfiles, otherwise fetch
                    const friendProfile = allUserProfiles[friendId] || await fetchUserProfile(friendId);
                    if (friendProfile) {
                        friends.push({ id: friendId, username: friendProfile.username, lastOnline: friendProfile.lastOnline });
                    }
                }

                // Sort friends: online first, then alphabetically by username
                friends.sort((a, b) => {
                    const fiveMinutesAgo = new Date().getTime() - (5 * 60 * 1000);
                    const onlineA = a.lastOnline && (a.lastOnline.toDate().getTime() > fiveMinutesAgo);
                    const onlineB = b.lastOnline && (b.lastOnline.toDate().getTime() > fiveMinutesAgo);

                    if (onlineA && !onlineB) return -1; // A is online, B is not
                    if (!onlineA && onlineB) return 1;  // B is online, A is not
                    return (a.username || '').localeCompare(b.username || ''); // Alphabetical if both are online/offline
                });


                friends.forEach(friend => {
                    const friendItem = document.createElement('div');
                    friendItem.classList.add('user-list-item');
                    friendItem.dataset.userId = friend.id;
                    friendItem.addEventListener('click', () => showUserProfileModal(friend.id));

                    let statusIndicatorClass = '';
                    let statusText = '';
                    if (friend.lastOnline && (new Date().getTime() - friend.lastOnline.toDate().getTime() < 5 * 60 * 1000)) {
                        statusIndicatorClass = 'online';
                        statusText = 'En ligne';
                    } else if (friend.lastOnline) {
                        const lastOnlineDate = friend.lastOnline.toDate();
                        const diffMs = new Date().getTime() - lastOnlineDate.getTime();
                        const minutes = Math.floor(diffMs / (1000 * 60));
                        const hours = Math.floor(minutes / 60);
                        const days = Math.floor(hours / 24);

                        if (minutes < 60) {
                            statusText = `Il y a ${minutes} min`;
                        } else if (hours < 24) {
                            statusText = `Il y a ${hours} h`;
                        } else {
                            statusText = `Il y a ${days} j`;
                        }
                    } else {
                        statusText = 'Hors ligne';
                    }

                    friendItem.innerHTML = `
                        <span class="status-indicator ${statusIndicatorClass}"></span>
                        <span class="username-display">${friend.username || 'Inconnu'}</span>
                        <span class="text-xs text-gray-500 ml-auto">${statusText}</span>
                    `;
                    friendsListElement.appendChild(friendItem);
                });

            } catch (error) {
                console.error("Erreur lors du rendu de la liste d'amis:", error);
                friendsListElement.innerHTML = '<p class="p-4 text-red-500 text-center">Erreur lors du chargement des amis.</p>';
            }
        }

        async function searchUsers() {
            if (!db || !currentUserId || !isAuthReady) {
                userSearchResults.innerHTML = '<p class="p-4 text-red-500 text-center">Connexion Firebase non établie.</p>';
                userSearchResults.classList.remove('hidden');
                return;
            }

            const searchTerm = userSearchInput.value.trim().toLowerCase();
            userSearchResults.innerHTML = ''; // Clear previous results
            userSearchResults.classList.remove('hidden');

            if (searchTerm.length < 3) {
                userSearchResults.innerHTML = '<p class="p-4 text-gray-500 text-center">Tapez au moins 3 caractères.</p>';
                return;
            }

            // Filter from the cached allUserProfiles
            const results = Object.values(allUserProfiles).filter(profile =>
                profile.id !== currentUserId && // Exclude current user from search results
                (profile.username.toLowerCase().includes(searchTerm) || profile.id.toLowerCase().includes(searchTerm))
            );

            if (results.length === 0) {
                userSearchResults.innerHTML = '<p class="p-4 text-gray-500 text-center">Aucun utilisateur trouvé.</p>';
                return;
            }

            results.forEach(user => {
                const userItem = document.createElement('div');
                userItem.classList.add('user-list-item');
                userItem.dataset.userId = user.id;
                userItem.addEventListener('click', () => showUserProfileModal(user.id));

                userItem.innerHTML = `
                    <span class="username-display">${user.username}</span>
                    <span class="user-id-display">${user.id}</span>
                `;
                userSearchResults.appendChild(userItem);
            });
        }

        // --- Notification System ---

        let pendingFriendRequests = [];
        let gameProposals = []; // Not implemented yet, but placeholder for future

        function setupFriendshipListeners() {
            if (!db || !currentUserId) return;

            // Unsubscribe existing listeners if any to prevent duplicates
            if (friendsListenerUnsubscribe) friendsListenerUnsubscribe();
            if (pendingRequestsListenerUnsubscribe) pendingRequestsListenerUnsubscribe();

            // Listener for accepted friends (for friends list)
            // FIX: Wrap or() and where() in an and() statement
            friendsListenerUnsubscribe = onSnapshot(
                query(
                    collection(db, "friendships"),
                    and(
                        or(
                            where("user1Id", "==", currentUserId),
                            where("user2Id", "==", currentUserId)
                        ),
                        where("status", "==", "accepted")
                    )
                ),
                (snapshot) => {
                    renderFriendsList(); // Re-render friends list on any change
                },
                (error) => {
                    console.error("Erreur d'écoute des amis:", error);
                }
            );

            // Listener for pending friend requests (for notifications)
            pendingRequestsListenerUnsubscribe = onSnapshot(
                query(
                    collection(db, "friendships"),
                    where("user2Id", "==", currentUserId), // Current user is the receiver
                    where("status", "==", "pending")
                ),
                async (snapshot) => {
                    pendingFriendRequests = []; // Clear previous requests
                    for (const docSnap of snapshot.docs) {
                        const data = docSnap.data();
                        // Fetch sender's profile to get username for display
                        const senderProfile = allUserProfiles[data.senderId] || await fetchUserProfile(data.senderId);
                        if (senderProfile) {
                            pendingFriendRequests.push({
                                id: docSnap.id,
                                senderId: data.senderId,
                                senderUsername: senderProfile.username,
                                type: 'friend_request'
                            });
                        }
                    }
                    updateNotificationCount();
                    if (!notificationModalOverlay.classList.contains('hidden')) {
                        renderNotifications(); // Re-render if modal is open
                    }
                },
                (error) => {
                    console.error("Erreur d'écoute des demandes d'amis:", error);
                }
            );
        }

        function updateNotificationCount() {
            const totalNotifications = pendingFriendRequests.length + gameProposals.length; // Add game proposals later
            if (totalNotifications > 0) {
                notificationCount.textContent = totalNotifications;
                notificationCount.classList.remove('hidden');
            } else {
                notificationCount.classList.add('hidden');
            }
        }

        function showNotificationModal() {
            notificationModalOverlay.classList.remove('hidden');
            renderNotifications();
        }

        function renderNotifications() {
            notificationList.innerHTML = ''; // Clear previous notifications
            if (pendingFriendRequests.length === 0 && gameProposals.length === 0) {
                notificationList.innerHTML = '<p class="p-4 text-gray-500 text-center">Aucune notification.</p>';
                return;
            }

            pendingFriendRequests.forEach(request => {
                const item = document.createElement('div');
                item.classList.add('notification-item');
                item.innerHTML = `
                    <span>Demande d'ami de <span class="font-semibold">${request.senderUsername}</span></span>
                    <div class="actions">
                        <button class="accept-button" data-sender-id="${request.senderId}">Accepter</button>
                        <button class="decline-button" data-sender-id="${request.senderId}">Refuser</button>
                    </div>
                `;
                item.querySelector('.accept-button').addEventListener('click', () => acceptFriendRequest(request.senderId));
                item.querySelector('.decline-button').addEventListener('click', () => declineFriendRequest(request.senderId));
                notificationList.appendChild(item);
            });

            // Add game proposals here later
            gameProposals.forEach(proposal => {
                const item = document.createElement('div');
                item.classList.add('notification-item');
                item.innerHTML = `
                    <span>Invitation de partie de <span class="font-semibold">${proposal.senderUsername}</span></span>
                    <div class="actions">
                        <button class="accept-button bg-purple-600 hover:bg-purple-700" data-game-id="${proposal.gameId}">Accepter</button>
                        <button class="decline-button" data-game-id="${proposal.gameId}">Refuser</button>
                    </div>
                `;
                // Add event listeners for game proposal acceptance/rejection
                notificationList.appendChild(item);
            });
        }

        // --- Chat System ---

        async function openChat(partnerId, partnerUsername) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            if (partnerId === currentUserId) { showMessage("Vous ne pouvez pas chatter avec vous-même."); return; }

            currentChatPartnerId = partnerId;
            currentChatPartnerUsername = partnerUsername;
            chatPartnerName.textContent = `Chat avec ${partnerUsername}`;

            hideAllScreens(); // Hide all other screens
            chatModalOverlay.classList.remove('hidden');
            chatMessagesDiv.innerHTML = ''; // Clear previous messages
            chatMessageInput.value = ''; // Clear input

            // Setup real-time listener for chat messages
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, partnerId);
            const chatRoomId = `${user1Id}_${user2Id}`;
            const chatDocRef = doc(db, "chats", chatRoomId);

            if (chatListenerUnsubscribe) {
                chatListenerUnsubscribe(); // Unsubscribe from previous chat if any
            }

            chatListenerUnsubscribe = onSnapshot(chatDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const chatData = docSnap.data();
                    displayChatMessages(chatData.messages || []);
                } else {
                    displayChatMessages([]); // No messages yet
                    console.log("Aucune conversation trouvée, la créera au premier message.");
                }
            }, (error) => {
                console.error("Erreur d'écoute du chat:", error);
                showMessage("Erreur de connexion au chat: " + error.message);
            });
        }

        function displayChatMessages(messages) {
            chatMessagesDiv.innerHTML = '';
            if (messages.length === 0) {
                chatMessagesDiv.innerHTML = '<p class="p-4 text-gray-500 text-center">Commencez la conversation !</p>';
                return;
            }

            // Sort messages by timestamp to ensure correct order
            messages.sort((a, b) => (a.timestamp?.toDate() || 0) - (b.timestamp?.toDate() || 0));

            messages.forEach(msg => {
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message');
                messageElement.classList.add(msg.senderId === currentUserId ? 'self' : 'other');

                const date = msg.timestamp ? msg.timestamp.toDate() : new Date();
                const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                messageElement.innerHTML = `
                    <p>${msg.text}</p>
                    <span class="timestamp">${timeString}</span>
                `;
                chatMessagesDiv.appendChild(messageElement);
            });
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Scroll to bottom to show latest message
        }

        async function sendChatMessage() {
            const messageText = chatMessageInput.value.trim();
            if (!messageText || !currentChatPartnerId || !currentUserId || !db || !isAuthReady) {
                return;
            }

            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, currentChatPartnerId);
            const chatRoomId = `${user1Id}_${user2Id}`;
            const chatDocRef = doc(db, "chats", chatRoomId);

            try {
                const docSnap = await getDoc(chatDocRef);
                const newMessage = {
                    senderId: currentUserId,
                    text: messageText,
                    timestamp: serverTimestamp()
                };

                if (docSnap.exists()) {
                    // Update existing chat document by adding to the messages array
                    await updateDoc(chatDocRef, {
                        messages: arrayUnion(newMessage)
                    });
                } else {
                    // Create new chat document with the first message
                    await setDoc(chatDocRef, {
                        user1Id: user1Id,
                        user2Id: user2Id,
                        messages: [newMessage]
                    });
                }
                chatMessageInput.value = ''; // Clear input field after sending
            } catch (error) {
                console.error("Erreur lors de l'envoi du message:", error);
                showMessage("Erreur lors de l'envoi du message: " + error.message);
            }
        }

        // --- Logique de navigation entre les écrans ---
        document.addEventListener('DOMContentLoaded', function() {
            hideAllScreens();
            homeScreen.classList.remove('hidden');

            // Username management event listeners
            if (changeUsernameButton) {
                changeUsernameButton.addEventListener('click', showUsernameEditForm);
            }
            if (saveUsernameButton) {
                saveUsernameButton.addEventListener('click', handleSaveUsername);
            }
            if (cancelUsernameButton) {
                cancelUsernameButton.addEventListener('click', cancelUsernameEdit);
            }

            // Play Online button
            if (playOnlineButton) {
                playOnlineButton.addEventListener('click', function() {
                    if (isAuthReady && currentUserId) {
                        findOnlineMatch();
                    } else {
                        showMessage("Veuillez patienter, la connexion à Firebase est en cours...", () => {
                            // Retry after message box is closed
                            if (isAuthReady && currentUserId) {
                                findOnlineMatch();
                            } else {
                                showMessage("Impossible de se connecter à Firebase. Veuillez vérifier votre connexion.");
                            }
                        });
                    }
                });
            }

            // Cancel Online Search button
            document.getElementById('cancelSearchButton').addEventListener('click', cancelOnlineSearch);

            // Leave Online Game button
            document.getElementById('online-leave-game-button').addEventListener('click', () => {
                showMessage("Êtes-vous sûr de vouloir quitter la partie ? Cela sera considéré comme une défaite.", () => {
                    leaveOnlineGame();
                });
            });

            // Game End Screen Buttons
            gameEndReplayButton.addEventListener('click', () => {
                gameEndOverlay.classList.add('hidden');
                gameEndBanner.classList.add('hidden');
                if (currentEndGameType === 'local') {
                    resetLocalGame();
                } else if (currentEndGameType === 'ai') {
                    resetAIGame();
                } else if (currentEndGameType === 'online') {
                    resetOnlineGame();
                }
            });

            gameEndHomeButton.addEventListener('click', () => {
                gameEndOverlay.classList.add('hidden');
                gameEndBanner.classList.add('hidden');
                if (currentEndGameType === 'local') {
                    leaveLocalGame();
                } else if (currentEndGameType === 'ai') {
                    leaveAIGame();
                } else if (currentEndGameType === 'online') {
                    leaveOnlineGame();
                }
            });


            // Play Local button
            if (playLocalButton) {
                playLocalButton.addEventListener('click', function() {
                    hideAllScreens();
                    localGameScreen.classList.remove('hidden');
                    createCells('local-board', handleLocalCellClick);
                    resetLocalGame();
                });
            }

            if (localBackToHomeButton) {
                localBackToHomeButton.addEventListener('click', function() {
                    leaveLocalGame();
                });
            }

            if (localResetButton) {
                localResetButton.addEventListener('click', resetLocalGame);
            }

            // Play AI button
            if (playAIButton) {
                playAIButton.addEventListener('click', function() {
                    hideAllScreens();
                    aiGameScreen.classList.remove('hidden');
                    createCells('ai-board', handleAICellClick);
                    updateStatus("Sélectionnez une difficulté pour commencer", 'ai');
                    aiGameActive = false;
                    difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
                });
            }

            if (aiBackToHomeButton) {
                aiBackToHomeButton.addEventListener('click', function() {
                    leaveAIGame();
                });
            }

            if (easyButton) {
                easyButton.addEventListener('click', () => handleDifficultySelection('easy'));
            }
            if (mediumButton) {
                mediumButton.addEventListener('click', () => handleDifficultySelection('medium'));
            }
            if (hardButton) {
                hardButton.addEventListener('click', () => handleDifficultySelection('hard'));
            }

            if (aiResetButton) {
                aiResetButton.addEventListener('click', resetAIGame);
            }

            // --- Event Listeners for History and Leaderboard ---
            if (showHistoryButton) {
                showHistoryButton.addEventListener('click', showGameHistoryScreen);
            }

            if (showLeaderboardButton) {
                showLeaderboardButton.addEventListener('click', function() {
                    if (isAuthReady && currentUserId) {
                        showLeaderboardScreen();
                    } else {
                        showMessage("Veuillez patienter, la connexion à Firebase est en cours...", () => {
                            if (isAuthReady && currentUserId) {
                                showLeaderboardScreen();
                            } else {
                                showMessage("Impossible de se connecter à Firebase. Veuillez vérifier votre connexion.");
                            }
                        });
                    }
                });
            }

            if (leaderboardBackToHomeButton) {
                leaderboardBackToHomeButton.addEventListener('click', function() {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
            }

            // History screen back button
            if (historyBackButton) {
                historyBackButton.addEventListener('click', function() {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
            }

            // History detail screen buttons
            if (prevMoveButton) {
                prevMoveButton.addEventListener('click', () => {
                    if (currentDetailMoveIndex > -1) {
                        currentDetailMoveIndex--;
                        updateDetailBoardDisplay();
                    }
                });
            }
            if (nextMoveButton) {
                nextMoveButton.addEventListener('click', () => {
                    if (currentDetailMoveIndex < currentDetailGameMoves.length - 1) {
                        currentDetailMoveIndex++;
                        updateDetailBoardDisplay();
                    }
                });
            }
            if (detailBackButton) {
                detailBackButton.addEventListener('click', showGameHistoryScreen);
            }

            // --- NOUVEAUX LISTENERS POUR LE SYSTÈME D'AMIS ET CHAT ---
            if (showFriendsButton) {
                showFriendsButton.addEventListener('click', showFriendsScreen);
            }
            if (friendsBackToHomeButton) {
                friendsBackToHomeButton.addEventListener('click', function() {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
            }

            if (userSearchButton) {
                userSearchButton.addEventListener('click', searchUsers);
                userSearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchUsers();
                    }
                });
            }

            // User Profile Modal Actions
            userProfileModalCloseButton.addEventListener('click', () => userProfileModalOverlay.classList.add('hidden'));

            sendFriendRequestButton.addEventListener('click', () => sendFriendRequest(modalProfileId.textContent));
            cancelFriendRequestButton.addEventListener('click', () => unfriend(modalProfileId.textContent)); // Unfriend also cancels pending
            acceptFriendRequestButton.addEventListener('click', () => acceptFriendRequest(modalProfileId.textContent));
            declineFriendRequestButton.addEventListener('click', () => declineFriendRequest(modalProfileId.textContent));
            unfriendButton.addEventListener('click', () => unfriend(modalProfileId.textContent));
            blockUserButton.addEventListener('click', () => blockUser(modalProfileId.textContent));
            unblockUserButton.addEventListener('click', () => unblockUser(modalProfileId.textContent));
            proposeGameButton.addEventListener('click', () => showMessage("La proposition de partie n'est pas encore implémentée.")); // Placeholder for now
            openChatButton.addEventListener('click', () => openChat(modalProfileId.textContent, modalProfileUsername.textContent));

            // Notification Modal Actions
            notificationButton.addEventListener('click', showNotificationModal);
            notificationModalCloseButton.addEventListener('click', () => notificationModalOverlay.classList.add('hidden'));

            // Chat Modal Actions
            chatModalCloseButton.addEventListener('click', () => {
                chatModalOverlay.classList.add('hidden');
                if (chatListenerUnsubscribe) {
                    chatListenerUnsubscribe(); // Stop listening to chat messages
                    chatListenerUnsubscribe = null;
                }
                currentChatPartnerId = null;
                currentChatPartnerUsername = null;
                // Return to friends screen if chat was opened from there, else home
                if (!friendsScreen.classList.contains('hidden')) { // Check if friends screen was active before chat
                    showFriendsScreen();
                } else {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                }
            });
            sendChatMessageButton.addEventListener('click', sendChatMessage);
            chatMessageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
        });
    </script>
</body>
</html>
