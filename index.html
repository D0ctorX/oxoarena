<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OXO Arena</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F0F2F5; /* Couleur de fond générale, gris très clair */
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem; /* p-4 md:p-8 de Tailwind */
            overflow-x: hidden; /* Empêche le défilement horizontal */
        }
        /* Style pour le motif de fond subtil */
        .background-pattern {
            background-image:
                linear-gradient(45deg, rgba(26, 43, 60, 0.05) 25%, transparent 25%, transparent 75%, rgba(26, 43, 60, 0.05) 75%, rgba(26, 43, 60, 0.05) 100%),
                linear-gradient(-45deg, rgba(26, 43, 60, 0.05) 25%, transparent 25%, transparent 75%, rgba(26, 43, 60, 0.05) 75%, rgba(26, 43, 60, 0.05) 100%);
            background-size: 40px 40px; /* Taille de chaque carré du motif */
            background-position: 0 0, 20px 20px; /* Décalage pour un motif en damier */
            position: fixed; /* Fixe le motif en arrière-plan */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Assure que le motif est derrière le contenu */
        }

        /* Styles personnalisés pour le plateau de jeu */
        .board-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 colonnes de taille égale */
            grid-template-rows: repeat(5, 1fr);    /* 5 lignes de taille égale */
            width: 400px; /* Largeur fixe pour le plateau */
            height: 400px; /* Hauteur fixe pour le plateau */
            border: 2px solid #1A2B3C; /* Bordure foncée du thème */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Ombre plus prononcée */
            border-radius: 0.75rem; /* Coins arrondis */
            background-color: #ffffff; /* Fond blanc pour le plateau */
            overflow: hidden; /* Assure que les coins arrondis des cellules sont contenus */
        }

        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem; /* Taille du symbole X/O */
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #e0e0e0; /* Bordure de cellule plus claire */
            transition: background-color 0.2s ease-in-out;
            color: #1A2B3C; /* Couleur par default du texte (sombre du thème) */
            user-select: none; /* Empêche la sélection du texte */
        }

        .cell:hover {
            background-color: #f5f5f5; /* Léger survol */
        }

        /* Couleurs des joueurs basées sur le thème OXO Arena */
        .cell.x {
            color: #FFD700; /* Jaune doré pour X */
        }

        .cell.o {
            color: #1A2B3C; /* Bleu foncé pour O */
        }

        /* Styles pour les coins arrondis des cellules (pour les cellules du coin du plateau) */
        .cell:nth-child(1) { border-top-left-radius: 0.75rem; }
        .cell:nth-child(5) { border-top-right-radius: 0.75rem; }
        .cell:nth-child(21) { border-bottom-left-radius: 0.75rem; }
        .cell:nth-child(25) { border-bottom-right-radius: 0.75rem; }

        /* Styles pour les boutons de réinitialisation et de retour */
        .game-button {
            background-color: #1A2B3C; /* Couleur principale du thème */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Ombre pour le bouton */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem; /* Equivalent de space-x-3 */
        }

        .game-button:hover {
            background-color: #334a60; /* Couleur plus claire au survol */
            transform: translateY(-2px); /* Léger effet de soulèvement */
        }

        .game-button:active {
            transform: translateY(0); /* Retour à la position normale au clic */
        }

        /* Couleurs spécifiques pour les boutons de difficulté, adaptées au thème OXO Arena */
        #easy-button { background-color: #60A5FA; } /* Bleu clair */
        #easy-button:hover { background-color: #3B82F6; }

        #medium-button { background-color: #FBBF24; } /* Jaune/Orange */
        #medium-button:hover { background-color: #F59E0B; }

        #hard-button { background-color: #EF4444; } /* Rouge */
        #hard-button:hover { background-color: #DC2626; }

        /* Style pour la boîte de message */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            max-width: 90%;
            text-align: center;
        }
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        /* Style pour la difficulté sélectionnée */
        .selected-difficulty {
            border: 3px solid #FFD700; /* Bordure jaune dorée pour indiquer la sélection */
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); /* Ombre lumineuse */
        }

        /* Styles pour l'animation de chargement */
        .loader {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #FFD700; /* Yellow */
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles pour l'écran de fin de partie */
        .game-end-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            z-index: 999;
            text-align: center;
            gap: 2rem;
        }

        /* Couleurs du thème OXO Arena pour les écrans de fin de partie */
        .game-end-screen.win {
            background-color: #1A2B3C; /* Couleur principale du thème (bleu foncé) */
            color: #FFD700; /* Couleur d'accent (jaune doré) */
        }
        .game-end-screen.loss {
            background-color: #600000; /* Rouge foncé plus discret */
            color: #E5E7EB; /* Gris clair pour le texte */
        }
        .game-end-screen.draw {
            background-color: #4B5563; /* Gris foncé de Tailwind */
            color: #E5E7EB; /* Gris clair pour le texte */
        }

        .game-end-screen h2 {
            font-size: 4rem; /* Grande taille pour le titre */
            font-weight: bold;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .game-end-screen p {
            font-size: 2rem; /* Taille pour le message */
            margin-bottom: 2rem;
        }

        .game-end-screen .icon {
            /* L'icône est maintenant vide ou gérée par le texte, donc pas de taille spécifique */
            font-size: 0; /* Cache l'icône si elle est vide */
            margin-bottom: 0;
            line-height: 0;
        }

        .game-end-screen .button-group {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-end-screen .game-button {
            min-width: 200px; /* Assure une largeur minimale pour les boutons */
        }

        /* Styles spécifiques pour le classement */
        .leaderboard-list {
            width: 100%;
            max-width: 500px;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            font-size: 1.125rem;
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-item .rank {
            font-weight: bold;
            color: #1A2B3C;
            width: 30px;
            text-align: center;
        }

        .leaderboard-item .username {
            flex-grow: 1;
            font-weight: 600;
            color: #334a60;
            text-align: left;
            padding-left: 1rem;
        }

        .leaderboard-item .elo {
            font-weight: bold;
            color: #FFD700;
            width: 60px;
            text-align: right;
        }

        .leaderboard-item.top-3 {
            background-color: #FFFBEB; /* Light yellow background for top 3 */
        }
        .leaderboard-item.top-1 {
            background-color: #FFD700; /* Gold for rank 1 */
            color: #1A2B3C;
        }
        .leaderboard-item.top-1 .rank, .leaderboard-item.top-1 .username, .leaderboard-item.top-1 .elo {
            color: #1A2B3C;
        }
    </style>
</head>
<body class="background-pattern">
    <div class="w-full max-w-6xl flex flex-col items-center justify-center">

        <div id="home-screen" class="bg-white rounded-xl shadow-2xl overflow-hidden w-full flex flex-col md:flex-row">
            <div class="w-full md:w-1/3 p-6 md:p-10 flex flex-col items-center justify-center bg-[#1A2B3C] text-white rounded-t-xl md:rounded-l-xl md:rounded-tr-none">
                <h1 class="text-4xl md:text-5xl font-extrabold mb-8 text-center tracking-tight">
                    OXO Arena
                </h1>
                <nav class="w-full space-y-4">
                    <button id="playOnlineButton" class="w-full py-3 px-6 bg-[#FFD700] text-[#1A2B3C] font-semibold rounded-lg shadow-md hover:bg-yellow-400 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                        <span>Jouer en Ligne</span>
                    </button>
                    <button id="playLocalButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M17 20h2a2 2 0 002-2V4a2 2 0 00-2-2H5a2 2 0 00-2 2v14a2 2 0 002 2h2m10 0v2m0-2h-3m-2 0h-2M9 16H5a2 2 0 00-2 2v2h10v-2a2 2 0 00-2-2z" />
                        </svg>
                        <span>Jouer en Local</span>
                    </button>
                    <button id="playAIButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 7h14a2 2 0 002-2V3a2 2 0 00-2-2H5a2 2 0 00-2 2v2a2 2 0 002 2zm0 14h14a2 2 0 002-2v-2a2 2 0 00-2-2H5a2 2 0 00-2 2v2a2 2 0 002 2zM12 11h.01M12 15h.01" />
                        </svg>
                        <span>Jouer Contre IA</span>
                    </button>
                    <button id="showLeaderboardButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        <span>Classement</span>
                    </button>
                </nav>
            </div>

            <div class="w-full md:w-2/3 p-6 md:p-10 flex flex-col justify-center items-center text-[#1A2B3C]">
                <h2 class="text-3xl md:text-4xl font-bold mb-6 text-center">Votre Profil</h2>
                <div id="profile-loading" class="text-xl text-gray-500">Chargement du profil...</div>
                <div id="profile-content" class="bg-gray-100 p-6 rounded-xl shadow-inner w-full max-w-md space-y-4 text-lg md:text-xl hidden">
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">ID Utilisateur :</span>
                        <span id="user-id-display" class="text-gray-700 font-medium break-all"></span>
                    </p>
                    <div class="flex flex-col items-start w-full">
                        <div class="flex justify-between items-center w-full">
                            <span class="font-semibold">Pseudo :</span>
                            <span id="profile-username" class="text-gray-700 font-medium"></span>
                            <button id="change-username-button" class="ml-2 px-3 py-1 bg-[#FFD700] text-[#1A2B3C] text-sm rounded-md hover:bg-yellow-400 transition-colors">Modifier</button>
                        </div>
                        <div id="username-edit-section" class="hidden mt-2 w-full">
                            <input type="text" id="new-username-input" class="w-full p-2 border border-gray-300 rounded-md text-gray-800" placeholder="Nouveau pseudo (3-20 caractères)">
                            <button id="save-username-button" class="mt-2 w-full py-2 bg-[#1A2B3C] text-white rounded-md hover:bg-gray-800">Sauvegarder</button>
                            <button id="cancel-username-button" class="mt-2 w-full py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500">Annuler</button>
                        </div>
                        <p id="username-cooldown-message" class="text-xs text-red-600 mt-1 text-center w-full hidden"></p>
                    </div>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Elo :</span>
                        <span id="profile-elo" class="text-[#FFD700] font-bold"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Niveau :</span>
                        <span id="profile-level" class="text-[#FFD700] font-bold"></span>
                    </p>
                    <div class="border-t border-gray-300 pt-4 mt-4"></div>
                    <h3 class="text-2xl font-bold mb-2 text-center">Statistiques</h3>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Parties jouées :</span>
                        <span id="profile-games-played" class="font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Victoires :</span>
                        <span id="profile-wins" class="text-green-600 font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Défaites :</span>
                        <span id="profile-losses" class="text-red-600 font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Nuls :</span>
                        <span id="profile-draws" class="text-gray-500 font-medium"></span>
                    </p>
                </div>
                <button id="showHistoryButton" class="mt-8 py-3 px-8 bg-[#1A2B3C] text-white font-semibold rounded-lg shadow-lg hover:bg-gray-800 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>Historique des Parties</span>
                </button>
            </div>
        </div>

        <div id="leaderboard-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full mt-8 text-[#1A2B3C]">
            <h1 class="text-4xl font-extrabold mb-6 text-center">Classement des Joueurs</h1>
            <div id="leaderboard-list" class="leaderboard-list">
                <div class="text-center p-4 text-gray-500">Chargement du classement...</div>
            </div>
            <button id="leaderboard-back-to-home-button" class="game-button mt-8">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                </svg>
                <span>Retour à l'Accueil</span>
            </button>
        </div>

        <div id="local-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full mt-8">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - Local</h1>
            <p class="text-center text-gray-600 mb-6 italic">
                Les parties jouées en local n'impactent pas vos statistiques (Elo, niveau, nombre de parties, etc.).
            </p>
            <div id="local-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]">Au tour de : X</div>

            <div id="local-board" class="board-grid">
                </div>

            <div class="mt-8 flex space-x-4">
                <button id="local-reset-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                    </svg>
                    <span>Nouvelle partie</span>
                </button>
                <button id="local-back-to-home-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                    </svg>
                    <span>Retour à l'Accueil</span>
                </button>
            </div>
        </div>

        <div id="ai-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full mt-8">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - Contre IA</h1>
            <p class="text-center text-gray-600 mb-6 italic">
                Les parties jouées contre l'IA en mode Facile et Moyen n'impactent pas vos statistiques (Elo, niveau, nombre de parties, etc.). Seules les parties en mode Difficile sont prises en compte.
            </p>
            <div id="ai-difficulty-buttons" class="flex space-x-4 mb-8">
                <button id="easy-button" class="game-button">Facile</button>
                <button id="medium-button" class="game-button">Moyen</button>
                <button id="hard-button" class="game-button">Difficile</button>
            </div>
            <div id="ai-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]">Sélectionnez une difficulté pour commencer</div>

            <div id="ai-board" class="board-grid">
                </div>

            <div class="mt-8 flex space-x-4">
                <button id="ai-reset-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                    </svg>
                    <span>Nouvelle partie</span>
                </button>
                <button id="ai-back-to-home-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                        </svg>
                    <span>Retour à l'Accueil</span>
                </button>
            </div>
        </div>

        <div id="online-searching-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full mt-8 text-[#1A2B3C]">
            <h1 class="text-4xl font-extrabold mb-4 text-center">Recherche de partie...</h1>
            <p class="text-lg text-gray-600 mb-8 text-center">
                Veuillez patienter pendant que nous trouvons un adversaire pour vous.
            </p>
            <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32 mb-8" style="border-top-color: #FFD700;"></div>
            <button id="cancelSearchButton" class="game-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
                <span>Annuler la recherche</span>
            </button>
        </div>

        <div id="online-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full mt-8">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - En Ligne</h1>
            <p class="text-center text-gray-600 mb-2 italic">
                Votre ID de partie : <span id="online-game-id-display" class="font-semibold break-all text-sm"></span>
            </p>
            <p class="text-center text-gray-600 mb-2 italic">
                Vous êtes le joueur : <span id="online-player-role" class="font-bold"></span>
            </p>
            <div class="text-center text-gray-600 mb-6 italic">
                <p>Adversaire : <span id="online-opponent-username" class="font-semibold text-sm"></span></p>
                <p>Elo : <span id="online-opponent-elo" class="font-semibold text-sm"></span> | Niveau : <span id="online-opponent-level" class="font-semibold text-sm"></span></p>
            </div>
            <div id="online-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]"></div>

            <div id="online-board" class="board-grid"></div>

            <div class="mt-8 flex space-x-4">
                <button id="online-leave-game-button" class="game-button bg-red-600 hover:bg-red-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                    </svg>
                    <span>Quitter la partie</span>
                </button>
            </div>
        </div>

    </div>

    <div id="game-end-screen" class="game-end-screen hidden">
        <div id="game-end-icon" class="icon"></div>
        <h2 id="game-end-title"></h2>
        <p id="game-end-message"></p>
        <div class="button-group">
            <button id="game-end-replay-button" class="game-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                </svg>
                <span>Rejouer</span>
            </button>
            <button id="game-end-home-button" class="game-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                </svg>
                <span>Retour à l'Accueil</span>
            </button>
        </div>
    </div>


    <div id="message-box-overlay" class="message-box-overlay hidden"></div>
    <div id="message-box" class="message-box hidden">
        <p id="message-box-text" class="text-xl font-semibold text-[#1A2B3C]"></p>
        <button id="message-box-close" class="game-button">OK</button>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, where, getDocs, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Initialization ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'oxoarena';
        let firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        if (Object.keys(firebaseConfig).length === 0) {
            console.warn("Firebase: Exécution locale. Utilisation de la configuration Firebase fournie par l'utilisateur.");
            firebaseConfig = {
                apiKey: "AIzaSyCTAax7cKcxL29HwwVgRxD8AfqDzx8tG6A",
                authDomain: "oxoarena-2476d.firebaseapp.com",
                projectId: "oxoarena-2476d",
                storageBucket: "oxoarena-2476d.firebasestorage.app",
                messagingSenderId: "1071875114714",
                appId: "1:1071875114714:web:0658dedac66047438f07e3",
                measurementId: "G-3N7C3R5HYV"
            };
        }

        let app;
        let db;
        let auth;
        let currentUserId = null;
        let isAuthReady = false;
        let userProfileData = null; // Stores current user's profile data

        // Online Game Variables
        let currentOnlineGameId = null;
        let currentOnlinePlayerRole = null;
        let onlineBoard = Array(25).fill('');
        let onlineCurrentTurn = 'X';
        let onlineGameActive = false;
        let onlineCells;
        let onlineGameListenerUnsubscribe = null;
        let onlineOpponentUserId = null; // Store opponent's user ID
        let onlineOpponentProfile = null; // Store opponent's profile data

        if (Object.keys(firebaseConfig).length > 0 && firebaseConfig.apiKey) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    isAuthReady = true;
                    console.log("Firebase: User signed in:", currentUserId);
                    userProfileData = await fetchUserProfile(currentUserId); // Use fetchUserProfile for current user
                    displayUserProfile(currentUserId, userProfileData); // Display current user's profile
                    // Ensure profile content is visible after loading
                    document.getElementById('profile-loading').classList.add('hidden');
                    document.getElementById('profile-content').classList.remove('hidden');
                } else {
                    console.log("Firebase: No user signed in. Attempting sign-in...");
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Firebase: Signed in with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Firebase: Signed in anonymously.");
                        }
                    } catch (error) {
                        console.error("Firebase: Authentication error:", error);
                        showMessage("Erreur de connexion Firebase: " + error.message);
                    }
                    isAuthReady = true;
                    // Ensure profile content is visible even if not logged in (e.g., showing N/A)
                    document.getElementById('profile-loading').classList.add('hidden');
                    document.getElementById('profile-content').classList.remove('hidden');
                }
            });
        } else {
            console.warn("Firebase: La configuration Firebase est incomplète ou introuvable. Exécution sans les fonctionnalités Firebase.");
            isAuthReady = true;
            document.getElementById('profile-loading').classList.add('hidden');
            document.getElementById('profile-content').classList.remove('hidden');
            document.getElementById('user-id-display').textContent = 'Non connecté (Firebase désactivé)';
            document.getElementById('profile-elo').textContent = 'N/A';
            document.getElementById('profile-level').textContent = 'N/A';
            document.getElementById('profile-games-played').textContent = 'N/A';
            document.getElementById('profile-wins').textContent = 'N/A';
            document.getElementById('profile-losses').textContent = 'N/A';
            document.getElementById('profile-draws').textContent = 'N/A';
            document.getElementById('playOnlineButton').disabled = true;
            document.getElementById('playOnlineButton').textContent = 'Jouer en Ligne (Hors ligne)';
        }

        // --- Message Box Elements ---
        const messageBoxOverlay = document.getElementById('message-box-overlay');
        const messageBox = document.getElementById('message-box');
        const messageBoxText = document.getElementById('message-box-text');
        const messageBoxCloseButton = document.getElementById('message-box-close');

        messageBoxCloseButton.addEventListener('click', () => {
            messageBox.classList.add('hidden');
            messageBoxOverlay.classList.add('hidden');
        });

        function showMessage(message, callback = null) {
            messageBoxText.textContent = message;
            messageBox.classList.remove('hidden');
            messageBoxOverlay.classList.remove('hidden');
            if (callback) {
                messageBoxCloseButton.onclick = () => {
                    messageBox.classList.add('hidden');
                    messageBoxOverlay.classList.add('hidden');
                    callback();
                    messageBoxCloseButton.onclick = null;
                };
            } else {
                messageBoxCloseButton.onclick = () => {
                    messageBox.classList.add('hidden');
                    messageBoxOverlay.classList.add('hidden');
                    messageBoxCloseButton.onclick = null;
                };
            }
        }

        // --- User Profile Functions ---
        const defaultUserProfile = {
            elo: 0,
            level: 0,
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            username: 'Joueur' + Math.floor(Math.random() * 10000), // Default username
            lastUsernameChange: null, // No previous change
        };
        const MAX_LEVEL = 50;

        async function fetchUserProfile(userIdToFetch) {
            if (!db || !userIdToFetch) {
                console.error("Firebase: Firestore ou userId non disponible pour le profil.");
                return { ...defaultUserProfile };
            }

            const userProfileRef = doc(db, `artifacts/${appId}/users/${userIdToFetch}/profile`, 'data');
            const userDocRef = doc(db, `artifacts/${appId}/users`, userIdToFetch); // Référence au document parent de l'utilisateur

            try {
                // S'assurer que le document parent de l'utilisateur existe ou est créé/mis à jour.
                // Ceci est crucial pour la requête du classement qui liste les documents dans la collection 'users'.
                await setDoc(userDocRef, { lastActive: serverTimestamp() }, { merge: true });
                console.log(`Firebase: Document parent utilisateur pour ${userIdToFetch} assuré.`);


                const docSnap = await getDoc(userProfileRef);
                let profileData = {};

                if (docSnap.exists()) {
                    profileData = docSnap.data();
                    // S'assurer que tous les champs par défaut existent
                    for (const key in defaultUserProfile) {
                        if (profileData[key] === undefined) {
                            profileData[key] = defaultUserProfile[key];
                        }
                    }
                    console.log("Firebase: Profil utilisateur récupéré :", profileData);
                } else {
                    console.log("Firebase: Pas de profil utilisateur trouvé, création par défaut.");
                    profileData = { ...defaultUserProfile };
                    await setDoc(userProfileRef, profileData);
                    console.log("Firebase: Profil par défaut créé.");
                }
                return profileData;
            } catch (error) {
                console.error("Firebase: Erreur lors de la récupération ou la création du profil utilisateur :", error);
                showMessage("Erreur lors du chargement du profil: " + error.message);
                return { ...defaultUserProfile };
            }
        }

        async function updateUserProfileStats(userId, gameResult, opponentElo = null) {
            if (!db || !userId || !isAuthReady) {
                console.error("Firebase: Firestore, userId, ou auth non prêt pour la mise à jour.");
                return;
            }
            const userProfileRef = doc(db, `artifacts/${appId}/users/${userId}/profile`, 'data');

            try {
                const docSnap = await getDoc(userProfileRef);
                let currentProfile = docSnap.exists() ? docSnap.data() : { ...defaultUserProfile };

                currentProfile.gamesPlayed = (currentProfile.gamesPlayed || 0) + 1;

                let eloChange = 0;
                if (gameResult === 'win') {
                    currentProfile.wins = (currentProfile.wins || 0) + 1;
                    if (opponentElo !== null) { // Online game Elo calculation
                        if (currentProfile.elo >= opponentElo) { // Won against lower/equal Elo
                            eloChange = 8;
                        } else { // Won against higher Elo
                            eloChange = 15;
                        }
                    } else { // AI game or other default win (only hard AI impacts stats)
                        eloChange = 10;
                    }
                } else if (gameResult === 'loss') {
                    currentProfile.losses = (currentProfile.losses || 0) + 1;
                    if (opponentElo !== null) { // Online game Elo calculation
                        if (currentProfile.elo >= opponentElo) { // Lost against lower/equal Elo
                            eloChange = -15;
                        } else { // Lost against higher Elo
                            eloChange = -8;
                        }
                    } else { // AI game or other default loss (only hard AI impacts stats)
                        eloChange = -5;
                    }
                } else if (gameResult === 'draw') {
                    currentProfile.draws = (currentProfile.draws || 0) + 1;
                    eloChange = 1; // Draw always +1
                }

                currentProfile.elo = Math.max(0, (currentProfile.elo || 0) + eloChange);
                currentProfile.level = Math.min(MAX_LEVEL, Math.floor((currentProfile.elo || 0) / 25));

                await setDoc(userProfileRef, currentProfile);
                console.log("Firebase: Profil utilisateur mis à jour avec succès.", currentProfile);
                // Only update the main profile display if it's the current user's profile
                if (userId === currentUserId) {
                    displayUserProfile(userId, currentProfile);
                    userProfileData = currentProfile;
                }
            } catch (error) {
                console.error("Firebase: Erreur lors de la mise à jour du profil utilisateur :", error);
                showMessage("Erreur lors de la mise à jour du profil: " + error.message);
            }
        }

        // --- DOM Elements for Username Management ---
        const profileUsername = document.getElementById('profile-username');
        const changeUsernameButton = document.getElementById('change-username-button');
        const usernameEditSection = document.getElementById('username-edit-section');
        const newUsernameInput = document.getElementById('new-username-input');
        const saveUsernameButton = document.getElementById('save-username-button');
        const cancelUsernameButton = document.getElementById('cancel-username-button');
        const usernameCooldownMessage = document.getElementById('username-cooldown-message');

        function displayUserProfile(userId, profile) {
            // This function is for displaying the CURRENT user's profile on the home screen
            document.getElementById('user-id-display').textContent = userId;
            profileUsername.textContent = profile.username; // Display username
            document.getElementById('profile-elo').textContent = profile.elo;
            document.getElementById('profile-level').textContent = `${profile.level}/${MAX_LEVEL}`;
            document.getElementById('profile-games-played').textContent = profile.gamesPlayed;
            document.getElementById('profile-wins').textContent = profile.wins;
            document.getElementById('profile-losses').textContent = profile.losses;
            document.getElementById('profile-draws').textContent = profile.draws;

            // Cooldown logic for username change
            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            if (profile.lastUsernameChange && profile.lastUsernameChange instanceof Object && 'toDate' in profile.lastUsernameChange) {
                const lastChangeDate = profile.lastUsernameChange.toDate(); // Convert Firestore Timestamp to Date
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;

                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    usernameCooldownMessage.textContent = `Prochain changement dans ${days} jour${days > 1 ? 's' : ''}.`;
                    usernameCooldownMessage.classList.remove('hidden');
                    changeUsernameButton.disabled = true;
                    changeUsernameButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    usernameCooldownMessage.classList.add('hidden');
                    changeUsernameButton.disabled = false;
                    changeUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            } else {
                // No previous change, allow immediate change
                usernameCooldownMessage.classList.add('hidden');
                changeUsernameButton.disabled = false;
                changeUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }


        // --- Username Change Functions ---
        function showUsernameEditForm() {
            changeUsernameButton.classList.add('hidden');
            usernameEditSection.classList.remove('hidden');
            newUsernameInput.value = profileUsername.textContent; // Pre-fill with current username

            // Re-check cooldown when opening edit form
            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            if (userProfileData && userProfileData.lastUsernameChange && userProfileData.lastUsernameChange instanceof Object && 'toDate' in userProfileData.lastUsernameChange) {
                const lastChangeDate = userProfileData.lastUsernameChange.toDate();
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;
                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    usernameCooldownMessage.textContent = `Vous devez attendre ${days} jour${days > 1 ? 's' : ''} avant de changer de pseudo.`;
                    usernameCooldownMessage.classList.remove('hidden');
                    newUsernameInput.disabled = true;
                    saveUsernameButton.disabled = true;
                    saveUsernameButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    usernameCooldownMessage.classList.add('hidden');
                    newUsernameInput.disabled = false;
                    saveUsernameButton.disabled = false;
                    saveUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            } else {
                usernameCooldownMessage.classList.add('hidden');
                newUsernameInput.disabled = false;
                saveUsernameButton.disabled = false;
                saveUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        async function handleSaveUsername() {
            const newUsername = newUsernameInput.value.trim();

            if (!newUsername || newUsername.length < 3 || newUsername.length > 20) {
                showMessage("Le pseudo doit contenir entre 3 et 20 caractères.");
                return;
            }

            if (newUsername === profileUsername.textContent) {
                showMessage("Le nouveau pseudo est identique au pseudo actuel.");
                usernameEditSection.classList.add('hidden');
                changeUsernameButton.classList.remove('hidden');
                return;
            }

            await updateUsername(newUsername);
        }

        function cancelUsernameEdit() {
            usernameEditSection.classList.add('hidden');
            changeUsernameButton.classList.remove('hidden');
            // Re-apply cooldown status if needed
            displayUserProfile(currentUserId, userProfileData);
        }

        async function updateUsername(newUsername) {
            if (!db || !currentUserId || !isAuthReady) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }

            const userProfileRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data');

            // Re-fetch current profile to get the latest lastUsernameChange
            const docSnap = await getDoc(userProfileRef);
            let currentProfile = docSnap.exists() ? docSnap.data() : { ...defaultUserProfile };

            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            if (currentProfile.lastUsernameChange && currentProfile.lastUsernameChange instanceof Object && 'toDate' in currentProfile.lastUsernameChange) {
                const lastChangeDate = currentProfile.lastUsernameChange.toDate();
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;
                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    showMessage(`Vous devez attendre ${days} jour${days > 1 ? 's' : ''} avant de changer de pseudo.`);
                    return;
                }
            }

            try {
                await updateDoc(userProfileRef, {
                    username: newUsername,
                    lastUsernameChange: serverTimestamp() // Update timestamp on successful change
                });
                showMessage("Pseudo mis à jour avec succès !");
                // Re-fetch and display profile to update the UI and cooldown status
                userProfileData = await fetchUserProfile(currentUserId);
                displayUserProfile(currentUserId, userProfileData);
            } catch (error) {
                console.error("Erreur lors de la mise à jour du pseudo:", error);
                showMessage("Erreur lors de la mise à jour du pseudo: " + error.message);
            } finally {
                usernameEditSection.classList.add('hidden');
                changeUsernameButton.classList.remove('hidden');
            }
        }


        // --- Éléments du DOM et variables d'état pour l'application globale ---
        const homeScreen = document.getElementById('home-screen');
        const localGameScreen = document.getElementById('local-game-screen');
        const aiGameScreen = document.getElementById('ai-game-screen');
        const onlineSearchingScreen = document.getElementById('online-searching-screen');
        const onlineGameScreen = document.getElementById('online-game-screen');
        const gameEndScreen = document.getElementById('game-end-screen');
        const gameEndTitle = document.getElementById('game-end-title');
        const gameEndMessage = document.getElementById('game-end-message');
        const gameEndIcon = document.getElementById('game-end-icon');
        const gameEndReplayButton = document.getElementById('game-end-replay-button');
        const gameEndHomeButton = document.getElementById('game-end-home-button');
        const leaderboardScreen = document.getElementById('leaderboard-screen'); // Nouvelle référence
        const leaderboardList = document.getElementById('leaderboard-list'); // Nouvelle référence


        const playOnlineButton = document.getElementById('playOnlineButton');
        const playLocalButton = document.getElementById('playLocalButton');
        const playAIButton = document.getElementById('playAIButton');
        const showHistoryButton = document.getElementById('showHistoryButton'); // Référence au bouton Historique sous le profil
        const showLeaderboardButton = document.getElementById('showLeaderboardButton'); // Référence au bouton Classement dans la nav
        const leaderboardBackToHomeButton = document.getElementById('leaderboard-back-to-home-button'); // Bouton retour depuis classement


        // --- Variables et éléments du DOM pour le jeu local ---
        const localStatusDisplay = document.getElementById('local-game-status');
        const localBoardElement = document.getElementById('local-board');
        const localResetButton = document.getElementById('local-reset-button');
        const localBackToHomeButton = document.getElementById('local-back-to-home-button');

        let localBoard = Array(25).fill('');
        let localCurrentPlayer = 'X';
        let localGameActive = true;
        let localCells;

        // --- Variables et éléments du DOM pour le jeu IA ---
        const aiStatusDisplay = document.getElementById('ai-game-status');
        const aiBoardElement = document.getElementById('ai-board');
        const aiResetButton = document.getElementById('ai-reset-button');
        const aiBackToHomeButton = document.getElementById('ai-back-to-home-button');
        const easyButton = document.getElementById('easy-button');
        const mediumButton = document.getElementById('medium-button');
        const hardButton = document.getElementById('hard-button');
        const difficultyButtons = [easyButton, mediumButton, hardButton];

        let aiBoard = Array(25).fill('');
        let humanPlayer = 'X';
        let aiPlayer = 'O';
        let aiCurrentPlayer = humanPlayer;
        let aiGameActive = false;
        let aiDifficulty = null;
        const MINIMAX_MAX_DEPTH = 4;
        let aiCells;

        // --- Constantes de jeu communes ---
        const BOARD_SIZE = 5;
        const WIN_LENGTH = 4;

        const generateWinningCombinations = () => {
            const combinations = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col <= BOARD_SIZE - WIN_LENGTH; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i));
                }
            }
            for (let col = 0; col < BOARD_SIZE; col++) {
                for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * BOARD_SIZE));
                }
            }
            for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                for (let col = 0; col <= BOARD_SIZE - WIN_LENGTH; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * (BOARD_SIZE + 1)));
                }
            }
            for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                for (let col = WIN_LENGTH - 1; col < BOARD_SIZE; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * (BOARD_SIZE - 1)));
                }
            }
            return combinations;
        };
        const winningCombinations = generateWinningCombinations();

        const updateStatus = (message, gameType) => {
            if (gameType === 'local') {
                localStatusDisplay.innerHTML = message;
            } else if (gameType === 'ai') {
                aiStatusDisplay.innerHTML = message;
            } else if (gameType === 'online') {
                document.getElementById('online-game-status').innerHTML = message;
            }
        };

        const createCells = (boardElementId, clickHandler) => {
            const currentBoardElement = document.getElementById(boardElementId);
            currentBoardElement.innerHTML = '';
            for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                cell.addEventListener('click', clickHandler);
                currentBoardElement.appendChild(cell);
            }
            if (boardElementId === 'local-board') {
                localCells = Array.from(document.querySelectorAll('#local-board .cell'));
            } else if (boardElementId === 'ai-board') {
                aiCells = Array.from(document.querySelectorAll('#ai-board .cell'));
            } else if (boardElementId === 'online-board') {
                onlineCells = Array.from(document.querySelectorAll('#online-board .cell'));
            }
        };

        const checkForWin = (player, currentBoard) => {
            for (let i = 0; i < winningCombinations.length; i++) {
                const combination = winningCombinations[i];
                let allMatch = true;
                for (let j = 0; j < WIN_LENGTH; j++) {
                    if (currentBoard[combination[j]] !== player) {
                        allMatch = false;
                        break;
                    }
                }
                if (allMatch) {
                    return true;
                }
            }
            return false;
        };

        const checkForDraw = (currentBoard) => {
            return !currentBoard.includes('');
        };

        // --- Fonctions communes pour les écrans de fin de partie ---
        let currentEndGameType = ''; // 'local', 'ai', 'online'

        function showGameEndScreen(status, winner, gameType) {
            hideAllScreens();
            gameEndScreen.classList.remove('hidden', 'win', 'loss', 'draw');
            gameEndTitle.textContent = '';
            gameEndMessage.textContent = '';
            gameEndIcon.innerHTML = ''; // Clear any previous icon
            currentEndGameType = gameType; // Stocke le type de jeu pour les boutons

            let title = '';
            let message = '';

            if (gameType === 'local') {
                gameEndScreen.classList.add('draw'); // Couleur neutre pour local (pas de victoire/défaite absolue)
                if (status === 'win') {
                    title = 'PARTIE TERMINÉE !';
                    message = `Le joueur ${winner} a gagné !`;
                } else { // draw
                    title = 'MATCH NUL !';
                    message = 'Aucun vainqueur.';
                }
            } else { // AI or Online
                if (status === 'win') {
                    gameEndScreen.classList.add('win');
                    title = 'VICTOIRE !';
                    message = `Vous avez gagné en tant que joueur ${winner} !`;
                } else if (status === 'loss') {
                    gameEndScreen.classList.add('loss');
                    title = 'DÉFAITE !';
                    message = `Le joueur ${winner} a gagné.`;
                } else { // draw
                    gameEndScreen.classList.add('draw');
                    title = 'MATCH NUL !';
                    message = 'Aucun vainqueur.';
                }

                // Update profile stats for AI (hard) and Online games
                if (isAuthReady && currentUserId) {
                    if (gameType === 'ai' && aiDifficulty === 'hard') {
                        updateUserProfileStats(currentUserId, status);
                    } else if (gameType === 'online' && onlineOpponentProfile) {
                        updateUserProfileStats(currentUserId, status, onlineOpponentProfile.elo);
                    }
                }
            }

            gameEndTitle.textContent = title;
            gameEndMessage.textContent = message;

            gameEndReplayButton.style.display = 'flex';
            gameEndHomeButton.style.display = 'flex';
        }

        // --- Fonctions spécifiques au jeu local ---
        const handleLocalCellClick = (event) => {
            const clickedCell = event.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            if (localBoard[clickedCellIndex] !== '' || !localGameActive) {
                return;
            }
            localBoard[clickedCellIndex] = localCurrentPlayer;
            localCells[clickedCellIndex].innerHTML = localCurrentPlayer;
            localCells[clickedCellIndex].classList.add(localCurrentPlayer.toLowerCase());

            const hasWon = checkForWin(localCurrentPlayer, localBoard);
            if (hasWon) {
                showGameEndScreen('win', localCurrentPlayer, 'local');
                localGameActive = false;
                return;
            }

            const hasDraw = checkForDraw(localBoard);
            if (hasDraw) {
                showGameEndScreen('draw', null, 'local');
                localGameActive = false;
                return;
            }

            localCurrentPlayer = localCurrentPlayer === 'X' ? 'O' : 'X';
            updateStatus(`Au tour de : ${localCurrentPlayer}`, 'local');
        };

        const resetLocalGame = () => {
            localBoard = Array(25).fill('');
            localCurrentPlayer = 'X';
            localGameActive = true;
            updateStatus(`Au tour de : ${localCurrentPlayer}`, 'local');
            localCells.forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('x', 'o');
            });
            hideAllScreens();
            localGameScreen.classList.remove('hidden');
        };

        const leaveLocalGame = () => {
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            // Re-display current user's profile on returning to home
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        };

        // --- Fonctions spécifiques au jeu IA ---
        const handleAICellClick = (event) => {
            const clickedCell = event.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            if (aiBoard[clickedCellIndex] !== '' || !aiGameActive || aiCurrentPlayer !== humanPlayer) {
                return;
            }

            makeAIMoveInternal(clickedCellIndex, humanPlayer);
            checkAIGameStatus();
        };

        const makeAIMoveInternal = (index, player) => {
            aiBoard[index] = player;
            aiCells[index].innerHTML = player;
            aiCells[index].classList.add(player.toLowerCase());
        };

        const checkAIGameStatus = async () => {
            const humanWon = checkForWin(humanPlayer, aiBoard);
            const aiWon = checkForWin(aiPlayer, aiBoard);
            const isDraw = checkForDraw(aiBoard);

            if (humanWon) {
                showGameEndScreen('win', humanPlayer, 'ai');
                aiGameActive = false;
            } else if (aiWon) {
                showGameEndScreen('loss', aiPlayer, 'ai');
                aiGameActive = false;
            } else if (isDraw) {
                showGameEndScreen('draw', null, 'ai');
                aiGameActive = false;
            } else {
                aiCurrentPlayer = aiCurrentPlayer === humanPlayer ? aiPlayer : humanPlayer;
                updateStatus(`Au tour de : ${aiCurrentPlayer}`, 'ai');
                if (aiCurrentPlayer === aiPlayer && aiGameActive) {
                    setTimeout(makeAIPlayerMove, 700);
                }
            }
        };

        const getEmptyCells = (currentBoard) => {
            return currentBoard.map((cell, index) => cell === '' ? index : null).filter(index => index !== null);
        };

        const findWinningMove = (player, currentBoard) => {
            const emptyCells = getEmptyCells(currentBoard);
            for (let i = 0; i < emptyCells.length; i++) {
                const move = emptyCells[i];
                currentBoard[move] = player;
                if (checkForWin(player, currentBoard)) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }
            return null;
        };

        const findBlockingMove = (playerToBlock, currentBoard) => {
            return findWinningMove(playerToBlock, currentBoard);
        };

        const countThreats = (player, count, currentBoard) => {
            let numThreats = 0;
            for (const combination of winningCombinations) {
                let playerCount = 0;
                let emptyCount = 0;
                for (const index of combination) {
                    if (currentBoard[index] === player) playerCount++;
                    else if (currentBoard[index] === '') emptyCount++;
                }
                if (playerCount === count && emptyCount === WIN_LENGTH - count) {
                    numThreats++;
                }
            }
            return numThreats;
        };

        const easyAI = (currentBoard) => {
            const winningMove = findWinningMove(aiPlayer, currentBoard);
            if (winningMove !== null) {
                return winningMove;
            }

            const blockingMove = findBlockingMove(humanPlayer, currentBoard);
            if (blockingMove !== null) {
                return blockingMove;
            }

            const emptyCells = getEmptyCells(currentBoard);
            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            if (emptyCells.length > 0) {
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                return emptyCells[randomIndex];
            }
            return null;
        };

        const mediumAI = (currentBoard) => {
            const winningMove = findWinningMove(aiPlayer, currentBoard);
            if (winningMove !== null) {
                return winningMove;
            }

            const blockingMove = findBlockingMove(humanPlayer, currentBoard);
            if (blockingMove !== null) {
                return blockingMove;
            }

            const emptyCells = getEmptyCells(currentBoard);
            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) >= 2) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) >= 2) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            if (currentBoard[12] === '') {
                return 12;
            }

            const corners = [0, 4, 20, 24];
            const availableCorners = corners.filter(index => currentBoard[index] === '');
            if (availableCorners.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableCorners.length);
                return availableCorners[randomIndex];
            }

            return easyAI(currentBoard);
        };

        const hardAI = (currentBoard) => {
            const emptyCells = getEmptyCells(currentBoard);
            if (emptyCells.length === 0) return null;

            let bestMove = -1;
            let bestScore = -Infinity;

            const minimax = (boardState, depth, isMaximizingPlayer) => {
                if (checkForWin(aiPlayer, boardState)) {
                    return 10000 - depth;
                }
                if (checkForWin(humanPlayer, boardState)) {
                    return -10000 + depth;
                }
                if (getEmptyCells(boardState).length === 0) {
                    return 0;
                }

                if (depth >= MINIMAX_MAX_DEPTH) {
                    return evaluateBoard(boardState);
                }

                const tempEmptyCells = getEmptyCells(boardState);

                if (isMaximizingPlayer) {
                    let maxEval = -Infinity;
                    for (const move of tempEmptyCells) {
                        boardState[move] = aiPlayer;
                        const evaluation = minimax(boardState, depth + 1, false);
                        boardState[move] = '';
                        maxEval = Math.max(maxEval, evaluation);
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of tempEmptyCells) {
                        boardState[move] = humanPlayer;
                        const evaluation = minimax(boardState, depth + 1, true);
                        boardState[move] = '';
                        minEval = Math.min(minEval, evaluation);
                    }
                    return minEval;
                }
            };

            const evaluateBoard = (boardState) => {
                let score = 0;

                for (const combination of winningCombinations) {
                    let aiCount = 0;
                    let humanCount = 0;
                    let emptyCount = 0;

                    for (const index of combination) {
                        if (boardState[index] === aiPlayer) aiCount++;
                        else if (boardState[index] === humanPlayer) humanCount++;
                        else emptyCount++;
                    }

                    if (humanCount === 0) {
                        if (aiCount === WIN_LENGTH - 1 && emptyCount >= 1) score += 1000;
                        if (aiCount === WIN_LENGTH - 2 && emptyCount >= 2) score += 100;
                        if (aiCount === WIN_LENGTH - 3 && emptyCount >= 3) score += 10;
                    }

                    if (aiCount === 0) {
                        if (humanCount === WIN_LENGTH - 1 && emptyCount >= 1) score -= 900;
                        if (humanCount === WIN_LENGTH - 2 && emptyCount >= 2) score -= 90;
                        if (humanCount === WIN_LENGTH - 3 && emptyCount >= 3) score -= 9;
                    }
                }
                return score;
            };

            for (const move of emptyCells) {
                aiBoard[move] = aiPlayer;
                const score = minimax(aiBoard, 0, false);
                aiBoard[move] = '';

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            if (bestMove === -1 || (emptyCells.length === BOARD_SIZE * BOARD_SIZE && bestScore <= 0)) {
                if (aiBoard[12] === '') {
                    return 12;
                }
                const corners = [0, 4, 20, 24];
                const availableCorners = corners.filter(index => aiBoard[index] === '');
                if (availableCorners.length > 0) {
                    const randomIndex = Math.floor(Math.random() * availableCorners.length);
                    return availableCorners[randomIndex];
                }
                return easyAI(aiBoard);
            }

            return bestMove;
        };

        const makeAIPlayerMove = () => {
            if (!aiGameActive) return;

            let move = null;
            if (aiDifficulty === 'easy') {
                move = easyAI(aiBoard);
            } else if (aiDifficulty === 'medium') {
                move = mediumAI(aiBoard);
            } else if (aiDifficulty === 'hard') {
                move = hardAI(aiBoard);
            }

            if (move !== null) {
                makeAIMoveInternal(move, aiPlayer);
                checkAIGameStatus();
            }
        };

        const resetAIGame = () => {
            aiBoard = Array(25).fill('');
            aiCurrentPlayer = humanPlayer;
            aiGameActive = true;
            updateStatus(`Au tour de : ${aiCurrentPlayer}`, 'ai');
            aiCells.forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('x', 'o');
            });
            hideAllScreens();
            aiGameScreen.classList.remove('hidden');
            // Re-select difficulty button visually
            if (aiDifficulty) {
                document.getElementById(`${aiDifficulty}-button`).classList.add('selected-difficulty');
            }
        };

        const leaveAIGame = () => {
            aiDifficulty = null; // Reset difficulty
            difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            // Re-display current user's profile on returning to home
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        };

        const handleDifficultySelection = (difficulty) => {
            aiDifficulty = difficulty;
            difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
            document.getElementById(`${difficulty}-button`).classList.add('selected-difficulty');
            resetAIGame();
        };

        // --- Online Game Logic ---

        let matchmakingListenerUnsubscribe = null;

        async function findOnlineMatch() {
            if (!db || !currentUserId || !isAuthReady) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }

            hideAllScreens();
            onlineSearchingScreen.classList.remove('hidden');

            const queueCollectionRef = collection(db, 'matchmaking_queue');

            try {
                const q = query(queueCollectionRef);
                const querySnapshot = await getDocs(q);

                let foundOpponentId = null;
                let foundOpponentDocRef = null;

                for (const docSnapshot of querySnapshot.docs) {
                    if (docSnapshot.id !== currentUserId) {
                        const queueEntry = docSnapshot.data();
                        if (queueEntry.status === 'searching' && queueEntry.gameId === null && queueEntry.opponentId === null) {
                            foundOpponentId = docSnapshot.id;
                            foundOpponentDocRef = doc(db, 'matchmaking_queue', foundOpponentId);
                            break;
                        }
                    }
                }

                if (foundOpponentId) {
                    console.log("Matchmaking: Opponent found:", foundOpponentId);
                    const gameRef = doc(collection(db, 'games'));
                    const gameId = gameRef.id;

                    await setDoc(gameRef, {
                        playerXId: foundOpponentId,
                        playerOId: currentUserId,
                        board: Array(25).fill(''),
                        currentPlayer: 'X',
                        status: 'active',
                        winner: null,
                        createdAt: serverTimestamp(),
                        lastMoveTime: serverTimestamp()
                    });

                    await updateDoc(foundOpponentDocRef, {
                        status: 'matched',
                        gameId: gameId,
                        opponentId: currentUserId
                    });

                    await deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {});

                    console.log(`Matchmaking: Game ${gameId} created. Player X: ${foundOpponentId}, Player O: ${currentUserId}`);
                    startGameOnline(gameId, 'O', foundOpponentId);

                } else {
                    console.log("Matchmaking: No opponent found, entering queue.");
                    await setDoc(doc(queueCollectionRef, currentUserId), {
                        timestamp: serverTimestamp(),
                        status: 'searching',
                        opponentId: null,
                        gameId: null
                    });
                    console.log(`Matchmaking: User ${currentUserId} added to queue.`);

                    matchmakingListenerUnsubscribe = onSnapshot(doc(queueCollectionRef, currentUserId), (docSnap) => {
                        if (docSnap.exists() && docSnap.data().gameId) {
                            const data = docSnap.data();
                            console.log("Matchmaking: Our queue entry updated. Game found:", data.gameId, "Opponent:", data.opponentId);
                            if (matchmakingListenerUnsubscribe) {
                                matchmakingListenerUnsubscribe();
                                matchmakingListenerUnsubscribe = null;
                            }
                            startGameOnline(data.gameId, 'X', data.opponentId);
                            deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {});
                        } else if (!docSnap.exists()) {
                            console.warn("Matchmaking: Notre entrée dans la file a été retirée. Si la partie ne démarre pas, il y a un problème.");
                            if (!currentOnlineGameId) {
                                showMessage("La recherche de partie a été annulée ou a échoué. Veuillez réessayer.", () => {
                                    hideAllScreens();
                                    homeScreen.classList.remove('hidden');
                                    if (isAuthReady && currentUserId) {
                                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                                    }
                                });
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("Matchmaking error:", error);
                showMessage("Erreur lors de la recherche de partie: " + error.message, () => {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
                if (currentUserId) {
                    deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {});
                }
            }
        }

        async function cancelOnlineSearch() {
            if (matchmakingListenerUnsubscribe) {
                matchmakingListenerUnsubscribe();
                matchmakingListenerUnsubscribe = null;
            }
            if (currentUserId) {
                await deleteDoc(doc(db, 'matchmaking_queue', currentUserId)).catch(e => console.error("Error deleting queue entry:", e));
            }
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            showMessage("Recherche de partie annulée.");
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        }

        async function startGameOnline(gameId, playerRole, opponentId) {
            console.log(`Starting online game: ${gameId} as player ${playerRole} against ${opponentId}`);
            currentOnlineGameId = gameId;
            currentOnlinePlayerRole = playerRole;
            onlineOpponentUserId = opponentId; // Store opponent's ID
            onlineGameActive = true;
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';

            hideAllScreens();
            onlineGameScreen.classList.remove('hidden');
            document.getElementById('online-game-id-display').textContent = gameId;
            document.getElementById('online-player-role').textContent = playerRole;

            // Fetch opponent's profile to display their username, Elo, and level
            onlineOpponentProfile = await fetchUserProfile(onlineOpponentUserId); // Fetch opponent's profile
            if (onlineOpponentProfile) {
                document.getElementById('online-opponent-username').textContent = onlineOpponentProfile.username || 'Inconnu';
                document.getElementById('online-opponent-elo').textContent = onlineOpponentProfile.elo || 'N/A';
                document.getElementById('online-opponent-level').textContent = onlineOpponentProfile.level || 'N/A';
            } else {
                document.getElementById('online-opponent-username').textContent = 'Chargement...';
                document.getElementById('online-opponent-elo').textContent = 'N/A';
                document.getElementById('online-opponent-level').textContent = 'N/A';
            }


            createCells('online-board', handleOnlineCellClick);
            updateStatus(`Au tour de : X`, 'online');
            resetOnlineBoardUI();

            const gameRef = doc(db, 'games', gameId);
            onlineGameListenerUnsubscribe = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    console.log("Online game update received:", gameData);
                    console.log("Current User ID (in listener):", currentUserId);
                    console.log("Current Player Role (in listener):", currentOnlinePlayerRole);

                    onlineBoard = gameData.board;
                    onlineCurrentTurn = gameData.currentPlayer;
                    onlineGameActive = gameData.status === 'active';

                    for (let i = 0; i < onlineBoard.length; i++) {
                        const cell = onlineCells[i];
                        cell.innerHTML = onlineBoard[i];
                        cell.classList.remove('x', 'o');
                        if (onlineBoard[i] !== '') {
                            cell.classList.add(onlineBoard[i].toLowerCase());
                        }
                    }

                    if (gameData.status === 'finished') {
                        onlineGameActive = false;
                        if (gameData.winner === currentOnlinePlayerRole) {
                            showGameEndScreen('win', currentOnlinePlayerRole, 'online');
                        } else if (gameData.winner === 'draw') {
                            showGameEndScreen('draw', null, 'online');
                        } else { // Opponent won
                            showGameEndScreen('loss', gameData.winner, 'online');
                        }
                    } else if (gameData.status === 'abandoned') {
                        onlineGameActive = false;
                        if (gameData.winner === currentOnlinePlayerRole) {
                             // This means opponent abandoned and we "won" by default
                            showGameEndScreen('win', currentOnlinePlayerRole, 'online');
                        } else {
                            // This scenario ideally shouldn't happen if the winner is set to the other player on abandon
                            // but as a fallback, treat it as a loss or neutral if opponent's UID is our current role
                            showGameEndScreen('draw', null, 'online'); // Or loss if winner is explicitly other player
                        }
                    }
                    else {
                        updateStatus(`Au tour de : ${onlineCurrentTurn}`, 'online');
                    }

                } else {
                    console.log("Online game document deleted.");
                    showMessage("La partie a été annulée ou l'adversaire a quitté.", () => {
                        leaveOnlineGame();
                    });
                }
            }, (error) => {
                console.error("Error listening to online game:", error);
                showMessage("Erreur de connexion à la partie en ligne: " + error.message, () => {
                    leaveOnlineGame();
                });
            });
        }

        async function handleOnlineCellClick(event) {
            const clickedCellIndex = parseInt(event.target.dataset.index);

            if (!onlineGameActive || onlineBoard[clickedCellIndex] !== '' || onlineCurrentTurn !== currentOnlinePlayerRole) {
                return;
            }

            const newBoard = [...onlineBoard];
            newBoard[clickedCellIndex] = currentOnlinePlayerRole;

            const hasWon = checkForWin(currentOnlinePlayerRole, newBoard);
            const hasDraw = checkForDraw(newBoard);

            let nextPlayer = currentOnlinePlayerRole === 'X' ? 'O' : 'X';
            let gameStatus = 'active';
            let winner = null;

            if (hasWon) {
                gameStatus = 'finished';
                winner = currentOnlinePlayerRole;
            } else if (hasDraw) {
                gameStatus = 'finished';
                winner = 'draw';
            }

            try {
                await updateDoc(doc(db, 'games', currentOnlineGameId), {
                    board: newBoard,
                    currentPlayer: nextPlayer,
                    status: gameStatus,
                    winner: winner,
                    lastMoveTime: serverTimestamp()
                });
                console.log("Firestore mis à jour avec le mouvement.");
            } catch (error) {
                console.error("Erreur lors de l'envoi du mouvement:", error);
                showMessage("Erreur lors de l'envoi du mouvement: " + error.message);
            }
        }

        function resetOnlineBoardUI() {
            if (onlineCells) {
                onlineCells.forEach(cell => {
                    cell.innerHTML = '';
                    cell.classList.remove('x', 'o');
                });
            }
        }

        async function resetOnlineGame() {
            // Reinitialize game state for the current player
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';
            onlineGameActive = true;
            resetOnlineBoardUI();
            updateStatus(`Au tour de : X`, 'online');

            // Find a new match
            findOnlineMatch();
        }

        async function leaveOnlineGame() {
            if (onlineGameListenerUnsubscribe) {
                onlineGameListenerUnsubscribe();
                onlineGameListenerUnsubscribe = null;
            }
            if (currentOnlineGameId && db) {
                try {
                    const gameDoc = await getDoc(doc(db, 'games', currentOnlineGameId));
                    if (gameDoc.exists() && gameDoc.data().status === 'active') {
                        // Mark game as abandoned, setting the OTHER player as winner
                        await updateDoc(doc(db, 'games', currentOnlineGameId), {
                            status: 'abandoned',
                            winner: currentOnlinePlayerRole === 'X' ? 'O' : 'X',
                            lastMoveTime: serverTimestamp()
                        });
                        console.log("Partie en ligne marquée comme abandonnée.");
                        // Only update stats if we were the one abandoning an active game
                        updateUserProfileStats(currentUserId, 'loss', onlineOpponentProfile ? onlineOpponentProfile.elo : null);
                    }
                    // If game was already finished/abandoned, no need to update status
                } catch (error) {
                    console.error("Erreur lors de la tentative d'abandon de partie:", error);
                }
            }

            currentOnlineGameId = null;
            currentOnlinePlayerRole = null;
            onlineOpponentUserId = null; // Clear opponent ID
            onlineOpponentProfile = null; // Clear opponent profile
            onlineGameActive = false;
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';

            hideAllScreens();
            homeScreen.classList.remove('hidden');
            // Re-display current user's profile on returning to home
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        }


        // --- Fonctions de gestion du classement ---
        async function fetchLeaderboard() {
            if (!db || !isAuthReady) {
                leaderboardList.innerHTML = '<div class="text-center p-4 text-red-500">Erreur: Impossible de charger le classement. Firebase non prêt.</div>';
                return;
            }

            leaderboardList.innerHTML = '<div class="text-center p-4 text-gray-500">Chargement du classement...</div>';

            try {
                // Pour récupérer tous les documents sous les sous-collections 'profile/data' de chaque utilisateur,
                // nous devons d'abord lister tous les documents utilisateur dans la collection 'users',
                // puis récupérer la sous-collection 'profile/data' pour chacun.
                const usersCollectionRef = collection(db, `artifacts/${appId}/users`);
                const usersSnapshot = await getDocs(usersCollectionRef); // Ceci lit les documents parents (userId)
                console.log("Firebase: Nombre de documents parents utilisateur trouvés :", usersSnapshot.docs.length); // Log pour le débogage

                const users = [];

                // Pour chaque document utilisateur (qui est juste un conteneur pour les sous-collections)
                for (const userDoc of usersSnapshot.docs) {
                    const profileDocRef = doc(userDoc.ref, 'profile', 'data'); // Accéder à la sous-collection 'profile/data'
                    const profileSnap = await getDoc(profileDocRef); // Lire le document 'data' dans la sous-collection

                    if (profileSnap.exists()) {
                        const profileData = profileSnap.data();
                        users.push({
                            id: userDoc.id, // L'ID de l'utilisateur
                            username: profileData.username || 'Joueur Inconnu',
                            elo: profileData.elo || 0
                        });
                    }
                }

                // Trier les utilisateurs par Elo (du plus élevé au plus bas)
                users.sort((a, b) => b.elo - a.elo);

                displayLeaderboard(users);

            } catch (error) {
                console.error("Erreur lors de la récupération du classement:", error);
                leaderboardList.innerHTML = '<div class="text-center p-4 text-red-500">Erreur lors du chargement du classement.</div>';
                showMessage("Erreur lors du chargement du classement: " + error.message);
            }
        }

        function displayLeaderboard(users) {
            leaderboardList.innerHTML = ''; // Clear loading message

            if (users.length === 0) {
                leaderboardList.innerHTML = '<div class="text-center p-4 text-gray-500">Aucun joueur dans le classement pour le moment.</div>';
                return;
            }

            users.forEach((user, index) => {
                const rank = index + 1;
                const listItem = document.createElement('div');
                listItem.classList.add('leaderboard-item');

                if (rank === 1) {
                    listItem.classList.add('top-1');
                } else if (rank <= 3) {
                    listItem.classList.add('top-3');
                }

                listItem.innerHTML = `
                    <span class="rank">${rank}.</span>
                    <span class="username">${user.username}</span>
                    <span class="elo">${user.elo} Elo</span>
                `;
                leaderboardList.appendChild(listItem);
            });
        }

        function showLeaderboardScreen() {
            hideAllScreens();
            leaderboardScreen.classList.remove('hidden');
            fetchLeaderboard(); // Charger le classement à chaque fois qu'on y accède
        }

        // --- Helper for screen management ---
        function hideAllScreens() {
            homeScreen.classList.add('hidden');
            localGameScreen.classList.add('hidden');
            aiGameScreen.classList.add('hidden');
            onlineSearchingScreen.classList.add('hidden');
            onlineGameScreen.classList.add('hidden');
            gameEndScreen.classList.add('hidden'); // Ensure end screen is hidden
            leaderboardScreen.classList.add('hidden'); // Cacher le classement
        }


        // --- Logique de navigation entre les écrans ---
        document.addEventListener('DOMContentLoaded', function() {
            // Initial display of home screen
            hideAllScreens(); // Hide all initially
            homeScreen.classList.remove('hidden'); // Show home screen

            // Username management event listeners
            if (changeUsernameButton) {
                changeUsernameButton.addEventListener('click', showUsernameEditForm);
            }
            if (saveUsernameButton) {
                saveUsernameButton.addEventListener('click', handleSaveUsername);
            }
            if (cancelUsernameButton) {
                cancelUsernameButton.addEventListener('click', cancelUsernameEdit);
            }

            // Play Online button
            if (playOnlineButton) {
                playOnlineButton.addEventListener('click', function() {
                    if (isAuthReady && currentUserId) {
                        findOnlineMatch();
                    } else {
                        showMessage("Veuillez patienter, la connexion à Firebase est en cours...", () => {
                            if (isAuthReady && currentUserId) {
                                findOnlineMatch();
                            } else {
                                showMessage("Impossible de se connecter à Firebase. Veuillez vérifier votre connexion.");
                            }
                        });
                    }
                });
            }

            // Cancel Online Search button
            document.getElementById('cancelSearchButton').addEventListener('click', cancelOnlineSearch);

            // Leave Online Game button
            document.getElementById('online-leave-game-button').addEventListener('click', () => {
                showMessage("Êtes-vous sûr de vouloir quitter la partie ? Cela sera considéré comme une défaite.", () => {
                    leaveOnlineGame();
                });
            });

            // Game End Screen Buttons
            gameEndReplayButton.addEventListener('click', () => {
                gameEndScreen.classList.add('hidden');
                if (currentEndGameType === 'local') {
                    resetLocalGame();
                } else if (currentEndGameType === 'ai') {
                    resetAIGame();
                } else if (currentEndGameType === 'online') {
                    resetOnlineGame(); // This will initiate a new matchmaking search
                }
            });

            gameEndHomeButton.addEventListener('click', () => {
                gameEndScreen.classList.add('hidden');
                if (currentEndGameType === 'local') {
                    leaveLocalGame();
                } else if (currentEndGameType === 'ai') {
                    leaveAIGame();
                } else if (currentEndGameType === 'online') {
                    leaveOnlineGame();
                }
            });


            // Play Local button
            if (playLocalButton) {
                playLocalButton.addEventListener('click', function() {
                    hideAllScreens();
                    localGameScreen.classList.remove('hidden');
                    createCells('local-board', handleLocalCellClick);
                    resetLocalGame();
                });
            }

            if (localBackToHomeButton) {
                localBackToHomeButton.addEventListener('click', function() {
                    leaveLocalGame(); // Use the new leave function
                });
            }

            if (localResetButton) {
                localResetButton.addEventListener('click', resetLocalGame);
            }

            // Play AI button
            if (playAIButton) {
                playAIButton.addEventListener('click', function() {
                    hideAllScreens();
                    aiGameScreen.classList.remove('hidden');
                    createCells('ai-board', handleAICellClick);
                    updateStatus("Sélectionnez une difficulté pour commencer", 'ai');
                    aiGameActive = false;
                    difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
                });
            }

            if (aiBackToHomeButton) {
                aiBackToHomeButton.addEventListener('click', function() {
                    leaveAIGame(); // Use the new leave function
                });
            }

            if (easyButton) {
                easyButton.addEventListener('click', () => handleDifficultySelection('easy'));
            }
            if (mediumButton) {
                mediumButton.addEventListener('click', () => handleDifficultySelection('medium'));
            }
            if (hardButton) {
                hardButton.addEventListener('click', () => handleDifficultySelection('hard'));
            }

            if (aiResetButton) {
                aiResetButton.addEventListener('click', resetAIGame);
            }

            // --- Nouveaux Event Listeners pour Historique et Classement ---
            if (showHistoryButton) {
                showHistoryButton.addEventListener('click', function() {
                    showMessage("La section 'Historique des Parties' n'est pas encore implémentée.");
                    // hideAllScreens();
                    // historyScreen.classList.remove('hidden'); // Si vous implémentez cette section
                });
            }

            if (showLeaderboardButton) {
                showLeaderboardButton.addEventListener('click', function() {
                    if (isAuthReady && currentUserId) {
                        showLeaderboardScreen();
                    } else {
                        showMessage("Veuillez patienter, la connexion à Firebase est en cours...", () => {
                            if (isAuthReady && currentUserId) {
                                showLeaderboardScreen();
                            } else {
                                showMessage("Impossible de se connecter à Firebase. Veuillez vérifier votre connexion.");
                            }
                        });
                    }
                });
            }

            if (leaderboardBackToHomeButton) {
                leaderboardBackToHomeButton.addEventListener('click', function() {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    // Re-display current user's profile on returning to home
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
            }
        });
    </script>
</body>
</html>
