<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OXO Arena</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F0F2F5; /* Couleur de fond générale, gris très clair */
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Assure que le body prend au moins toute la hauteur du viewport */
            padding: 1rem; /* p-4 md:p-8 de Tailwind */
            overflow-x: hidden; /* Empêche le défilement horizontal */
            overflow-y: auto; /* Permet le défilement vertical si le contenu dépasse la hauteur du viewport */
        }
        /* Style pour le motif de fond subtil */
        .background-pattern {
            background-image:
                linear-gradient(45deg, rgba(26, 43, 60, 0.05) 25%, transparent 25%, transparent 75%, rgba(26, 43, 60, 0.05) 75%, rgba(26, 43, 60, 0.05) 100%),
                linear-gradient(-45deg, rgba(26, 43, 60, 0.05) 25%, transparent 25%, transparent 75%, rgba(26, 43, 60, 0.05) 75%, rgba(26, 43, 60, 0.05) 100%);
            background-size: 40px 40px; /* Taille de chaque carré du motif */
            background-position: 0 0, 20px 20px; /* Décalage pour un motif en damier */
            position: fixed; /* Fixe le motif en arrière-plan */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Assure que le motif est derrière le contenu */
        }

        /* Styles personnalisés pour le plateau de jeu */
        .board-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 colonnes de taille égale */
            grid-template-rows: repeat(5, 1fr);    /* 5 lignes de taille égale */
            /* Nouvelle approche pour garantir un carré parfait */
            width: min(90vw, 400px); /* Prend 90% de la largeur du viewport, max 400px */
            height: min(90vw, 400px); /* Prend la même valeur pour la hauteur pour un carré parfait */
            border: 2px solid #1A2B3C; /* Bordure foncée du thème */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Ombre plus prononcée */
            border-radius: 0.75rem; /* Coins arrondis */
            background-color: #ffffff; /* Fond blanc pour le plateau */
            overflow: hidden; /* Assure que les coins arrondis des cellules sont contenus */
            flex-shrink: 0; /* Empêche le plateau de rétrécir dans un conteneur flex */
        }

        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Utilisation de min() pour une taille de police réactive mais plafonnée */
            font-size: min(8vw, 2.5rem); /* Adapte la taille de la police, max 2.5rem */
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #e0e0e0; /* Bordure de cellule plus claire */
            transition: background-color 0.2s ease-in-out;
            color: #1A2B3C; /* Couleur par default du texte (sombre du thème) */
            user-select: none; /* Empêche la sélection du texte */
            box-sizing: border-box; /* Inclut padding et bordure dans la taille de l'élément */
        }

        .cell:hover {
            background-color: #f5f5f5; /* Léger survol */
        }

        /* Couleurs des joueurs basées sur le thème OXO Arena */
        .cell.x {
            color: #FFD700; /* Jaune doré pour X */
        }

        .cell.o {
            color: #1A2B3C; /* Bleu foncé pour O */
        }

        /* Styles pour les coins arrondis des cellules (pour les cellules du coin du plateau) */
        .cell:nth-child(1) { border-top-left-radius: 0.75rem; }
        .cell:nth-child(5) { border-top-right-radius: 0.75rem; }
        .cell:nth-child(21) { border-bottom-left-radius: 0.75rem; }
        .cell:nth-child(25) { border-bottom-right-radius: 0.75rem; }

        /* Styles pour les boutons de réinitialisation et de retour */
        .game-button {
            background-color: #1A2B3C; /* Couleur principale du thème */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Ombre pour le bouton */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem; /* Equivalent de space-x-3 */
        }

        .game-button:hover {
            background-color: #334a60; /* Couleur plus claire au survol */
            transform: translateY(-2px); /* Léger effet de soulèvement */
        }

        .game-button:active {
            transform: translateY(0); /* Retour à la position normale au clic */
        }

        /* Couleurs spécifiques pour les boutons de difficulté, adaptées au thème OXO Arena */
        #easy-button { background-color: #60A5FA; } /* Bleu clair */
        #easy-button:hover { background-color: #3B82F6; }

        #medium-button { background-color: #FBBF24; } /* Jaune/Orange */
        #medium-button:hover { background-color: #F59E0B; }

        #hard-button { background-color: #EF4444; } /* Rouge */
        #hard-button:hover { background-color: #DC2626; }

        /* Style pour la boîte de message */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            max-width: 90%;
            text-align: center;
        }
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        /* Style pour la difficulté sélectionnée */
        .selected-difficulty {
            border: 3px solid #FFD700; /* Bordure jaune dorée pour indiquer la sélection */
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); /* Ombre lumineuse */
        }

        /* Styles pour l'animation de chargement */
        .loader {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #FFD700; /* Yellow */
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles for the NEW game end overlay (banner) */
        .game-end-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 998; /* Below message box, above game */
            background-color: transparent; /* Initially transparent */
        }

        .game-end-banner {
            background-color: rgba(26, 43, 60, 0.8); /* Semi-transparent dark blue */
            color: white;
            padding: 1.5rem 3rem; /* Increased padding */
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5); /* Stronger shadow */
            max-width: 90%; /* Allow more width */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Increased gap */
            pointer-events: auto; /* Allow clicks on buttons within the banner */
        }

        .game-end-banner h2 {
            font-size: 2.5rem; /* Adjusted font size */
            font-weight: bold;
            color: #FFD700; /* Yellow accent */
            margin-bottom: 0.5rem;
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .game-end-banner h2 {
                font-size: 3rem;
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            .game-end-banner h2 {
                font-size: 4rem;
            }
        }


        .game-end-banner p {
            font-size: 1.25rem; /* Adjusted font size */
            margin-bottom: 1rem;
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .game-end-banner p {
                font-size: 1.5rem;
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            .game-end-banner p {
                font-size: 1.8rem;
            }
        }

        .game-end-banner .button-group {
            display: flex;
            gap: 1.5rem; /* Increased gap */
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Styles spécifiques pour le classement */
        .leaderboard-list {
            width: 100%;
            max-width: 500px;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            font-size: 1.125rem;
            cursor: pointer; /* Rendre les éléments cliquables */
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-item .rank {
            font-weight: bold;
            color: #1A2B3C;
            width: 30px;
            text-align: center;
        }

        .leaderboard-item .username {
            flex-grow: 1;
            font-weight: 600;
            color: #334a60;
            text-align: left;
            padding-left: 1rem;
        }

        .leaderboard-item .elo {
            font-weight: bold;
            color: #FFD700;
            width: 60px;
            text-align: right;
        }

        .leaderboard-item.top-3 {
            background-color: #FFFBEB; /* Light yellow background for top 3 */
        }
        .leaderboard-item.top-1 {
            background-color: #FFD700; /* Gold for rank 1 */
            color: #1A2B3C;
        }
        .leaderboard-item.top-1 .rank, .leaderboard-item.top-1 .username, .leaderboard-item.top-1 .elo {
            color: #1A2B3C;
        }

        /* Custom scrollbar for game history */
        #games-history-list::-webkit-scrollbar {
            width: 8px;
        }
        #games-history-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        #games-history-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        #games-history-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Styles for game history detail screen */
        .history-detail-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 100%;
        }

        .history-detail-info {
            width: 100%;
            background-color: #f8f8f8;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
        }
        .history-detail-info p {
            margin-bottom: 0.5rem;
        }
        .history-detail-info p span {
            font-weight: 600;
        }

        .history-detail-board-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .history-detail-board-controls button {
            background-color: #1A2B3C;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .history-detail-board-controls button:hover {
            background-color: #334a60;
        }
        .history-detail-board-controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Styles pour le bouton de notification (cloche) */
        #notification-button {
            position: relative;
            background-color: transparent;
            border: none;
            color: #1A2B3C;
            font-size: 1.8rem; /* Taille de l'icône */
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        #notification-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        #notification-count {
            position: absolute;
            top: 0;
            right: 0;
            background-color: #EF4444; /* Rouge */
            color: white;
            border-radius: 50%;
            padding: 0.2em 0.5em;
            font-size: 0.7rem;
            font-weight: bold;
            line-height: 1;
            min-width: 1.5em; /* Pour les nombres à deux chiffres */
            text-align: center;
            transform: translate(25%, -25%);
            display: none; /* Caché par default */
        }

        /* Styles pour les modals génériques (profil, notifications, invitations de partie) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            overflow-y: auto; /* Permet le défilement si le contenu est trop grand */
            padding: 1rem;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            max-width: 90%;
            max-height: 90vh; /* Limite la hauteur du modal */
            overflow-y: auto; /* Rend le contenu du modal défilable */
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative; /* Pour le bouton de fermeture */
        }
        .modal-close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #1A2B3C;
            cursor: pointer;
        }

        /* Styles spécifiques pour la liste d'amis/recherche */
        .user-list-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .user-list-item:hover {
            background-color: #f5f5f5;
        }
        .user-list-item:last-child {
            border-bottom: none;
        }
        .user-list-item .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: gray; /* Offline */
        }
        .user-list-item .status-indicator.online {
            background-color: #22C55E; /* Vert */
        }
        .user-list-item .username-display {
            font-weight: 600;
            color: #1A2B3C;
        }
        .user-list-item .user-id-display {
            font-size: 0.8rem;
            color: #6B7280;
            flex-grow: 1; /* Prend l'espace restant */
            text-align: right;
            padding-left: 0.5rem; /* Petit espace */
            word-break: break-all; /* Empêche l'ID de déborder */
        }

        /* Styles pour les demandes d'amis et invitations de partie dans le modal de notifications */
        .notification-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e0e0e0;
        }
        .notification-item:last-child {
            border-bottom: none;
        }
        .notification-item .actions button {
            margin-left: 0.5rem;
            padding: 0.4rem 0.8rem;
            border-radius: 0.3rem;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .notification-item .actions .accept-button {
            background-color: #22C55E;
            color: white;
        }
        .notification-item .actions .accept-button:hover {
            background-color: #16A34A;
        }
        .notification-item .actions .decline-button {
            background-color: #EF4444;
            color: white;
        }
        .notification-item .actions .decline-button:hover {
            background-color: #DC2626;
        }

        /* Styles pour les chronomètres */
        .timer-display {
            font-size: 2.2rem; /* Taille plus grande pour les chronos */
            font-weight: bold;
            color: #1A2B3C;
            background-color: #E0E0E0; /* Fond légèrement gris */
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            min-width: 150px; /* Largeur minimale pour éviter le saut */
            text-align: center;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .timer-display.active {
            background-color: #FFD700; /* Jaune pour le joueur actif */
            color: #1A2B3C;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .timer-display.low-time {
            background-color: #EF4444; /* Rouge pour le temps faible */
            color: white;
        }

        /* Styles pour le bouton de toggle (Classique/Blitz) */
        .toggle-button-group {
            display: flex;
            background-color: #e0e0e0;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .toggle-button {
            padding: 0.5rem 1rem;
            font-weight: 600;
            color: #6B7280;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .toggle-button.active {
            background-color: #1A2B3C;
            color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .toggle-button:hover:not(.active) {
            background-color: #cccccc;
        }

    </style>
</head>
<body class="background-pattern">
    <div class="w-full max-w-6xl flex flex-col items-center justify-center">

        <div id="home-screen" class="bg-white rounded-xl shadow-2xl w-full flex flex-col md:flex-row max-h-[calc(100vh-2rem)] overflow-y-auto">
            <div class="w-full md:w-1/3 p-6 md:p-10 flex flex-col items-center justify-center bg-[#1A2B3C] text-white rounded-t-xl md:rounded-l-xl md:rounded-tr-none flex-shrink-0">
                <h1 class="text-4xl md:text-5xl font-extrabold mb-8 text-center tracking-tight">
                    OXO Arena
                </h1>
                <nav class="w-full space-y-4">
                    <button id="playOnlineButton" class="w-full py-3 px-6 bg-[#FFD700] text-[#1A2B3C] font-semibold rounded-lg shadow-md hover:bg-yellow-400 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                        <span>Jouer en Ligne</span>
                    </button>
                    <button id="playLocalButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M17 20h2a2 2 0 002-2V4a2 2 0 00-2-2H5a2 2 0 00-2 2v14a2 2 0 002 2h2m10 0v2m0-2h-3m-2 0h-2M9 16H5a2 2 0 00-2 2v2h10v-2a2 2 0 00-2-2z" />
                        </svg>
                        <span>Jouer en Local</span>
                    </button>
                    <button id="playAIButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 7h14a2 2 0 002-2V3a2 2 0 00-2-2H5a2 2 0 00-2 2v2a2 2 0 002 2zM12 11h.01M12 15h.01" />
                        </svg>
                        <span>Jouer Contre IA</span>
                    </button>
                    <button id="showLeaderboardButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        <span>Classement</span>
                    </button>
                    <button id="showFriendsButton" class="w-full py-3 px-6 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                        <i class="fas fa-users h-6 w-6"></i> <span>Amis</span>
                    </button>
                </nav>
            </div>

            <div class="w-full md:w-2/3 p-6 md:p-10 flex flex-col justify-center items-center text-[#1A2B3C] flex-grow overflow-y-auto">
                <div class="w-full flex justify-between items-center mb-6">
                    <h2 class="text-3xl md:text-4xl font-bold text-center flex-grow">Votre Profil</h2>
                    <button id="notification-button" class="relative">
                        <i class="fas fa-bell"></i>
                        <span id="notification-count" class="absolute top-0 right-0 bg-red-500 text-white rounded-full px-2 py-1 text-xs font-bold -mt-2 -mr-2 hidden">0</span>
                    </button>
                </div>
                <div id="profile-loading" class="text-xl text-gray-500">Chargement du profil...</div>
                <div id="profile-content" class="bg-gray-100 p-4 rounded-xl shadow-inner w-full max-w-sm md:max-w-md space-y-3 text-base md:text-lg hidden">
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">ID Utilisateur :</span>
                        <span id="user-id-display" class="text-gray-700 font-medium break-all text-sm md:text-base"></span>
                    </p>
                    <div class="flex flex-col items-start w-full">
                        <div class="flex justify-between items-center w-full">
                            <span class="font-semibold">Pseudo :</span>
                            <span id="profile-username" class="text-gray-700 font-medium"></span>
                            <button id="change-username-button" class="ml-2 px-2 py-1 bg-[#FFD700] text-[#1A2B3C] text-xs rounded-md hover:bg-yellow-400 transition-colors">Modifier</button>
                        </div>
                        <div id="username-edit-section" class="hidden mt-2 w-full">
                            <input type="text" id="new-username-input" class="w-full p-2 border border-gray-300 rounded-md text-gray-800" placeholder="Nouveau pseudo (3-20 caractères)">
                            <button id="save-username-button" class="mt-2 w-full py-2 bg-[#1A2B3C] text-white rounded-md hover:bg-gray-800">Sauvegarder</button>
                            <button id="cancel-username-button" class="mt-2 w-full py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500">Annuler</button>
                        </div>
                        <p id="username-cooldown-message" class="text-xs text-red-600 mt-1 text-center w-full hidden"></p>
                    </div>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Elo (Classique) :</span>
                        <span id="profile-elo-classic" class="text-[#FFD700] font-bold"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Elo (Blitz) :</span>
                        <span id="profile-elo-blitz" class="text-[#FFD700] font-bold"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Niveau :</span>
                        <span id="profile-level" class="text-[#FFD700] font-bold"></span>
                    </p>
                    <div class="border-t border-gray-300 pt-4 mt-4"></div>
                    <h3 class="text-xl font-bold mb-2 text-center">Statistiques</h3>
                    <div class="flex justify-center mb-4">
                        <div class="toggle-button-group">
                            <button id="stats-toggle-classic" class="toggle-button active">Classique</button>
                            <button id="stats-toggle-blitz" class="toggle-button">Blitz</button>
                        </div>
                    </div>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Parties jouées :</span>
                        <span id="profile-games-played" class="font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Victoires :</span>
                        <span id="profile-wins" class="text-green-600 font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="font-semibold">Défaites :</span>
                        <span id="profile-losses" class="text-red-600 font-medium"></span>
                    </p>
                    <p class="flex justify-between items-center" id="profile-draws-row">
                        <span class="font-semibold">Nuls :</span>
                        <span id="profile-draws" class="text-gray-500 font-medium"></span>
                    </p>
                </div>
                <button id="showHistoryButton" class="mt-8 py-3 px-8 bg-[#1A2B3C] text-white font-semibold rounded-lg shadow-lg hover:bg-gray-800 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>Historique des Parties</span>
                </button>
            </div>
        </div>

        <div id="online-play-selection-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-8 text-center">Jouer en Ligne</h1>
            <p class="text-lg text-gray-600 mb-8 text-center">
                Choisissez votre mode de jeu en ligne.
            </p>
            <div class="w-full space-y-6">
                <button id="select-classic-online-button" class="w-full py-4 px-6 bg-[#1A2B3C] text-white font-semibold rounded-lg shadow-lg hover:bg-gray-800 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-4 text-xl">
                    <i class="fas fa-chess-board h-8 w-8"></i> <span>Classique</span>
                </button>
                <button id="select-blitz-online-button" class="w-full py-4 px-6 bg-[#FFD700] text-[#1A2B3C] font-semibold rounded-lg shadow-lg hover:bg-yellow-400 transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center gap-4 text-xl">
                    <i class="fas fa-stopwatch h-8 w-8"></i> <span>Blitz</span>
                </button>
            </div>
            <button id="online-selection-back-to-home-button" class="game-button mt-8">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                </svg>
                <span>Retour à l'Accueil</span>
            </button>
        </div>

        <div id="leaderboard-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-6 text-center">Classement des Joueurs</h1>
            <div class="flex justify-center mb-6">
                <div class="toggle-button-group">
                    <button id="leaderboard-toggle-classic" class="toggle-button active">Classique</button>
                    <button id="leaderboard-toggle-blitz" class="toggle-button">Blitz</button>
                </div>
            </div>
            <div id="leaderboard-list" class="leaderboard-list">
                <div class="text-center p-4 text-gray-500">Chargement du classement...</div>
            </div>
            <button id="leaderboard-back-to-home-button" class="game-button mt-8">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                </svg>
                <span>Retour à l'Accueil</span>
            </button>
        </div>

        <div id="local-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - Local</h1>
            <p class="text-center text-gray-600 mb-6 italic">
                Les parties jouées en local n'impactent pas vos statistiques (Elo, niveau, nombre de parties, etc.).
            </p>
            <div id="local-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]">Au tour de : X</div>

            <div id="local-board" class="board-grid">
                </div>

            <div class="mt-8 flex flex-wrap justify-center gap-4">
                <button id="local-reset-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                    </svg>
                    <span>Nouvelle partie</span>
                </button>
                <button id="local-back-to-home-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                        </svg>
                    <span>Retour à l'Accueil</span>
                </button>
            </div>
        </div>

        <div id="ai-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - Contre IA</h1>
            <p class="text-center text-gray-600 mb-6 italic">
                Les parties jouées contre l'IA en mode Facile et Moyen n'impactent pas vos statistiques (Elo, niveau, nombre de parties, etc.). Seules les parties en mode Difficile sont prises en compte.
            </p>
            <div id="ai-difficulty-buttons" class="flex flex-wrap justify-center gap-4 mb-8">
                <button id="easy-button" class="game-button">Facile</button>
                <button id="medium-button" class="game-button">Moyen</button>
                <button id="hard-button" class="game-button">Difficile</button>
            </div>
            <div id="ai-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]">Sélectionnez une difficulté pour commencer</div>

            <div id="ai-board" class="board-grid">
                </div>

            <div class="mt-8 flex flex-wrap justify-center gap-4">
                <button id="ai-reset-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                    </svg>
                    <span>Nouvelle partie</span>
                </button>
                <button id="ai-back-to-home-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                        </svg>
                    <span>Retour à l'Accueil</span>
                </button>
            </div>
        </div>

        <div id="online-searching-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-4 text-center">Recherche de partie...</h1>
            <p class="text-lg text-gray-600 mb-8 text-center">
                Veuillez patienter pendant que nous trouvons un adversaire pour vous.
            </p>
            <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32 mb-8" style="border-top-color: #FFD700;"></div>
            <button id="cancelSearchButton" class="game-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
                <span>Annuler la recherche</span>
            </button>
        </div>

        <div id="online-game-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h1 class="text-4xl font-extrabold mb-4 text-center text-[#1A2B3C]">OXO Arena - En Ligne</h1>
            <p class="text-center text-gray-600 mb-2 italic">
                Votre ID de partie : <span id="online-game-id-display" class="font-semibold break-all text-sm"></span>
            </p>
            <p class="text-center text-gray-600 mb-2 italic">
                Vous êtes le joueur : <span id="online-player-role" class="font-bold"></span>
            </p>
            <div class="text-center text-gray-600 mb-6 italic">
                <p>Adversaire : <span id="online-opponent-username" class="font-semibold text-sm"></span></p>
                <p>Elo : <span id="online-opponent-elo" class="font-semibold text-sm"></span> | Niveau : <span id="online-opponent-level" class="font-semibold text-sm"></span></p>
            </div>

            <div class="flex justify-around w-full mb-6 gap-4">
                <div class="flex flex-col items-center">
                    <span class="text-lg font-semibold text-gray-700">Votre Temps:</span>
                    <div id="player-time-display" class="timer-display">00:00.00</div>
                </div>
                <div class="flex flex-col items-center">
                    <span class="text-lg font-semibold text-gray-700">Temps Adversaire:</span>
                    <div id="opponent-time-display" class="timer-display">00:00.00</div>
                </div>
            </div>

            <div id="online-game-status" class="text-2xl font-semibold mb-6 text-center text-[#1A2B3C]"></div>

            <div id="online-board" class="board-grid"></div>

            <div class="mt-8 flex flex-wrap justify-center gap-4">
                <button id="online-leave-game-button" class="game-button bg-red-600 hover:bg-red-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                    </svg>
                    <span>Quitter la partie</span>
                </button>
            </div>
        </div>

    </div>

    <div id="game-end-overlay" class="game-end-overlay hidden">
        <div id="game-end-banner" class="game-end-banner hidden">
            <h2 id="game-end-title" class="text-2xl sm:text-3xl lg:text-4xl"></h2>
            <p id="game-end-message" class="text-lg sm:text-xl lg:text-2xl"></p>
            <div class="button-group">
                <button id="game-end-replay-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 13v-1m7-7h.582m15.356 2A8.001 8.001 0 004 13v-1" />
                    </svg>
                    <span>Rejouer</span>
                </button>
                <button id="game-end-home-button" class="game-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                    </svg>
                    <span>Retour à l'Accueil</span>
                </button>
            </div>
        </div>
    </div>


    <div id="message-box-overlay" class="message-box-overlay hidden"></div>
    <div id="message-box" class="message-box hidden">
        <p id="message-box-text" class="text-xl font-semibold text-[#1A2B3C]"></p>
        <button id="message-box-close" class="game-button">OK</button>
    </div>

    <div id="history-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
        <h1 class="text-4xl font-extrabold mb-6 text-center">Historique des Parties</h1>
        <div id="games-history-list" class="space-y-4 overflow-y-auto max-h-[60vh] w-full custom-scrollbar">
            </div>
        <button id="history-back-button" class="game-button mt-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
            </svg>
            <span>Retour à l'Historique</span>
        </button>
    </div>

    <div id="history-detail-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
        <h1 class="text-4xl font-extrabold mb-6 text-center">Détails de la Partie</h1>
        <div class="history-detail-container">
            <div id="detail-game-info" class="history-detail-info">
                <p>Mode: <span id="detail-mode"></span></p>
                <p>Date: <span id="detail-date"></span></p>
                <p>Adversaire: <span id="detail-opponent"></span></p>
                <p>Statut: <span id="detail-status"></span></p>
            </div>
            <div id="detail-board" class="board-grid">
                </div>
            <div class="history-detail-board-controls">
                <button id="prev-move-button" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 17l-5-5m0 0l5-5m-5 5h12" />
                    </svg>
                </button>
                <span id="move-counter">Coup 0/0</span>
                <button id="next-move-button" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M13 7l5 5m0 0l-5 5m5-5H6" />
                    </svg>
                </button>
            </div>
        </div>
        <button id="detail-back-button" class="game-button mt-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
            </svg>
            <span>Retour à l'Historique</span>
        </button>
    </div>

    <div id="friends-screen" class="hidden bg-white rounded-xl shadow-2xl p-6 md:p-10 flex flex-col items-center max-w-lg w-full text-[#1A2B3C] max-h-[calc(100vh-2rem)] overflow-y-auto">
        <h1 class="text-4xl font-extrabold mb-6 text-center">Vos Amis</h1>

        <div class="w-full mb-6">
            <h2 class="text-2xl font-bold mb-4 text-center">Rechercher un utilisateur</h2>
            <div class="flex gap-2 mb-4">
                <input type="text" id="user-search-input" placeholder="Pseudo ou ID utilisateur" class="flex-grow p-2 border border-gray-300 rounded-md text-gray-800">
                <button id="user-search-button" class="game-button px-4 py-2">
                    <i class="fas fa-search"></i>
                </button>
            </div>
            <div id="user-search-results" class="bg-gray-50 rounded-md shadow-inner max-h-48 overflow-y-auto hidden">
                <p class="p-4 text-gray-500 text-center">Aucun résultat.</p>
            </div>
        </div>

        <div class="w-full mb-6">
            <h2 class="text-2xl font-bold mb-4 text-center">Mes Amis</h2>
            <div id="friends-list" class="bg-gray-50 rounded-md shadow-inner max-h-64 overflow-y-auto">
                <p class="p-4 text-gray-500 text-center">Vous n'avez pas encore d'amis.</p>
            </div>
        </div>

        <button id="share-app-button" class="game-button mt-4 bg-blue-600 hover:bg-blue-700">
            <i class="fas fa-share-alt h-6 w-6"></i> <span>Partager l'application</span>
        </button>

        <button id="friends-back-to-home-button" class="game-button mt-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
            </svg>
            <span>Retour à l'Accueil</span>
        </button>
    </div>

    <div id="user-profile-modal-overlay" class="modal-overlay hidden">
        <div id="user-profile-modal-content" class="modal-content">
            <button class="modal-close-button" id="user-profile-modal-close"><i class="fas fa-times"></i></button>
            <h2 id="modal-profile-username" class="text-3xl font-bold text-center text-[#1A2B3C] mb-4"></h2>
            <p class="text-center text-gray-600 text-sm">ID: <span id="modal-profile-id" class="break-all"></span></p>
            <p class="text-center text-gray-600 text-sm">Dernière activité: <span id="modal-profile-last-online"></span></p>

            <div class="bg-gray-100 p-4 rounded-xl shadow-inner w-full space-y-3 text-base">
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Elo (Classique) :</span>
                    <span id="modal-profile-elo-classic" class="text-[#FFD700] font-bold"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Elo (Blitz) :</span>
                    <span id="modal-profile-elo-blitz" class="text-[#FFD700] font-bold"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Niveau :</span>
                    <span id="modal-profile-level" class="text-[#FFD700] font-bold"></span>
                </p>
                <div class="border-t border-gray-300 pt-4 mt-4"></div>
                <h3 class="text-xl font-bold mb-2 text-center">Statistiques</h3>
                <p class="text-center text-gray-600 italic text-sm">
                    Les statistiques affichées sont celles du mode Classique.
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Parties jouées :</span>
                    <span id="modal-profile-games-played" class="font-medium"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Victoires :</span>
                    <span id="modal-profile-wins" class="text-green-600 font-medium"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Défaites :</span>
                    <span id="modal-profile-losses" class="text-red-600 font-medium"></span>
                </p>
                <p class="flex justify-between items-center">
                    <span class="font-semibold">Nuls :</span>
                    <span id="modal-profile-draws" class="text-gray-500 font-medium"></span>
                </p>
            </div>

            <div class="flex flex-wrap justify-center gap-4 mt-4">
                <button id="send-friend-request-button" class="game-button px-4 py-2 text-sm bg-blue-600 hover:bg-blue-700 hidden">
                    <i class="fas fa-user-plus mr-2"></i> Envoyer Demande
                </button>
                <button id="cancel-friend-request-button" class="game-button px-4 py-2 text-sm bg-yellow-600 hover:bg-yellow-700 hidden">
                    <i class="fas fa-user-minus mr-2"></i> Annuler Demande
                </button>
                <button id="accept-friend-request-button" class="game-button px-4 py-2 text-sm bg-green-600 hover:bg-green-700 hidden">
                    <i class="fas fa-check mr-2"></i> Accepter Demande
                </button>
                <button id="decline-friend-request-button" class="game-button px-4 py-2 text-sm bg-red-600 hover:bg-red-700 hidden">
                    <i class="fas fa-times mr-2"></i> Refuser Demande
                </button>
                <button id="unfriend-button" class="game-button px-4 py-2 text-sm bg-gray-600 hover:bg-gray-700 hidden">
                    <i class="fas fa-user-slash mr-2"></i> Défriender
                </button>
                <button id="block-user-button" class="game-button px-4 py-2 text-sm bg-red-800 hover:bg-red-900 hidden">
                    <i class="fas fa-ban mr-2"></i> Bloquer
                </button>
                <button id="unblock-user-button" class="game-button px-4 py-2 text-sm bg-green-800 hover:bg-green-900 hidden">
                    <i class="fas fa-unlock mr-2"></i> Débloquer
                </button>
                <button id="propose-game-button" class="game-button px-4 py-2 text-sm bg-purple-600 hover:bg-purple-700 hidden">
                    <i class="fas fa-gamepad mr-2"></i> Proposer Partie
                </button>
                </div>
        </div>
    </div>

    <div id="notification-modal-overlay" class="modal-overlay hidden">
        <div id="notification-modal-content" class="modal-content">
            <button class="modal-close-button" id="notification-modal-close"><i class="fas fa-times"></i></button>
            <h2 class="text-3xl font-bold text-center text-[#1A2B3C] mb-4">Notifications</h2>
            <div id="notification-list" class="space-y-3">
                <p class="p-4 text-gray-500 text-center">Aucune notification.</p>
            </div>
        </div>
    </div>

    <div id="game-invite-modal-overlay" class="modal-overlay hidden">
        <div id="game-invite-modal-content" class="modal-content">
            <button class="modal-close-button" id="game-invite-modal-close"><i class="fas fa-times"></i></button>
            <h2 id="game-invite-title" class="text-3xl font-bold text-center text-[#1A2B3C] mb-4">Invitation de Partie</h2>
            <p id="game-invite-message" class="text-xl text-center text-gray-700 mb-6"></p>
            <div id="game-invite-buttons" class="flex justify-center gap-4">
                <button id="accept-game-invite-button" class="game-button px-6 py-3 bg-green-600 hover:bg-green-700">Accepter</button>
                <button id="decline-game-invite-button" class="game-button px-6 py-3 bg-red-600 hover:bg-red-700">Refuser</button>
            </div>
            <div id="game-invite-status-message" class="text-center text-red-500 mt-4 hidden"></div>
        </div>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, where, getDocs, onSnapshot, serverTimestamp, arrayUnion, arrayRemove, or, and, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-functions.js";


        // --- Firebase Initialization ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'oxoarena'; // Default to 'oxoarena' if not provided by Canvas
        let firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        if (Object.keys(firebaseConfig).length === 0) {
            console.warn("Firebase: Exécution locale. Utilisation de la configuration Firebase fournie par l'utilisateur.");
            firebaseConfig = {
                apiKey: "AIzaSyCTAax7cKcxL29HwwVgRxD8AfqDzx8tG6A",
                authDomain: "oxoarena-2476d.firebaseapp.com",
                projectId: "oxoarena-2476d",
                storageBucket: "oxoarena-2476d.firebaseolage.app",
                messagingSenderId: "1071875114714",
                appId: "1:1071875114714:web:0658dedac66047438f07e3",
                measurementId: "G-3N7C3R5HYV"
            };
        }

        let app;
        let db;
        let auth;
        let currentUserId = null;
        let isAuthReady = false;
        let userProfileData = null; // Stores current user's profile data
        let userProfileListenerUnsubscribe = null; // Listener for current user's profile

        // Online Game Variables
        let currentOnlineGameId = null;
        let currentOnlinePlayerRole = null;
        let onlineBoard = Array(25).fill('');
        let onlineCurrentTurn = 'X';
        let onlineGameActive = false;
        let onlineCells;
        let onlineGameListenerUnsubscribe = null;
        let onlineOpponentUserId = null; // Store opponent's user ID
        let onlineOpponentProfile = null; // Store opponent's profile data
        let currentOnlineGameMode = 'classic'; // Default to classic, can be 'blitz'

        // Timer variables for online games
        const BLITZ_TIME_LIMIT_MS = 30 * 1000; // 30 seconds in milliseconds
        let playerXTime = BLITZ_TIME_LIMIT_MS;
        let playerOTime = BLITZ_TIME_LIMIT_MS;
        let timerInterval = null;
        let lastMoveTimestamp = null; // Timestamp of the last move from the server

        // Friend System Variables
        let friendsListenerUnsubscribe = null;
        let pendingRequestsListenerUnsubscribe = null;
        let currentFriendshipDocId = null; // Stores the document ID of the current friendship being viewed/managed

        // Game Invitation Variables
        let gameInvitesListenerUnsubscribe = null; // Listener for incoming game invites
        let gameProposals = []; // Array to store incoming game proposals
        let currentIncomingGameInvite = null; // Stores the active game invite being displayed in the modal
        let currentSentInviteListenerUnsubscribe = null; // Listener for the game invite sent by this user

        // Global variable to store all user profiles for quick lookup (e.g., by ID or username)
        // This will be populated by fetching all profiles, primarily for search and display.
        let allUserProfiles = {};

        // Variable to store the invite_from ID from the URL, if present
        let urlInviteFromId = null;

        // Current display mode for stats and leaderboard
        let currentStatsDisplayMode = 'classic'; // 'classic' or 'blitz'
        let currentLeaderboardDisplayMode = 'classic'; // 'classic' or 'blitz'


        if (Object.keys(firebaseConfig).length > 0 && firebaseConfig.apiKey) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    isAuthReady = true;
                    console.log("Firebase: User signed in:", currentUserId);
                    userProfileData = await fetchUserProfile(currentUserId);
                    displayUserProfile(currentUserId, userProfileData);
                    document.getElementById('profile-loading').classList.add('hidden');
                    document.getElementById('profile-content').classList.remove('hidden');

                    // Start listening to friends, pending requests, and game invites
                    setupFriendshipListeners();
                    setupGameInviteListener(); // Setup listener for incoming game invites
                    // Fetch all user profiles for search functionality
                    await fetchAllUserProfiles(); // Ensure profiles are loaded before processing invitation
                    // Set up presence (lastOnline) listener
                    setupPresenceListener();

                    // Process URL invitation AFTER user is authenticated and profiles are loaded
                    if (urlInviteFromId) {
                        processUrlInvitation(urlInviteFromId);
                        urlInviteFromId = null; // Clear it after processing
                    }

                } else {
                    console.log("Firebase: No user signed in. Attempting sign-in.");
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Firebase: Signed in with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Firebase: Signed in anonymously.");
                        }
                    } catch (error) {
                        console.error("Firebase: Authentication error:", error);
                        if (error.code !== 'permission-denied') {
                            showMessage("Erreur de connexion Firebase: " + error.message);
                        } else {
                            console.warn("Firebase: Erreur de permission lors de l'authentification/profil, mais le jeu peut continuer.");
                        }
                    }
                    isAuthReady = true;
                    document.getElementById('profile-loading').classList.add('hidden');
                    document.getElementById('profile-content').classList.remove('hidden');
                    document.getElementById('user-id-display').textContent = 'Non connecté (Firebase désactivé)';
                    document.getElementById('profile-username').textContent = 'Invité'; // Default for anonymous
                    document.getElementById('profile-elo-classic').textContent = 'N/A'; // Update for classic
                    document.getElementById('profile-elo-blitz').textContent = 'N/A'; // Update for blitz
                    document.getElementById('profile-level').textContent = 'N/A';
                    document.getElementById('profile-games-played').textContent = 'N/A';
                    document.getElementById('profile-wins').textContent = 'N/A';
                    document.getElementById('profile-losses').textContent = 'N/A';
                    document.getElementById('profile-draws').textContent = 'N/A';
                    document.getElementById('playOnlineButton').disabled = true;
                    document.getElementById('playOnlineButton').textContent = 'Jouer en Ligne (Hors ligne)';
                    document.getElementById('showFriendsButton').disabled = true; // Disable friends button
                    document.getElementById('showFriendsButton').classList.add('opacity-50', 'cursor-not-allowed');
                    document.getElementById('notification-button').disabled = true; // Disable notification button
                    document.getElementById('notification-button').classList.add('opacity-50', 'cursor-not-allowed');
                    document.getElementById('change-username-button').disabled = true;
                    document.getElementById('change-username-button').classList.add('opacity-50', 'cursor-not-allowed');
                }
            });
        } else {
            console.warn("Firebase: La configuration Firebase est incomplète ou introuvable. Exécution sans les fonctionnalités Firebase.");
            isAuthReady = true;
            document.getElementById('profile-loading').classList.add('hidden');
            document.getElementById('profile-content').classList.remove('hidden');
            document.getElementById('user-id-display').textContent = 'Non connecté (Firebase désactivé)';
            document.getElementById('profile-elo-classic').textContent = 'N/A'; // Update for classic
            document.getElementById('profile-elo-blitz').textContent = 'N/A'; // Update for blitz
            document.getElementById('profile-level').textContent = 'N/A';
            document.getElementById('profile-games-played').textContent = 'N/A';
            document.getElementById('profile-wins').textContent = 'N/A';
            document.getElementById('profile-losses').textContent = 'N/A';
            document.getElementById('profile-draws').textContent = 'N/A';
            document.getElementById('playOnlineButton').disabled = true;
            document.getElementById('playOnlineButton').textContent = 'Jouer en Ligne (Hors ligne)';
            document.getElementById('showFriendsButton').disabled = true;
            document.getElementById('showFriendsButton').classList.add('opacity-50', 'cursor-not-allowed');
            document.getElementById('notification-button').disabled = true;
            document.getElementById('notification-button').classList.add('opacity-50', 'cursor-not-allowed');
            document.getElementById('change-username-button').disabled = true;
            document.getElementById('change-username-button').classList.add('opacity-50', 'cursor-not-allowed');
        }

        // --- Message Box Elements ---
        const messageBoxOverlay = document.getElementById('message-box-overlay');
        const messageBox = document.getElementById('message-box');
        const messageBoxText = document.getElementById('message-box-text');
        const messageBoxCloseButton = document.getElementById('message-box-close');

        messageBoxCloseButton.addEventListener('click', () => {
            messageBox.classList.add('hidden');
            messageBoxOverlay.classList.add('hidden');
        });

        function showMessage(message, callback = null) {
            messageBoxText.textContent = message;
            messageBox.classList.remove('hidden');
            messageBoxOverlay.classList.remove('hidden');
            if (callback) {
                messageBoxCloseButton.onclick = () => {
                    messageBox.classList.add('hidden');
                    messageBoxOverlay.classList.add('hidden');
                    callback();
                    messageBoxCloseButton.onclick = null;
                };
            } else {
                messageBoxCloseButton.onclick = () => {
                    messageBox.classList.add('hidden');
                    messageBoxOverlay.classList.add('hidden');
                    messageBoxCloseButton.onclick = null;
                };
            }
        }

        // --- User Profile Functions ---
        const defaultUserProfile = {
            eloClassic: 0, // Elo for classic games, starts at 0
            levelClassic: 0,
            gamesPlayedClassic: 0,
            winsClassic: 0,
            lossesClassic: 0,
            drawsClassic: 0,
            eloBlitz: 0, // Elo for blitz games, starts at 0
            levelBlitz: 0,
            gamesPlayedBlitz: 0,
            winsBlitz: 0,
            lossesBlitz: 0,
            drawsBlitz: 0, // Should typically be 0 for blitz, but kept for data consistency
            username: 'Joueur' + Math.floor(Math.random() * 10000), // Default username
            lastUsernameChange: null, // No previous change
            lastOnline: serverTimestamp(), // New field for presence
            isInGame: false // NEW: Field to track if user is currently in a game
        };
        const MAX_LEVEL = 50;

        async function fetchUserProfile(userIdToFetch) {
            if (!db || !userIdToFetch) {
                console.error("Firebase: Firestore ou userId non disponible pour le profil.");
                return { ...defaultUserProfile };
            }

            // Ensure the base 'artifacts/{appId}' document exists
            const appIdDocRef = doc(db, 'artifacts', appId);
            try {
                await setDoc(appIdDocRef, { initialized: true }, { merge: true });
                console.log(`Firebase: Document artifacts/${appId} assuré.`);
            } catch (error) {
                console.error(`Firebase: Erreur lors de l'assurance du document artifacts/${appId}:`, error);
                // Continue execution, but log the error
            }

            const userProfileRef = doc(db, `artifacts/${appId}/users/${userIdToFetch}/profile`, 'data');
            const userDocRef = doc(db, `artifacts/${appId}/users`, userIdToFetch); // Référence au document parent de l'utilisateur

            try {
                // Ensure the parent user document exists and update its lastActive timestamp
                // This is important for security rules that might rely on the existence of the user document
                await setDoc(userDocRef, { lastActive: serverTimestamp() }, { merge: true });
                console.log(`Firebase: Document parent utilisateur pour ${userIdToFetch} assuré.`);

                const docSnap = await getDoc(userProfileRef);
                let profileData = {};

                if (docSnap.exists()) {
                    profileData = docSnap.data();
                    // Ensure all default fields are present if profile was created before they existed
                    for (const key in defaultUserProfile) {
                        if (profileData[key] === undefined) {
                            profileData[key] = defaultUserProfile[key];
                        }
                    }
                    // Handle old Elo field if it exists and migrate to eloClassic if needed
                    if (profileData.elo !== undefined && profileData.eloClassic === undefined) {
                        profileData.eloClassic = profileData.elo;
                        delete profileData.elo; // Remove old field
                    }
                    // Handle old gamesPlayed field and migrate
                    if (profileData.gamesPlayed !== undefined && profileData.gamesPlayedClassic === undefined) {
                        profileData.gamesPlayedClassic = profileData.gamesPlayed;
                        profileData.winsClassic = profileData.wins;
                        profileData.lossesClassic = profileData.losses;
                        profileData.drawsClassic = profileData.draws;
                        delete profileData.gamesPlayed;
                        delete profileData.wins;
                        delete profileData.losses;
                        delete profileData.draws;
                    }
                    // Ensure blitz fields are initialized if missing
                    if (profileData.eloBlitz === undefined) profileData.eloBlitz = defaultUserProfile.eloBlitz;
                    if (profileData.gamesPlayedBlitz === undefined) profileData.gamesPlayedBlitz = defaultUserProfile.gamesPlayedBlitz;
                    if (profileData.winsBlitz === undefined) profileData.winsBlitz = defaultUserProfile.winsBlitz;
                    if (profileData.lossesBlitz === undefined) profileData.lossesBlitz = defaultUserProfile.lossesBlitz;
                    if (profileData.drawsBlitz === undefined) profileData.drawsBlitz = defaultUserProfile.drawsBlitz;


                    console.log("Firebase: Profil utilisateur récupéré :", profileData);
                } else {
                    console.log("Firebase: Pas de profil utilisateur trouvé, création par défaut.");
                    profileData = { ...defaultUserProfile };
                    await setDoc(userProfileRef, profileData); // Use setDoc for initial creation
                    console.log("Firebase: Profil par défaut créé.");
                }
                return profileData;
            } catch (error) {
                console.error("Firebase: Erreur lors de la récupération ou la création du profil utilisateur :", error);
                if (error.code !== 'permission-denied') {
                    showMessage("Erreur lors du chargement du profil: " + error.message);
                } else {
                    console.warn("Firebase: Erreur de permission lors de la récupération/création du profil, mais le jeu peut continuer.");
                }
                return { ...defaultUserProfile };
            }
        }

        // Modified updateUserProfileStats to handle game modes
        async function updateUserProfileStats(userId, gameResult, gameMode, opponentElo = null) {
            if (!db || !userId || !isAuthReady) {
                console.error("Firebase: Firestore, userId, ou auth non prêt pour la mise à jour.");
                return;
            }
            const userProfileRef = doc(db, `artifacts/${appId}/users/${userId}/profile`, 'data');

            try {
                const docSnap = await getDoc(userProfileRef);
                let currentProfile = docSnap.exists() ? docSnap.data() : { ...defaultUserProfile };

                let eloField = `elo${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)}`; // e.g., 'eloClassic' or 'eloBlitz'
                let gamesPlayedField = `gamesPlayed${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)}`;
                let winsField = `wins${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)}`;
                let lossesField = `losses${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)}`;
                let drawsField = `draws${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)}`;

                currentProfile[gamesPlayedField] = (currentProfile[gamesPlayedField] || 0) + 1;

                let eloChange = 0;
                let currentElo = currentProfile[eloField] || 0;

                if (gameResult === 'win') {
                    currentProfile[winsField] = (currentProfile[winsField] || 0) + 1;
                    if (opponentElo !== null) {
                        if (currentElo >= opponentElo) {
                            eloChange = 8;
                        } else {
                            eloChange = 15;
                        }
                    } else {
                        eloChange = 10;
                    }
                } else if (gameResult === 'loss') {
                    currentProfile[lossesField] = (currentProfile[lossesField] || 0) + 1;
                    if (opponentElo !== null) {
                        if (currentElo >= opponentElo) {
                            eloChange = -15;
                        } else {
                            eloChange = -8;
                        }
                    } else {
                        eloChange = -5;
                    }
                } else if (gameResult === 'draw') {
                    // Only count draws for classic mode
                    if (gameMode === 'classic') {
                        currentProfile[drawsField] = (currentProfile[drawsField] || 0) + 1;
                        eloChange = 1;
                    } else {
                        // For blitz, draws are typically not possible if time runs out,
                        // but if the board is full and no winner, it's still a draw.
                        // However, per user request, no draws for blitz stats.
                        eloChange = 0; // No Elo change for blitz draws
                    }
                }

                currentProfile[eloField] = Math.max(0, currentElo + eloChange);
                // Level is still based on classic Elo for now, or could be a separate level for each mode
                currentProfile.level = Math.min(MAX_LEVEL, Math.floor((currentProfile.eloClassic || 0) / 25));


                await setDoc(userProfileRef, currentProfile);
                console.log("Firebase: User profile updated successfully.", currentProfile);
                if (userId === currentUserId) {
                    userProfileData = currentProfile; // Update global user profile data
                    displayUserProfile(userId, currentProfile); // Update UI immediately
                }
            } catch (error) {
                console.error("Firebase: Erreur lors de la mise à jour du profil utilisateur :", error);
                showMessage("Erreur lors de la mise à jour du profil: " + error.message);
            }
        }

        // --- Presence / Last Online ---
        async function setupPresenceListener() {
            if (!db || !currentUserId) return;

            const userProfileRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data');

            // Update lastOnline timestamp every minute
            setInterval(async () => {
                if (currentUserId) { // Ensure user is still signed in
                    try {
                        await updateDoc(userProfileRef, { lastOnline: serverTimestamp() });
                    } catch (e) {
                        console.error("Erreur lors de la mise à jour de lastOnline:", e);
                    }
                }
            }, 60 * 1000); // Every 60 seconds (1 minute)

            // Update lastOnline when user closes/leaves the page (best effort)
            window.addEventListener('beforeunload', async () => {
                if (currentUserId) {
                    try {
                        await updateDoc(userProfileRef, { lastOnline: serverTimestamp() });
                    } catch (e) {
                        console.error("Erreur lors de la mise à jour de lastOnline à la fermeture:", e);
                    }
                }
            });
        }

        // Modified displayUserProfile to show both Elos and handle stats toggle
        function displayUserProfile(userId, profile) {
            document.getElementById('user-id-display').textContent = userId;
            profileUsername.textContent = profile.username;
            document.getElementById('profile-elo-classic').textContent = profile.eloClassic || 0; // Display classic Elo
            document.getElementById('profile-elo-blitz').textContent = profile.eloBlitz || 0; // Display blitz Elo
            document.getElementById('profile-level').textContent = `${profile.level || 0}/${MAX_LEVEL}`; // Level based on classic Elo

            // Update displayed stats based on currentStatsDisplayMode
            updateDisplayedStats(currentStatsDisplayMode);

            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            // Check if lastUsernameChange exists and is a Firestore Timestamp
            if (profile.lastUsernameChange && profile.lastUsernameChange instanceof Object && 'toDate' in profile.lastUsernameChange) {
                const lastChangeDate = profile.lastUsernameChange.toDate();
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;

                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    usernameCooldownMessage.textContent = `Prochain changement dans ${days} jour${days > 1 ? 's' : ''}.`;
                    usernameCooldownMessage.classList.remove('hidden');
                    changeUsernameButton.disabled = true;
                    changeUsernameButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    usernameCooldownMessage.classList.add('hidden');
                    changeUsernameButton.disabled = false;
                    changeUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            } else {
                // If lastUsernameChange is null or not a valid timestamp, allow change
                usernameCooldownMessage.classList.add('hidden');
                changeUsernameButton.disabled = false;
                changeUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        // Function to update displayed stats based on mode
        function updateDisplayedStats(mode) {
            if (!userProfileData) return;

            let gamesPlayed = 0;
            let wins = 0;
            let losses = 0;
            let draws = 0;

            if (mode === 'classic') {
                gamesPlayed = userProfileData.gamesPlayedClassic || 0;
                wins = userProfileData.winsClassic || 0;
                losses = userProfileData.lossesClassic || 0;
                draws = userProfileData.drawsClassic || 0;
                document.getElementById('profile-draws-row').classList.remove('hidden'); // Show draws for classic
            } else if (mode === 'blitz') {
                gamesPlayed = userProfileData.gamesPlayedBlitz || 0;
                wins = userProfileData.winsBlitz || 0;
                losses = userProfileData.lossesBlitz || 0;
                draws = userProfileData.drawsBlitz || 0; // Will be 0 per requirement
                document.getElementById('profile-draws-row').classList.add('hidden'); // Hide draws for blitz
            }

            document.getElementById('profile-games-played').textContent = gamesPlayed;
            document.getElementById('profile-wins').textContent = wins;
            document.getElementById('profile-losses').textContent = losses;
            document.getElementById('profile-draws').textContent = draws;

            // Update toggle button active state
            document.getElementById('stats-toggle-classic').classList.remove('active');
            document.getElementById('stats-toggle-blitz').classList.remove('active');
            document.getElementById(`stats-toggle-${mode}`).classList.add('active');
        }


        // --- Username Change Functions ---
        const profileUsername = document.getElementById('profile-username');
        const changeUsernameButton = document.getElementById('change-username-button');
        const usernameEditSection = document.getElementById('username-edit-section');
        const newUsernameInput = document.getElementById('new-username-input');
        const saveUsernameButton = document.getElementById('save-username-button');
        const cancelUsernameButton = document.getElementById('cancel-username-button');
        const usernameCooldownMessage = document.getElementById('username-cooldown-message');

        function showUsernameEditForm() {
            changeUsernameButton.classList.add('hidden');
            usernameEditSection.classList.remove('hidden');
            newUsernameInput.value = profileUsername.textContent;

            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            if (userProfileData && userProfileData.lastUsernameChange && userProfileData.lastUsernameChange instanceof Object && 'toDate' in userProfileData.lastUsernameChange) {
                const lastChangeDate = userProfileData.lastUsernameChange.toDate();
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;
                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    usernameCooldownMessage.textContent = `Vous devez attendre ${days} jour${days > 1 ? 's' : ''} avant de changer de pseudo.`;
                    usernameCooldownMessage.classList.remove('hidden');
                    newUsernameInput.disabled = true;
                    saveUsernameButton.disabled = true;
                    saveUsernameButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    usernameCooldownMessage.classList.add('hidden');
                    newUsernameInput.disabled = false;
                    saveUsernameButton.disabled = false;
                    saveUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            } else {
                usernameCooldownMessage.classList.add('hidden');
                newUsernameInput.disabled = false;
                saveUsernameButton.disabled = false;
                saveUsernameButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        async function handleSaveUsername() {
            const newUsername = newUsernameInput.value.trim();

            if (!newUsername || newUsername.length < 3 || newUsername.length > 20) {
                showMessage("Le pseudo doit contenir entre 3 et 20 caractères.");
                return;
            }

            if (newUsername === profileUsername.textContent) {
                showMessage("Le nouveau pseudo est identique au pseudo actuel.");
                usernameEditSection.classList.add('hidden');
                changeUsernameButton.classList.remove('hidden');
                return;
            }

            await updateUsername(newUsername);
        }

        function cancelUsernameEdit() {
            usernameEditSection.classList.add('hidden');
            changeUsernameButton.classList.remove('hidden');
            displayUserProfile(currentUserId, userProfileData); // Re-display current profile data
        }

        async function updateUsername(newUsername) {
            if (!db || !currentUserId || !isAuthReady) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }

            const userProfileRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data');

            const docSnap = await getDoc(userProfileRef);
            let currentProfile = docSnap.exists() ? docSnap.data() : { ...defaultUserProfile };

            const fifteenDaysInMs = 15 * 24 * 60 * 60 * 1000;
            const now = Date.now();

            if (currentProfile.lastUsernameChange && currentProfile.lastUsernameChange instanceof Object && 'toDate' in currentProfile.lastUsernameChange) {
                const lastChangeDate = currentProfile.lastUsernameChange.toDate();
                const nextChangeAllowed = lastChangeDate.getTime() + fifteenDaysInMs;
                if (now < nextChangeAllowed) {
                    const remainingMs = nextChangeAllowed - now;
                    const days = Math.ceil(remainingMs / (1000 * 60 * 60 * 24));
                    showMessage(`Vous devez attendre ${days} jour${days > 1 ? 's' : ''} avant de changer de pseudo.`);
                    return;
                }
            }

            try {
                await updateDoc(userProfileRef, {
                    username: newUsername,
                    lastUsernameChange: serverTimestamp() // Set timestamp for cooldown
                });
                showMessage("Pseudo mis à jour avec succès !");
                userProfileData = await fetchUserProfile(currentUserId); // Re-fetch to update local cache
                displayUserProfile(currentUserId, userProfileData); // Update UI
            } catch (error) {
                console.error("Erreur lors de la mise à jour du pseudo:", error);
                showMessage("Erreur lors de la mise à jour du pseudo: " + error.message);
            } finally {
                usernameEditSection.classList.add('hidden');
                changeUsernameButton.classList.remove('hidden');
            }
        }


        // --- Éléments du DOM et variables d'état pour l'application globale ---
        const homeScreen = document.getElementById('home-screen');
        const localGameScreen = document.getElementById('local-game-screen');
        const aiGameScreen = document.getElementById('ai-game-screen');
        const onlinePlaySelectionScreen = document.getElementById('online-play-selection-screen'); // NEW
        const onlineSearchingScreen = document.getElementById('online-searching-screen');
        const onlineGameScreen = document.getElementById('online-game-screen');
        const gameEndOverlay = document.getElementById('game-end-overlay');
        const gameEndBanner = document.getElementById('game-end-banner');
        const gameEndTitle = document.getElementById('game-end-title');
        const gameEndMessage = document.getElementById('game-end-message');
        const gameEndReplayButton = document.getElementById('game-end-replay-button');
        const gameEndHomeButton = document.getElementById('game-end-home-button');
        const leaderboardScreen = document.getElementById('leaderboard-screen');
        const leaderboardList = document.getElementById('leaderboard-list');
        const historyScreen = document.getElementById('history-screen');
        const gamesHistoryList = document.getElementById('games-history-list');
        const historyDetailScreen = document.getElementById('history-detail-screen');
        const detailGameInfo = document.getElementById('detail-game-info');
        const detailBoardElement = document.getElementById('detail-board');
        const prevMoveButton = document.getElementById('prev-move-button');
        const nextMoveButton = document.getElementById('next-move-button');
        const moveCounter = document.getElementById('move-counter');
        const detailBackButton = document.getElementById('detail-back-button');

        // Éléments du DOM pour le système d'amis
        const showFriendsButton = document.getElementById('showFriendsButton');
        const friendsScreen = document.getElementById('friends-screen');
        const friendsBackToHomeButton = document.getElementById('friends-back-to-home-button');
        const userSearchInput = document.getElementById('user-search-input');
        const userSearchButton = document.getElementById('user-search-button');
        const userSearchResults = document.getElementById('user-search-results');
        const friendsListElement = document.getElementById('friends-list');
        // NEW: Share App Button
        const shareAppButton = document.getElementById('share-app-button');


        const userProfileModalOverlay = document.getElementById('user-profile-modal-overlay');
        const userProfileModalCloseButton = document.getElementById('user-profile-modal-close');
        const modalProfileUsername = document.getElementById('modal-profile-username');
        const modalProfileId = document.getElementById('modal-profile-id');
        const modalProfileLastOnline = document.getElementById('modal-profile-last-online');
        const modalProfileEloClassic = document.getElementById('modal-profile-elo-classic'); // NEW
        const modalProfileEloBlitz = document.getElementById('modal-profile-elo-blitz');   // NEW
        const modalProfileLevel = document.getElementById('modal-profile-level');
        const modalProfileGamesPlayed = document.getElementById('modal-profile-games-played');
        const modalProfileWins = document.getElementById('modal-profile-wins');
        const modalProfileLosses = document.getElementById('modal-profile-losses');
        const modalProfileDraws = document.getElementById('modal-profile-draws');

        const sendFriendRequestButton = document.getElementById('send-friend-request-button');
        const cancelFriendRequestButton = document.getElementById('cancel-friend-request-button');
        const acceptFriendRequestButton = document.getElementById('accept-friend-request-button');
        const declineFriendRequestButton = document.getElementById('decline-friend-request-button');
        const unfriendButton = document.getElementById('unfriend-button');
        const blockUserButton = document.getElementById('block-user-button');
        const unblockUserButton = document.getElementById('unblock-user-button');
        const proposeGameButton = document.getElementById('propose-game-button');

        const notificationButton = document.getElementById('notification-button');
        const notificationCount = document.getElementById('notification-count');
        const notificationModalOverlay = document.getElementById('notification-modal-overlay');
        const notificationModalCloseButton = document.getElementById('notification-modal-close');
        const notificationList = document.getElementById('notification-list');

        // NEW: Game Invite Modal Elements
        const gameInviteModalOverlay = document.getElementById('game-invite-modal-overlay');
        const gameInviteModalCloseButton = document.getElementById('game-invite-modal-close');
        const gameInviteTitle = document.getElementById('game-invite-title');
        const gameInviteMessage = document.getElementById('game-invite-message');
        const acceptGameInviteButton = document.getElementById('accept-game-invite-button');
        const declineGameInviteButton = document.getElementById('decline-game-invite-button');
        const gameInviteStatusMessage = document.getElementById('game-invite-status-message');

        // NEW: Online Play Selection Buttons
        const selectClassicOnlineButton = document.getElementById('select-classic-online-button');
        const selectBlitzOnlineButton = document.getElementById('select-blitz-online-button');
        const onlineSelectionBackToHomeButton = document.getElementById('online-selection-back-to-home-button');

        // NEW: Timer elements
        const playerTimeDisplay = document.getElementById('player-time-display');
        const opponentTimeDisplay = document.getElementById('opponent-time-display');


        const playOnlineButton = document.getElementById('playOnlineButton');
        const playLocalButton = document.getElementById('playLocalButton');
        const playAIButton = document.getElementById('playAIButton');
        const showHistoryButton = document.getElementById('showHistoryButton');
        const showLeaderboardButton = document.getElementById('showLeaderboardButton');
        const leaderboardBackToHomeButton = document.getElementById('leaderboard-back-to-home-button');
        const historyBackButton = document.getElementById('history-back-button');

        // Toggle buttons for stats and leaderboard
        const statsToggleClassic = document.getElementById('stats-toggle-classic');
        const statsToggleBlitz = document.getElementById('stats-toggle-blitz');
        const leaderboardToggleClassic = document.getElementById('leaderboard-toggle-classic');
        const leaderboardToggleBlitz = document.getElementById('leaderboard-toggle-blitz');


        // --- Variables et éléments du DOM pour le jeu local ---
        const localStatusDisplay = document.getElementById('local-game-status');
        const localBoardElement = document.getElementById('local-board');
        const localResetButton = document.getElementById('local-reset-button');
        const localBackToHomeButton = document.getElementById('local-back-to-home-button');

        let localBoard = Array(25).fill('');
        let localCurrentPlayer = 'X';
        let localGameActive = true;
        let localMovesHistory = [];
        let localCells; // Déclaré ici, initialisé dans createCells

        // --- Variables et éléments du DOM pour le jeu IA ---
        const aiStatusDisplay = document.getElementById('ai-game-status');
        const aiBoardElement = document.getElementById('ai-board');
        const aiResetButton = document.getElementById('ai-reset-button');
        const aiBackToHomeButton = document.getElementById('ai-back-to-home-button');
        const easyButton = document.getElementById('easy-button');
        const mediumButton = document.getElementById('medium-button');
        const hardButton = document.getElementById('hard-button');
        const difficultyButtons = [easyButton, mediumButton, hardButton];

        let aiBoard = Array(25).fill('');
        let humanPlayer = 'X';
        let aiPlayer = 'O';
        let aiCurrentPlayer = humanPlayer;
        let aiGameActive = false;
        let aiDifficulty = null;
        const MINIMAX_MAX_DEPTH = 4;
        let aiCells; // Déclaré ici, initialisé dans createCells
        let aiMovesHistory = [];

        // --- Constantes de jeu communes ---
        const BOARD_SIZE = 5;
        const WIN_LENGTH = 4;

        const generateWinningCombinations = () => {
            const combinations = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col <= BOARD_SIZE - WIN_LENGTH; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i));
                }
            }
            for (let col = 0; col < BOARD_SIZE; col++) {
                for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * BOARD_SIZE));
                }
            }
            for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                for (let col = 0; col <= BOARD_SIZE - WIN_LENGTH; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * (BOARD_SIZE + 1)));
                }
            }
            for (let row = 0; row <= BOARD_SIZE - WIN_LENGTH; row++) {
                for (let col = WIN_LENGTH - 1; col < BOARD_SIZE; col++) {
                    const start = row * BOARD_SIZE + col;
                    combinations.push(Array.from({ length: WIN_LENGTH }, (_, i) => start + i * (BOARD_SIZE - 1)));
                }
            }
            return combinations;
        };
        const winningCombinations = generateWinningCombinations();

        const updateStatus = (message, gameType) => {
            if (gameType === 'local') {
                localStatusDisplay.innerHTML = message;
            } else if (gameType === 'ai') {
                aiStatusDisplay.innerHTML = message;
            } else if (gameType === 'online') {
                document.getElementById('online-game-status').innerHTML = message;
            }
        };

        const createCells = (boardElementId, clickHandler) => {
            const currentBoardElement = document.getElementById(boardElementId);
            currentBoardElement.innerHTML = '';
            for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                if (clickHandler) { // Only add if a handler is provided
                    cell.addEventListener('click', clickHandler);
                }
                currentBoardElement.appendChild(cell);
            }
            // Initialiser les tableaux de cellules après la création des éléments DOM
            if (boardElementId === 'local-board') {
                localCells = Array.from(document.querySelectorAll('#local-board .cell'));
            } else if (boardElementId === 'ai-board') {
                aiCells = Array.from(document.querySelectorAll('#ai-board .cell'));
            } else if (boardElementId === 'online-board') {
                onlineCells = Array.from(document.querySelectorAll('#online-board .cell'));
            } else if (boardElementId === 'detail-board') {
                // No specific cells array for detail board, it's temporary
            }
        };

        const checkForWin = (player, currentBoard) => {
            for (let i = 0; i < winningCombinations.length; i++) {
                const combination = winningCombinations[i];
                let allMatch = true;
                for (let j = 0; j < WIN_LENGTH; j++) {
                    if (currentBoard[combination[j]] !== player) {
                        allMatch = false;
                        break;
                    }
                }
                if (allMatch) {
                    return true;
                }
            }
            return false;
        };

        const checkForDraw = (currentBoard) => {
            return !currentBoard.includes('');
        };

        // --- Fonctions communes pour les écrans de fin de partie ---
        let currentEndGameType = '';
        let currentOpponentName = '';
        const playerXMarker = 'X';

        function showGameEndScreen(status, winner, gameType, finalBoardState, movesHistory, gameMode = 'classic') {
            localGameScreen.classList.add('hidden');
            aiGameScreen.classList.add('hidden');
            onlineGameScreen.classList.add('hidden');
            onlineSearchingScreen.classList.add('hidden');
            onlinePlaySelectionScreen.classList.add('hidden'); // Ensure this is hidden too

            gameEndOverlay.classList.remove('hidden');
            gameEndBanner.classList.remove('hidden');

            gameEndTitle.textContent = '';
            gameEndMessage.textContent = '';
            currentEndGameType = gameType; // Store gameType (local, ai, online)
            currentOnlineGameMode = gameMode; // Store gameMode (classic, blitz) for online games

            let title = '';
            let message = '';
            let historyStatus = '';

            if (gameType === 'local') {
                if (status === 'win') {
                    title = 'PARTIE TERMINÉE !';
                    message = `Le joueur ${winner} a gagné !`;
                    historyStatus = (winner === playerXMarker) ? 'won' : 'lost';
                } else {
                    title = 'MATCH NUL !';
                    message = 'Aucun vainqueur.';
                    historyStatus = 'draw';
                }
                currentOpponentName = 'Joueur Local';
            } else if (gameType === 'ai') {
                if (status === 'win') {
                    title = 'VICTOIRE !';
                    message = `Vous avez gagné !`;
                    historyStatus = 'won';
                } else if (status === 'loss') {
                    title = 'DÉFAITE !';
                    message = `L'IA a gagné.`;
                    historyStatus = 'lost';
                } else {
                    title = 'MATCH NUL !';
                    message = 'Aucun vainqueur.';
                    historyStatus = 'draw';
                }
                currentOpponentName = `IA ${aiDifficulty === 'easy' ? 'Facile' : (aiDifficulty === 'medium' ? 'Moyenne' : 'Difficile')}`;
            } else if (gameType === 'online') {
                if (status === 'win') {
                    title = 'VICTOIRE !';
                    message = `Vous avez gagné !`;
                    historyStatus = 'won';
                } else if (status === 'loss') {
                    title = 'DÉFAITE !';
                    message = `${onlineOpponentProfile ? onlineOpponentProfile.username : 'Votre adversaire'} a gagné.`;
                    historyStatus = 'lost';
                } else if (status === 'timeout') { // Specific status for timeout loss
                    title = 'DÉFAITE PAR TEMPS !';
                    message = `Vous avez dépassé le temps. ${onlineOpponentProfile ? onlineOpponentProfile.username : 'Votre adversaire'} a gagné.`;
                    historyStatus = 'lost'; // Timeout is still a loss for stats
                }
                else { // Default draw for online
                    title = 'MATCH NUL !';
                    message = 'Aucun vainqueur.';
                    historyStatus = 'draw';
                }
                currentOpponentName = onlineOpponentProfile ? onlineOpponentProfile.username : 'Joueur en ligne';
            }

            gameEndTitle.textContent = title;
            gameEndMessage.textContent = message;

            // Update user stats for online games and hard AI games
            if (isAuthReady && currentUserId) {
                if (gameType === 'ai' && aiDifficulty === 'hard') {
                    updateUserProfileStats(currentUserId, status, 'classic'); // AI hard is classic mode
                } else if (gameType === 'online') {
                    // Pass the actual gameMode to updateUserProfileStats
                    updateUserProfileStats(currentUserId, status, currentOnlineGameMode, onlineOpponentProfile ? (currentOnlineGameMode === 'classic' ? onlineOpponentProfile.eloClassic : onlineOpponentProfile.eloBlitz) : null);
                }
            }

            saveGameToHistory(gameType, historyStatus, currentOpponentName, finalBoardState, movesHistory, BOARD_SIZE, currentOnlineGameId, currentOnlineGameMode);
        }

        // --- Fonctions spécifiques au jeu local ---
        const handleLocalCellClick = (event) => {
            const clickedCell = event.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            if (localBoard[clickedCellIndex] !== '' || !localGameActive) {
                return;
            }
            localBoard[clickedCellIndex] = localCurrentPlayer;
            localCells[clickedCellIndex].innerHTML = localCurrentPlayer;
            localCells[clickedCellIndex].classList.add(localCurrentPlayer.toLowerCase());
            localMovesHistory.push({ index: clickedCellIndex, player: localCurrentPlayer });

            const hasWon = checkForWin(localCurrentPlayer, localBoard);
            if (hasWon) {
                showGameEndScreen('win', localCurrentPlayer, 'local', [...localBoard], [...localMovesHistory]);
                localGameActive = false;
                return;
            }

            const hasDraw = checkForDraw(localBoard);
            if (hasDraw) {
                showGameEndScreen('draw', null, 'local', [...localBoard], [...localMovesHistory]);
                localGameActive = false;
                return;
            }

            localCurrentPlayer = localCurrentPlayer === 'X' ? 'O' : 'X';
            updateStatus(`Au tour de : ${localCurrentPlayer}`, 'local');
        };

        const resetLocalGame = () => {
            localBoard = Array(25).fill('');
            localCurrentPlayer = 'X';
            localGameActive = true;
            localMovesHistory = [];
            updateStatus(`Au tour de : ${localCurrentPlayer}`, 'local');
            // Assurez-vous que localCells est bien initialisé avant de l'utiliser
            if (localCells) {
                localCells.forEach(cell => {
                    cell.innerHTML = '';
                    cell.classList.remove('x', 'o');
                });
            }
            localGameScreen.classList.remove('hidden');
        };

        const leaveLocalGame = () => {
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        };

        // --- Fonctions spécifiques au jeu IA ---
        const handleAICellClick = (event) => {
            const clickedCell = event.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            if (aiBoard[clickedCellIndex] !== '' || !aiGameActive || aiCurrentPlayer !== humanPlayer) {
                return;
            }

            makeAIMoveInternal(clickedCellIndex, humanPlayer);
            aiMovesHistory.push({ index: clickedCellIndex, player: humanPlayer });
            checkAIGameStatus();
        };

        const makeAIMoveInternal = (index, player) => {
            aiBoard[index] = player;
            aiCells[index].innerHTML = player;
            aiCells[index].classList.add(player.toLowerCase());
        };

        const checkAIGameStatus = async () => {
            const humanWon = checkForWin(humanPlayer, aiBoard);
            const aiWon = checkForWin(aiPlayer, aiBoard);
            const isDraw = checkForDraw(aiBoard);

            if (humanWon) {
                showGameEndScreen('win', humanPlayer, 'ai', [...aiBoard], [...aiMovesHistory]);
                aiGameActive = false;
            } else if (aiWon) {
                showGameEndScreen('loss', aiPlayer, 'ai', [...aiBoard], [...aiMovesHistory]);
                aiGameActive = false;
            } else if (isDraw) {
                showGameEndScreen('draw', null, 'ai', [...aiBoard], [...aiMovesHistory]);
                aiGameActive = false;
            } else {
                aiCurrentPlayer = aiCurrentPlayer === humanPlayer ? aiPlayer : humanPlayer;
                updateStatus(`Au tour de : ${aiCurrentPlayer}`, 'ai');
                if (aiCurrentPlayer === aiPlayer && aiGameActive) {
                    setTimeout(makeAIPlayerMove, 700);
                }
            }
        };

        const getEmptyCells = (currentBoard) => {
            return currentBoard.map((cell, index) => cell === '' ? index : null).filter(index => index !== null);
        };

        const findWinningMove = (player, currentBoard) => {
            const emptyCells = getEmptyCells(currentBoard);
            for (let i = 0; i < emptyCells.length; i++) {
                const move = emptyCells[i];
                currentBoard[move] = player;
                if (checkForWin(player, currentBoard)) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }
            return null;
        };

        const findBlockingMove = (playerToBlock, currentBoard) => {
            return findWinningMove(playerToBlock, currentBoard);
        };

        const countThreats = (player, count, currentBoard) => {
            let numThreats = 0;
            for (const combination of winningCombinations) {
                let playerCount = 0;
                let emptyCount = 0;
                for (const index of combination) {
                    if (currentBoard[index] === player) playerCount++;
                    else if (currentBoard[index] === '') emptyCount++;
                }
                if (playerCount === count && emptyCount === WIN_LENGTH - count) {
                    numThreats++;
                }
            }
            return numThreats;
        };

        const easyAI = (currentBoard) => {
            const winningMove = findWinningMove(aiPlayer, currentBoard);
            if (winningMove !== null) {
                return winningMove;
            }

            const blockingMove = findBlockingMove(humanPlayer, currentBoard);
            if (blockingMove !== null) {
                return blockingMove;
            }

            const emptyCells = getEmptyCells(currentBoard);
            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            if (emptyCells.length > 0) {
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                return emptyCells[randomIndex];
            }
            return null;
        };

        const mediumAI = (currentBoard) => {
            const winningMove = findWinningMove(aiPlayer, currentBoard);
            if (winningMove !== null) {
                return winningMove;
            }

            const blockingMove = findBlockingMove(humanPlayer, currentBoard);
            if (blockingMove !== null) {
                return blockingMove;
            }

            const emptyCells = getEmptyCells(currentBoard);
            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) >= 2) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) >= 2) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = aiPlayer;
                if (countThreats(aiPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            for (const move of emptyCells) {
                currentBoard[move] = humanPlayer;
                if (countThreats(humanPlayer, WIN_LENGTH - 1, currentBoard) > 0) {
                    currentBoard[move] = '';
                    return move;
                }
                currentBoard[move] = '';
            }

            if (currentBoard[12] === '') {
                return 12;
            }

            const corners = [0, 4, 20, 24];
            const availableCorners = corners.filter(index => currentBoard[index] === '');
            if (availableCorners.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableCorners.length);
                return availableCorners[randomIndex];
            }

            return easyAI(currentBoard);
        };

        const hardAI = (currentBoard) => {
            const emptyCells = getEmptyCells(currentBoard);
            if (emptyCells.length === 0) return null;

            let bestMove = -1;
            let bestScore = -Infinity;

            const minimax = (boardState, depth, isMaximizingPlayer) => {
                if (checkForWin(aiPlayer, boardState)) {
                    return 10000 - depth;
                }
                if (checkForWin(humanPlayer, boardState)) {
                    return -10000 + depth;
                }
                if (getEmptyCells(boardState).length === 0) {
                    return 0;
                }

                if (depth >= MINIMAX_MAX_DEPTH) {
                    return evaluateBoard(boardState);
                }

                const tempEmptyCells = getEmptyCells(boardState);

                if (isMaximizingPlayer) {
                    let maxEval = -Infinity;
                    for (const move of tempEmptyCells) {
                        boardState[move] = aiPlayer;
                        const evaluation = minimax(boardState, depth + 1, false);
                        boardState[move] = '';
                        maxEval = Math.max(maxEval, evaluation);
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of tempEmptyCells) {
                        boardState[move] = humanPlayer;
                        const evaluation = minimax(boardState, depth + 1, true);
                        boardState[move] = '';
                        minEval = Math.min(minEval, evaluation);
                    }
                    return minEval;
                }
            };

            const evaluateBoard = (boardState) => {
                let score = 0;

                for (const combination of winningCombinations) {
                    let aiCount = 0;
                    let humanCount = 0;
                    let emptyCount = 0;

                    for (const index of combination) {
                        if (boardState[index] === aiPlayer) aiCount++;
                        else if (boardState[index] === humanPlayer) humanCount++;
                        else emptyCount++;
                    }

                    if (humanCount === 0) {
                        if (aiCount === WIN_LENGTH - 1 && emptyCount >= 1) score += 1000;
                        if (aiCount === WIN_LENGTH - 2 && emptyCount >= 2) score += 100;
                        if (aiCount === WIN_LENGTH - 3 && emptyCount >= 3) score += 10;
                    }

                    if (aiCount === 0) {
                        if (humanCount === WIN_LENGTH - 1 && emptyCount >= 1) score -= 900;
                        if (humanCount === WIN_LENGTH - 2 && emptyCount >= 2) score -= 90;
                        if (humanCount === WIN_LENGTH - 3 && emptyCount >= 3) score -= 9;
                    }
                }
                return score;
            };

            for (const move of emptyCells) {
                aiBoard[move] = aiPlayer;
                const score = minimax(aiBoard, 0, false);
                aiBoard[move] = '';

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            if (bestMove === -1 || (emptyCells.length === BOARD_SIZE * BOARD_SIZE && bestScore <= 0)) {
                if (aiBoard[12] === '') {
                    return 12;
                }
                const corners = [0, 4, 20, 24];
                const availableCorners = corners.filter(index => aiBoard[index] === '');
                if (availableCorners.length > 0) {
                    const randomIndex = Math.floor(Math.random() * availableCorners.length);
                    return availableCorners[randomIndex];
                }
                return easyAI(aiBoard);
            }

            return bestMove;
        };

        const makeAIPlayerMove = () => {
            if (!aiGameActive) return;

            let move = null;
            if (aiDifficulty === 'easy') {
                move = easyAI(aiBoard);
            } else if (aiDifficulty === 'medium') {
                move = mediumAI(aiBoard);
            } else if (aiDifficulty === 'hard') {
                move = hardAI(aiBoard);
            }

            if (move !== null) {
                makeAIMoveInternal(move, aiPlayer);
                aiMovesHistory.push({ index: move, player: aiPlayer });
                checkAIGameStatus();
            }
        };

        const resetAIGame = () => {
            aiBoard = Array(25).fill('');
            aiCurrentPlayer = humanPlayer;
            aiGameActive = true;
            aiMovesHistory = [];
            updateStatus(`Au tour de : ${aiCurrentPlayer}`, 'ai');
            // Assurez-vous que aiCells est bien initialisé avant de l'utiliser
            if (aiCells) {
                aiCells.forEach(cell => {
                    cell.innerHTML = '';
                    cell.classList.remove('x', 'o');
                });
            }
            aiGameScreen.classList.remove('hidden');
            if (aiDifficulty) {
                document.getElementById(`${aiDifficulty}-button`).classList.add('selected-difficulty');
            }
        };

        const leaveAIGame = () => {
            aiDifficulty = null;
            difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        };

        const handleDifficultySelection = (difficulty) => {
            aiDifficulty = difficulty;
            difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
            document.getElementById(`${difficulty}-button`).classList.add('selected-difficulty');
            resetAIGame();
        };

        // --- Online Game Logic ---

        let matchmakingListenerUnsubscribe = null;

        // Modified findOnlineMatch to accept gameMode
        async function findOnlineMatch(gameMode) {
            if (!db || !currentUserId || !isAuthReady) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }

            // Set user's isInGame status to true when starting to search for a game
            await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: true });

            hideAllScreens();
            onlineSearchingScreen.classList.remove('hidden');

            const queueCollectionRef = collection(db, 'matchmaking_queue');

            try {
                // Query for an opponent in the same game mode
                const q = query(queueCollectionRef, where("gameMode", "==", gameMode));
                const querySnapshot = await getDocs(q);

                let foundOpponentId = null;
                let foundOpponentDocRef = null;

                for (const docSnapshot of querySnapshot.docs) {
                    if (docSnapshot.id !== currentUserId) {
                        const queueEntry = docSnapshot.data();
                        if (queueEntry.status === 'searching' && queueEntry.gameId === null && queueEntry.opponentId === null) {
                            foundOpponentId = docSnapshot.id;
                            foundOpponentDocRef = doc(db, 'matchmaking_queue', foundOpponentId);
                            break;
                        }
                    }
                }

                if (foundOpponentId) {
                    console.log("Matchmaking: Opponent found:", foundOpponentId);
                    const gameRef = doc(collection(db, 'games'));
                    const gameId = gameRef.id;

                    await setDoc(gameRef, {
                        playerXId: foundOpponentId,
                        playerOId: currentUserId,
                        board: Array(25).fill(''),
                        currentPlayer: 'X',
                        status: 'active',
                        winner: null,
                        createdAt: serverTimestamp(),
                        lastMoveTime: serverTimestamp(),
                        moves: [],
                        gameMode: gameMode, // Store game mode
                        playerXTime: BLITZ_TIME_LIMIT_MS, // Initial time for X
                        playerOTime: BLITZ_TIME_LIMIT_MS  // Initial time for O
                    });

                    await updateDoc(foundOpponentDocRef, {
                        status: 'matched',
                        gameId: gameId,
                        opponentId: currentUserId
                    });

                    await deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {});

                    // Update opponent's isInGame status
                    await updateDoc(doc(db, `artifacts/${appId}/users/${foundOpponentId}/profile`, 'data'), { isInGame: true });

                    console.log(`Matchmaking: Game ${gameId} created. Player X: ${foundOpponentId}, Player O: ${currentUserId}`);
                    startGameOnline(gameId, 'O', foundOpponentId, gameMode);

                } else {
                    console.log("Matchmaking: No opponent found, entering queue.");
                    await setDoc(doc(queueCollectionRef, currentUserId), {
                        timestamp: serverTimestamp(),
                        status: 'searching',
                        opponentId: null,
                        gameId: null,
                        gameMode: gameMode // Store game mode in queue
                    });
                    console.log(`Matchmaking: User ${currentUserId} added to queue for ${gameMode} mode.`);

                    matchmakingListenerUnsubscribe = onSnapshot(doc(queueCollectionRef, currentUserId), async (docSnap) => { // Made async
                        if (docSnap.exists() && docSnap.data().gameId) {
                            const data = docSnap.data();
                            console.log("Matchmaking: Our queue entry updated. Game found:", data.gameId, "Opponent:", data.opponentId);
                            if (matchmakingListenerUnsubscribe) {
                                matchmakingListenerUnsubscribe();
                                matchmakingListenerUnsubscribe = null;
                            }
                            // Update opponent's isInGame status
                            if (data.opponentId) {
                                await updateDoc(doc(db, `artifacts/${appId}/users/${data.opponentId}/profile`, 'data'), { isInGame: true });
                            }
                            startGameOnline(data.gameId, 'X', data.opponentId, data.gameMode); // Pass gameMode
                            deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {});
                        } else if (!docSnap.exists()) {
                            console.warn("Matchmaking: Notre entrée dans la file a été retirée. Si la partie ne démarre pas, il y a un problème.");
                            if (!currentOnlineGameId) {
                                showMessage("La recherche de partie a été annulée ou a échoué. Veuillez réessayer.", async () => { // Made async
                                    hideAllScreens();
                                    homeScreen.classList.remove('hidden');
                                    if (isAuthReady && currentUserId) {
                                        await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false }); // Set isInGame to false
                                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                                    }
                                });
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("Matchmaking error:", error);
                showMessage("Erreur lors de la recherche de partie: " + error.message, async () => { // Made async
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false }); // Set isInGame to false
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
                if (currentUserId) {
                    await deleteDoc(doc(queueCollectionRef, currentUserId)).catch(() => {}); // Ensure queue entry is cleaned
                    await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false }); // Set isInGame to false
                }
            }
        }

        async function cancelOnlineSearch() {
            if (matchmakingListenerUnsubscribe) {
                matchmakingListenerUnsubscribe();
                matchmakingListenerUnsubscribe = null;
            }
            if (currentUserId) {
                await deleteDoc(doc(db, 'matchmaking_queue', currentUserId)).catch(e => console.error("Error deleting queue entry:", e));
                await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false }); // Set isInGame to false
            }
            hideAllScreens();
            homeScreen.classList.remove('hidden');
            showMessage("Recherche de partie annulée.");
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        }

        // Modified startGameOnline to accept gameMode and handle timers
        async function startGameOnline(gameId, playerRole, opponentId, gameMode) {
            console.log(`Starting online game: ${gameId} as player ${playerRole} against ${opponentId} in ${gameMode} mode.`);
            currentOnlineGameId = gameId;
            currentOnlinePlayerRole = playerRole;
            onlineOpponentUserId = opponentId;
            onlineGameActive = true;
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';
            currentOnlineGameMode = gameMode; // Store the actual game mode

            // Initialize times based on game mode
            if (gameMode === 'blitz') {
                playerXTime = BLITZ_TIME_LIMIT_MS;
                playerOTime = BLITZ_TIME_LIMIT_MS;
                // Ensure timers are visible for blitz
                playerTimeDisplay.classList.remove('hidden');
                opponentTimeDisplay.classList.remove('hidden');
            } else { // Classic mode
                playerXTime = -1; // Indicate no timer for classic
                playerOTime = -1;
                // Hide timers completely for classic
                playerTimeDisplay.classList.add('hidden');
                opponentTimeDisplay.classList.add('hidden');
                if (timerInterval) clearInterval(timerInterval); // Ensure timer is stopped
                timerInterval = null;
            }
            updateTimerDisplay(); // Ensure display is updated immediately after setting times

            hideAllScreens();
            onlineGameScreen.classList.remove('hidden');
            document.getElementById('online-game-id-display').textContent = gameId;
            document.getElementById('online-player-role').textContent = playerRole;

            // Fetch opponent's profile to display their username, Elo, and level
            onlineOpponentProfile = allUserProfiles[onlineOpponentUserId] || await fetchUserProfile(onlineOpponentUserId);
            if (onlineOpponentProfile) {
                document.getElementById('online-opponent-username').textContent = onlineOpponentProfile.username || 'Inconnu';
                // Display correct Elo based on game mode
                document.getElementById('online-opponent-elo').textContent = (gameMode === 'classic' ? onlineOpponentProfile.eloClassic : onlineOpponentProfile.eloBlitz) || 'N/A';
                document.getElementById('online-opponent-level').textContent = onlineOpponentProfile.level || 'N/A';
            } else {
                document.getElementById('online-opponent-username').textContent = 'Chargement...';
                document.getElementById('online-opponent-elo').textContent = 'N/A';
                document.getElementById('online-opponent-level').textContent = 'N/A';
            }

            createCells('online-board', handleOnlineCellClick);
            updateStatus(`Au tour de : ${onlineCurrentTurn}`, 'online'); // Initial status from game data
            resetOnlineBoardUI();

            const gameRef = doc(db, 'games', gameId);
            onlineGameListenerUnsubscribe = onSnapshot(gameRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    console.log("Online game update received:", gameData);

                    onlineBoard = gameData.board;
                    onlineCurrentTurn = gameData.currentPlayer;
                    onlineGameActive = gameData.status === 'active';

                    // Update timers if it's a blitz game
                    if (currentOnlineGameMode === 'blitz') {
                        playerXTime = gameData.playerXTime || 0;
                        playerOTime = gameData.playerOTime || 0;
                        lastMoveTimestamp = gameData.lastMoveTime ? gameData.lastMoveTime.toDate().getTime() : Date.now(); // Convert Firestore Timestamp to JS Date

                        // Stop any existing timer
                        if (timerInterval) clearInterval(timerInterval);

                        // Start timer for the current player if game is active
                        if (onlineGameActive) {
                            timerInterval = setInterval(() => {
                                const now = Date.now();
                                const timeElapsed = now - lastMoveTimestamp;

                                if (onlineCurrentTurn === 'X') {
                                    playerXTime = Math.max(0, BLITZ_TIME_LIMIT_MS - timeElapsed); // Recalculate based on last move
                                    if (playerXTime <= 0) {
                                        playerXTime = 0;
                                        clearInterval(timerInterval);
                                        handleTimeout('X');
                                    }
                                } else { // onlineCurrentTurn === 'O'
                                    playerOTime = Math.max(0, BLITZ_TIME_LIMIT_MS - timeElapsed); // Recalculate based on last move
                                    if (playerOTime <= 0) {
                                        playerOTime = 0;
                                        clearInterval(timerInterval);
                                        handleTimeout('O');
                                    }
                                }
                                updateTimerDisplay();
                            }, 10); // Update every 10ms for hundredths
                        }
                    } else {
                        // For classic mode, ensure timers are not displayed/active
                        playerTimeDisplay.textContent = '--:--.--';
                        opponentTimeDisplay.textContent = '--:--.--';
                        playerTimeDisplay.classList.remove('active', 'low-time');
                        opponentTimeDisplay.classList.remove('active', 'low-time');
                        if (timerInterval) clearInterval(timerInterval);
                    }

                    for (let i = 0; i < onlineBoard.length; i++) {
                        const cell = onlineCells[i];
                        cell.innerHTML = onlineBoard[i];
                        cell.classList.remove('x', 'o');
                        if (onlineBoard[i] !== '') {
                            cell.classList.add(onlineBoard[i].toLowerCase());
                        }
                    }

                    if (gameData.status === 'finished' || gameData.status === 'abandoned' || gameData.status === 'timeout') {
                        onlineGameActive = false;
                        if (onlineGameListenerUnsubscribe) {
                            onlineGameListenerUnsubscribe();
                            onlineGameListenerUnsubscribe = null;
                        }
                        if (timerInterval) {
                            clearInterval(timerInterval); // Stop timer on game end
                            timerInterval = null;
                        }

                        // Fetch the final game data one last time to ensure we have the complete moves history
                        const finalGameDocSnap = await getDoc(gameRef);
                        const finalGameData = finalGameDocSnap.exists() ? finalGameDocSnap.data() : gameData; // Corrected variable name

                        let statusToShow = '';
                        if (gameData.winner === currentOnlinePlayerRole) {
                            statusToShow = 'win';
                        } else if (gameData.winner === 'draw') {
                            statusToShow = 'draw';
                        } else if (gameData.status === 'timeout') { // If game ended by timeout
                            statusToShow = (gameData.winner === currentOnlinePlayerRole) ? 'win' : 'loss'; // Determine win/loss based on winner field
                        }
                        else {
                            statusToShow = 'loss';
                        }

                        // Set isInGame to false for both players once the game is truly finished/abandoned
                        await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false });
                        if (onlineOpponentUserId) {
                            await updateDoc(doc(db, `artifacts/${appId}/users/${onlineOpponentUserId}/profile`, 'data'), { isInGame: false });
                        }

                        showGameEndScreen(statusToShow, gameData.winner, 'online', [...finalGameData.board], finalGameData.moves, currentOnlineGameMode);

                    } else {
                        updateStatus(`Au tour de : ${onlineCurrentTurn}`, 'online');
                        updateTimerDisplay(); // Ensure display is updated even if no move
                    }

                } else {
                    console.log("Online game document deleted.");
                    showMessage("La partie a été annulée ou l'adversaire a quitté.", async () => { // Made async
                        await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false }); // Set isInGame to false
                        if (onlineOpponentUserId) {
                            await updateDoc(doc(db, `artifacts/${appId}/users/${onlineOpponentUserId}/profile`, 'data'), { isInGame: false });
                        }
                        leaveOnlineGame();
                    });
                }
            }, (error) => {
                console.error("Error listening to online game:", error);
                showMessage("Erreur de connexion à la partie en ligne: " + error.message, async () => { // Made async
                    await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false }); // Set isInGame to false
                    if (onlineOpponentUserId) {
                        await updateDoc(doc(db, `artifacts/${appId}/users/${onlineOpponentUserId}/profile`, 'data'), { isInGame: false });
                    }
                    leaveOnlineGame();
                });
            });
        }

        // Function to format time for display
        function formatTime(ms) {
            if (ms < 0) return '--:--.--'; // For classic mode or uninitialized
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const hundredths = Math.floor((ms % 1000) / 10); // Get hundredths

            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${hundredths.toString().padStart(2, '0')}`;
        }

        // Function to update timer display on UI
        function updateTimerDisplay() {
            // Only update if in blitz mode, otherwise, they should be hidden
            if (currentOnlineGameMode === 'blitz') {
                const playerTime = (currentOnlinePlayerRole === 'X') ? playerXTime : playerOTime;
                const opponentTime = (currentOnlinePlayerRole === 'X') ? playerOTime : playerXTime;

                playerTimeDisplay.textContent = formatTime(playerTime);
                opponentTimeDisplay.textContent = formatTime(opponentTime);

                // Update active/low-time classes
                playerTimeDisplay.classList.toggle('active', onlineGameActive && onlineCurrentTurn === currentOnlinePlayerRole);
                opponentTimeDisplay.classList.toggle('active', onlineGameActive && onlineCurrentTurn !== currentOnlinePlayerRole);

                playerTimeDisplay.classList.toggle('low-time', playerTime <= 10000 && playerTime > 0); // 10 seconds or less
                opponentTimeDisplay.classList.toggle('low-time', opponentTime <= 10000 && opponentTime > 0);
            }
            // If in classic mode, the elements are already hidden by startGameOnline, so no display update is needed.
        }

        // Handle timeout
        async function handleTimeout(timedOutPlayer) {
            console.log(`Player ${timedOutPlayer} timed out!`);
            onlineGameActive = false;
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;

            const winnerPlayer = (timedOutPlayer === 'X') ? 'O' : 'X';
            const gameRef = doc(db, 'games', currentOnlineGameId);

            try {
                await updateDoc(gameRef, {
                    status: 'timeout', // Custom status for timeout
                    winner: winnerPlayer,
                    lastMoveTime: serverTimestamp(),
                    playerXTime: playerXTime, // Save final times
                    playerOTime: playerOTime
                });
                console.log("Game updated with timeout status.");
            } catch (error) {
                console.error("Error updating game for timeout:", error);
                showMessage("Erreur lors de la mise à jour de la partie (timeout): " + error.message);
            }
        }


        async function handleOnlineCellClick(event) {
            const clickedCellIndex = parseInt(event.target.dataset.index);

            if (!onlineGameActive || onlineBoard[clickedCellIndex] !== '' || onlineCurrentTurn !== currentOnlinePlayerRole) {
                return;
            }

            // If it's a blitz game, check for timeout before processing move
            if (currentOnlineGameMode === 'blitz') {
                const now = Date.now();
                const timeElapsed = now - lastMoveTimestamp;

                if (currentOnlinePlayerRole === 'X') {
                    playerXTime = Math.max(0, playerXTime - timeElapsed);
                    if (playerXTime <= 0) {
                        handleTimeout('X');
                        return;
                    }
                } else { // currentOnlinePlayerRole === 'O'
                    playerOTime = Math.max(0, playerOTime - timeElapsed);
                    if (playerOTime <= 0) {
                        handleTimeout('O');
                        return;
                    }
                }
            }


            const newBoard = [...onlineBoard];
            newBoard[clickedCellIndex] = currentOnlinePlayerRole;

            const hasWon = checkForWin(currentOnlinePlayerRole, newBoard);
            const hasDraw = checkForDraw(newBoard);

            let nextPlayer = currentOnlinePlayerRole === 'X' ? 'O' : 'X';
            let gameStatus = 'active';
            let winner = null;

            if (hasWon) {
                gameStatus = 'finished';
                winner = currentOnlinePlayerRole;
            } else if (hasDraw) {
                gameStatus = 'finished';
                winner = 'draw';
            }

            try {
                const updateData = {
                    board: newBoard,
                    currentPlayer: nextPlayer,
                    status: gameStatus,
                    winner: winner,
                    lastMoveTime: serverTimestamp(),
                    moves: arrayUnion({ index: clickedCellIndex, player: currentOnlinePlayerRole }) // Add move to history
                };

                // Only update player times in Firestore if it's a blitz game
                if (currentOnlineGameMode === 'blitz') {
                    updateData.playerXTime = (currentOnlinePlayerRole === 'X') ? playerXTime : playerXTime; // Player X's remaining time
                    updateData.playerOTime = (currentOnlinePlayerRole === 'O') ? playerOTime : playerOTime; // Player O's remaining time
                }

                await updateDoc(doc(db, 'games', currentOnlineGameId), updateData);
                console.log("Firestore mis à jour avec le mouvement.");
            } catch (error) {
                console.error("Erreur lors de l'envoi du mouvement:", error);
                showMessage("Erreur lors de l'envoi du mouvement: " + error.message);
            }
        }

        function resetOnlineBoardUI() {
            if (onlineCells) {
                onlineCells.forEach(cell => {
                    cell.innerHTML = '';
                    cell.classList.remove('x', 'o');
                });
            }
        }

        async function resetOnlineGame() {
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';
            onlineGameActive = true;
            resetOnlineBoardUI();
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            findOnlineMatch(currentOnlineGameMode); // Start a new matchmaking search with the same mode
        }

        async function leaveOnlineGame() {
            if (onlineGameListenerUnsubscribe) {
                onlineGameListenerUnsubscribe();
                onlineGameListenerUnsubscribe = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            if (currentOnlineGameId && db) {
                try {
                    const gameDoc = await getDoc(doc(db, 'games', currentOnlineGameId));
                    if (gameDoc.exists() && gameDoc.data().status === 'active') {
                        // Mark game as abandoned and assign win to opponent
                        await updateDoc(doc(db, 'games', currentOnlineGameId), {
                            status: 'abandoned',
                            winner: currentOnlinePlayerRole === 'X' ? 'O' : 'X', // Opponent wins
                            lastMoveTime: serverTimestamp()
                        });
                        console.log("Partie en ligne marquée comme abandonnée.");
                        // Update current user's stats for a loss
                        updateUserProfileStats(currentUserId, 'loss', currentOnlineGameMode, onlineOpponentProfile ? (currentOnlineGameMode === 'classic' ? onlineOpponentProfile.eloClassic : onlineOpponentProfile.eloBlitz) : null);
                    }
                } catch (error) {
                    console.error("Erreur lors de la tentative d'abandon de partie:", error);
                }
            }

            // Set isInGame to false for the current user
            if (currentUserId) {
                await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false });
            }
            // If opponent ID is known, also set their isInGame to false (best effort, might be overwritten by their own leave/game end)
            if (onlineOpponentUserId) {
                await updateDoc(doc(db, `artifacts/${appId}/users/${onlineOpponentUserId}/profile`, 'data'), { isInGame: false });
            }

            // Reset online game state variables
            currentOnlineGameId = null;
            currentOnlinePlayerRole = null;
            onlineOpponentUserId = null;
            onlineOpponentProfile = null;
            onlineGameActive = false;
            onlineBoard = Array(25).fill('');
            onlineCurrentTurn = 'X';
            currentOnlineGameMode = 'classic'; // Reset to default

            hideAllScreens();
            homeScreen.classList.remove('hidden');
            if (isAuthReady && currentUserId) {
                fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
            }
        }


        // --- Fonctions de gestion du classement ---
        async function fetchLeaderboard(mode) {
            if (!db || !isAuthReady) {
                leaderboardList.innerHTML = '<div class="text-center p-4 text-red-500">Erreur: Impossible de charger le classement. Firebase non prêt.</div>';
                return;
            }

            leaderboardList.innerHTML = '<div class="text-center p-4 text-gray-500">Chargement du classement...</div>';

            try {
                const usersCollectionRef = collection(db, `artifacts/${appId}/users`);
                const usersSnapshot = await getDocs(usersCollectionRef);
                console.log("Firebase: Nombre de documents parents utilisateur trouvés :", usersSnapshot.docs.length);

                const users = [];
                const eloField = `elo${mode.charAt(0).toUpperCase() + mode.slice(1)}`; // 'eloClassic' or 'eloBlitz'

                for (const userDoc of usersSnapshot.docs) {
                    const profileDocRef = doc(userDoc.ref, 'profile', 'data');
                    const profileSnap = await getDoc(profileDocRef);

                    if (profileSnap.exists()) {
                        const profileData = profileSnap.data();
                        users.push({
                            id: userDoc.id,
                            username: profileData.username || 'Joueur Inconnu',
                            elo: profileData[eloField] || 0 // Use the correct Elo field
                        });
                    }
                }

                users.sort((a, b) => b.elo - a.elo); // Sort by Elo descending

                displayLeaderboard(users, mode);

            } catch (error) {
                console.error("Erreur lors de la récupération du classement:", error);
                leaderboardList.innerHTML = '<div class="text-center p-4 text-red-500">Erreur lors du chargement du classement.</div>';
                showMessage("Erreur lors du chargement du classement: " + error.message);
            }
        }

        // Modified displayLeaderboard to accept mode
        function displayLeaderboard(users, mode) {
            leaderboardList.innerHTML = '';

            if (users.length === 0) {
                leaderboardList.innerHTML = '<div class="text-center p-4 text-gray-500">Aucun joueur dans le classement pour le moment.</div>';
                return;
            }

            users.forEach((user, index) => {
                const rank = index + 1;
                const listItem = document.createElement('div');
                listItem.classList.add('leaderboard-item');
                listItem.dataset.userId = user.id; // Store user ID for click handler

                if (rank === 1) {
                    listItem.classList.add('top-1');
                } else if (rank <= 3) {
                    listItem.classList.add('top-3');
                }

                listItem.innerHTML = `
                    <span class="rank">${rank}.</span>
                    <span class="username">${user.username}</span>
                    <span class="elo">${user.elo} Elo (${mode.charAt(0).toUpperCase() + mode.slice(1)})</span>
                `;
                listItem.addEventListener('click', () => showUserProfileModal(user.id));
                leaderboardList.appendChild(listItem);
            });

            // Update toggle button active state
            document.getElementById('leaderboard-toggle-classic').classList.remove('active');
            document.getElementById('leaderboard-toggle-blitz').classList.remove('active');
            document.getElementById(`leaderboard-toggle-${mode}`).classList.add('active');
        }

        function showLeaderboardScreen() {
            hideAllScreens();
            leaderboardScreen.classList.remove('hidden');
            fetchLeaderboard(currentLeaderboardDisplayMode); // Fetch based on current mode
        }

        // --- Fonctions de gestion de l'historique des parties ---
        const HISTORY_STORAGE_KEY = 'oxoArenaGameHistory';
        const MAX_HISTORY_ITEMS = 10;

        // Modified saveGameToHistory to store gameMode
        function saveGameToHistory(mode, finalStatus, opponent, finalBoardState, movesHistory, boardSize, gameId = null, gameMode = 'classic') {
            let history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '[]');

            // Prevent duplicate entries for online games if they are already saved by the listener
            if (gameId) {
                if (history.some(game => game.gameId === gameId)) {
                    console.log(`Partie en ligne ${gameId} déjà sauvegardée dans l'historique local. Ignoré.`);
                    return;
                }
            }

            const newGame = {
                id: gameId || Date.now().toString(), // Use gameId for online, timestamp for local/AI
                mode: mode, // 'local', 'ai', 'online'
                gameMode: gameMode, // 'classic' or 'blitz' (only relevant for online)
                date: new Date().toLocaleString(),
                opponent: opponent,
                status: finalStatus,
                finalBoard: finalBoardState,
                moves: movesHistory,
                boardSize: boardSize,
                gameId: gameId // Store gameId for online games
            };
            history.unshift(newGame); // Add to the beginning
            history = history.slice(0, MAX_HISTORY_ITEMS); // Keep only the last MAX_HISTORY_ITEMS
            localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
            console.log("Partie sauvegardée dans l'historique local:", newGame);
        }

        function showGameHistoryScreen() {
            hideAllScreens();
            historyScreen.classList.remove('hidden');
            renderGameHistory();
        }

        function renderGameHistory() {
            gamesHistoryList.innerHTML = '';
            const history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '[]');

            if (history.length === 0) {
                gamesHistoryList.innerHTML = '<p class="text-center p-4 text-gray-600">Aucune partie jouée pour le moment.</p>';
                return;
            }

            history.forEach(game => {
                const gameItem = document.createElement('div');
                gameItem.className = 'bg-gray-50 p-4 rounded-lg shadow flex flex-col items-start space-y-2 cursor-pointer hover:bg-gray-100 transition-colors';
                gameItem.dataset.gameId = game.id;

                gameItem.addEventListener('click', () => showHistoryDetail(game));

                let statusClass = '';
                let statusText = '';
                if (game.status === 'won') {
                    statusClass = 'text-green-600';
                    statusText = 'Victoire';
                } else if (game.status === 'lost') {
                    statusClass = 'text-red-600';
                    statusText = 'Défaite';
                } else {
                    statusClass = 'text-blue-600';
                    statusText = 'Nul';
                }

                let gameModeDisplay = '';
                if (game.mode === 'online') {
                    gameModeDisplay = ` (${game.gameMode.charAt(0).toUpperCase() + game.gameMode.slice(1)})`;
                }


                gameItem.innerHTML = `
                    <div class="w-full flex justify-between items-center">
                        <span class="text-sm text-gray-500">${game.date}</span>
                        <span class="font-semibold ${statusClass}">${statusText}</span>
                    </div>
                    <div class="text-lg font-medium text-gray-800">Mode: ${game.mode === 'local' ? 'Local' : (game.mode === 'ai' ? 'Vs IA' : 'En ligne')}${gameModeDisplay}</div>
                    <div class="text-md text-gray-700">Adversaire: ${game.opponent}</div>
                    <div class="w-full flex justify-center mt-2">
                        ${createMiniBoardHTML(game.finalBoard, game.boardSize)}
                    </div>
                `;
                gamesHistoryList.appendChild(gameItem);
            });
        }

        function createMiniBoardHTML(boardState, boardSize) {
            const cellSizePx = 20;
            const gapPx = 1;

            let boardHTML = `<div class="grid w-full aspect-square bg-gray-300 border border-gray-400 rounded-sm overflow-hidden" style="grid-template-columns: repeat(${boardSize}, 1fr); gap: ${gapPx}px;">`;
            boardState.forEach(cell => {
                let content = '';
                let cellClass = '';
                if (cell === 'X') {
                    content = 'X';
                    cellClass = 'text-[#FFD700]';
                } else if (cell === 'O') {
                    content = 'O';
                    cellClass = 'text-[#1A2B3C]';
                }
                boardHTML += `<div class="flex items-center justify-center bg-white font-bold ${cellClass}" style="font-size: ${cellSizePx * 0.8}px;">${content}</div>`;
            });
            boardHTML += `</div>`;
            return boardHTML;
        }

        // --- History Detail Screen Logic ---
        let currentDetailGameMoves = [];
        let currentDetailMoveIndex = -1;

        function showHistoryDetail(gameData) {
            hideAllScreens();
            historyDetailScreen.classList.remove('hidden');

            let gameModeDisplay = '';
            if (gameData.mode === 'online') {
                gameModeDisplay = ` (${gameData.gameMode.charAt(0).toUpperCase() + gameData.gameMode.slice(1)})`;
            }

            document.getElementById('detail-mode').textContent = `${gameData.mode === 'local' ? 'Local' : (gameData.mode === 'ai' ? 'Vs IA' : 'En ligne')}${gameModeDisplay}`;
            document.getElementById('detail-date').textContent = gameData.date;
            document.getElementById('detail-opponent').textContent = gameData.opponent;
            let statusText = '';
            if (gameData.status === 'won') statusText = 'Victoire';
            else if (gameData.status === 'lost') statusText = 'Défaite';
            else statusText = 'Nul';
            document.getElementById('detail-status').textContent = statusText;

            createCells('detail-board', null); // Create cells without click handler
            currentDetailGameMoves = gameData.moves || [];
            currentDetailMoveIndex = -1; // Start before the first move
            updateDetailBoardDisplay();
        }

        function updateDetailBoardDisplay() {
            const tempBoard = Array(BOARD_SIZE * BOARD_SIZE).fill('');
            for (let i = 0; i <= currentDetailMoveIndex; i++) {
                const move = currentDetailGameMoves[i];
                if (move) {
                    tempBoard[move.index] = move.player;
                }
            }

            const detailCells = Array.from(document.querySelectorAll('#detail-board .cell'));
            detailCells.forEach((cell, index) => {
                cell.innerHTML = tempBoard[index];
                cell.classList.remove('x', 'o');
                if (tempBoard[index] === 'X') {
                    cell.classList.add('x');
                } else if (tempBoard[index] === 'O') {
                    cell.classList.add('o');
                }
            });

            moveCounter.textContent = `Coup ${currentDetailMoveIndex + 1}/${currentDetailGameMoves.length}`;
            prevMoveButton.disabled = currentDetailMoveIndex <= -1;
            nextMoveButton.disabled = currentDetailMoveIndex >= currentDetailGameMoves.length - 1;
        }


        // --- Helper for screen management ---
        function hideAllScreens() {
            homeScreen.classList.add('hidden');
            localGameScreen.classList.add('hidden');
            aiGameScreen.classList.add('hidden');
            onlinePlaySelectionScreen.classList.add('hidden'); // NEW
            onlineSearchingScreen.classList.add('hidden');
            onlineGameScreen.classList.add('hidden');
            gameEndOverlay.classList.add('hidden');
            gameEndBanner.classList.add('hidden');
            leaderboardScreen.classList.add('hidden');
            historyScreen.classList.add('hidden');
            historyDetailScreen.classList.add('hidden');
            friendsScreen.classList.add('hidden'); // Hide friends screen
            userProfileModalOverlay.classList.add('hidden'); // Hide profile modal
            notificationModalOverlay.classList.add('hidden'); // Hide notification modal
            gameInviteModalOverlay.classList.add('hidden'); // NEW: Hide game invite modal
        }

        // --- FRIEND SYSTEM FUNCTIONS ---

        // Utility to get ordered user IDs for consistent document IDs
        function getOrderedUserIds(userId1, userId2) {
            return userId1 < userId2 ? { user1Id: userId1, user2Id: userId2 } : { user1Id: userId2, user2Id: userId1 };
        }

        // Function to fetch all user profiles (for search and friends list display)
        async function fetchAllUserProfiles() {
            if (!db || !isAuthReady) {
                console.warn("Firebase non prêt pour la récupération des profils.");
                return;
            }
            try {
                const usersCollectionRef = collection(db, `artifacts/${appId}/users`);
                const querySnapshot = await getDocs(usersCollectionRef);
                allUserProfiles = {}; // Clear previous data
                for (const userDoc of querySnapshot.docs) {
                    const profileDocRef = doc(userDoc.ref, 'profile', 'data');
                    const profileSnap = await getDoc(profileDocRef);
                    if (profileSnap.exists()) {
                        allUserProfiles[userDoc.id] = { id: userDoc.id, ...profileSnap.data() };
                    }
                }
                console.log("Tous les profils utilisateurs chargés:", Object.keys(allUserProfiles).length);
            } catch (error) {
                console.error("Erreur lors du chargement de tous les profils utilisateurs:", error);
                showMessage("Erreur lors du chargement des profils pour la recherche: " + error.message);
            }
        }

        // Function to display a user's profile in the modal
        async function showUserProfileModal(targetUserId) {
            if (!db || !currentUserId || !isAuthReady || targetUserId === currentUserId) {
                // If trying to view own profile, or not ready, just show main profile or do nothing
                if (targetUserId === currentUserId) {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    return;
                }
                showMessage("Impossible d'afficher le profil. Connexion ou ID invalide.");
                return;
            }

            // Try to get profile from cache, otherwise fetch
            const targetProfile = allUserProfiles[targetUserId] || await fetchUserProfile(targetUserId);
            if (!targetProfile) {
                showMessage("Profil utilisateur introuvable.");
                return;
            }

            // Update modal content
            modalProfileUsername.textContent = targetProfile.username || 'Inconnu';
            modalProfileId.textContent = targetUserId;
            modalProfileEloClassic.textContent = targetProfile.eloClassic || 0; // Display classic Elo
            modalProfileEloBlitz.textContent = targetProfile.eloBlitz || 0;     // Display blitz Elo
            modalProfileLevel.textContent = `${targetProfile.level || 0}/${MAX_LEVEL}`;
            modalProfileGamesPlayed.textContent = targetProfile.gamesPlayedClassic || 0; // Default to classic stats for modal
            modalProfileWins.textContent = targetProfile.winsClassic || 0;
            modalProfileLosses.textContent = targetProfile.lossesClassic || 0;
            modalProfileDraws.textContent = targetProfile.drawsClassic || 0;

            // Display last online status
            if (targetProfile.lastOnline && targetProfile.lastOnline instanceof Object && 'toDate' in targetProfile.lastOnline) {
                const lastOnlineDate = targetProfile.lastOnline.toDate();
                const now = new Date();
                const diffMs = now.getTime() - lastOnlineDate.getTime();
                const minutes = Math.floor(diffMs / (1000 * 60));
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);

                let statusText = '';
                if (minutes < 5) {
                    statusText = 'En ligne';
                    modalProfileLastOnline.classList.add('text-green-600');
                    modalProfileLastOnline.classList.remove('text-gray-500');
                } else if (minutes < 60) {
                    statusText = `Il y a ${minutes} minute${minutes > 1 ? 's' : ''}`;
                    modalProfileLastOnline.classList.remove('text-green-600');
                    modalProfileLastOnline.classList.add('text-gray-500');
                } else if (hours < 24) {
                    statusText = `Il y a ${hours} heure${hours > 1 ? 's' : ''}`;
                    modalProfileLastOnline.classList.remove('text-green-600');
                    modalProfileLastOnline.classList.add('text-gray-500');
                } else {
                    statusText = `Il y a ${days} jour${days > 1 ? 's' : ''}`;
                    modalProfileLastOnline.classList.remove('text-green-600');
                    modalProfileLastOnline.classList.add('text-gray-500');
                }
                modalProfileLastOnline.textContent = statusText;
            } else {
                modalProfileLastOnline.textContent = 'Non disponible';
                modalProfileLastOnline.classList.add('text-gray-500');
                modalProfileLastOnline.classList.remove('text-green-600');
            }


            // Hide all action buttons initially
            sendFriendRequestButton.classList.add('hidden');
            cancelFriendRequestButton.classList.add('hidden');
            acceptFriendRequestButton.classList.add('hidden');
            declineFriendRequestButton.classList.add('hidden');
            unfriendButton.classList.add('hidden');
            blockUserButton.classList.add('hidden');
            unblockUserButton.classList.add('hidden');
            proposeGameButton.classList.add('hidden');

            // Determine friendship status and show relevant buttons
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, targetUserId);
            const q = query(
                collection(db, "friendships"),
                where("user1Id", "==", user1Id),
                where("user2Id", "==", user2Id)
            );
            const querySnapshot = await getDocs(q);

            let friendshipStatus = null;
            let friendshipDocId = null;

            if (!querySnapshot.empty) {
                const docData = querySnapshot.docs[0].data();
                friendshipStatus = docData.status;
                friendshipDocId = querySnapshot.docs[0].id;
                currentFriendshipDocId = friendshipDocId; // Store for later use
            } else {
                currentFriendshipDocId = null;
            }

            // Display buttons based on status
            if (friendshipStatus === 'pending') {
                if (querySnapshot.docs[0].data().senderId === targetUserId) { // Target sent request to current user
                    acceptFriendRequestButton.classList.remove('hidden');
                    declineFriendRequestButton.classList.remove('hidden');
                } else { // Current user sent request to target
                    cancelFriendRequestButton.classList.remove('hidden');
                }
            } else if (friendshipStatus === 'accepted') {
                unfriendButton.classList.remove('hidden');
                proposeGameButton.classList.remove('hidden');
                blockUserButton.classList.remove('hidden'); // Can block an accepted friend
            } else if (friendshipStatus === 'blocked') {
                if (querySnapshot.docs[0].data().senderId === currentUserId) { // Current user blocked target
                    unblockUserButton.classList.remove('hidden');
                } else { // Target blocked current user (cannot unblock from here)
                    showMessage(`${targetProfile.username} vous a bloqué.`);
                }
            } else { // No existing friendship
                sendFriendRequestButton.classList.remove('hidden');
                blockUserButton.classList.remove('hidden'); // Can block someone not yet a friend
            }

            // Show the modal
            userProfileModalOverlay.classList.remove('hidden');
        }

        // --- Friend System Firebase Operations ---

        async function sendFriendRequest(receiverId, isAuto = false) {
            if (!db || !currentUserId || !isAuthReady) {
                if (!isAuto) showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }
            if (currentUserId === receiverId) {
                if (!isAuto) showMessage("Vous ne pouvez pas vous ajouter vous-même en ami.");
                return;
            }

            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, receiverId);
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id));
            const querySnapshot = await getDocs(q);

            try {
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    const currentStatus = querySnapshot.docs[0].data().status;
                    const senderOfExisting = querySnapshot.docs[0].data().senderId;

                    if (currentStatus === 'pending') {
                        if (senderOfExisting === currentUserId) {
                            if (!isAuto) showMessage("Vous avez déjà envoyé une demande à cet utilisateur.");
                        } else { // Receiver sent request to current user, now current user sends back -> accept
                            await updateDoc(docRef, { status: "accepted", timestamp: serverTimestamp() });
                            showMessage("Demande d'ami acceptée !");
                        }
                    } else if (currentStatus === 'accepted') {
                        if (!isAuto) showMessage("Vous êtes déjà amis.");
                    } else if (currentStatus === 'blocked') {
                        if (senderOfExisting === currentUserId) { // Current user blocked target
                            if (!isAuto) showMessage("Vous avez bloqué cet utilisateur. Débloquez-le d'abord.");
                        } else { // Target blocked current user
                            if (!isAuto) showMessage("Cet utilisateur vous a bloqué. Impossible d'envoyer une demande.");
                        }
                    }
                } else {
                    // Use addDoc to let Firestore generate a unique ID for the friendship document
                    await addDoc(collection(db, "friendships"), {
                        user1Id: user1Id,
                        user2Id: user2Id,
                        status: "pending",
                        senderId: currentUserId, // Store who sent the request
                        timestamp: serverTimestamp()
                    });
                    showMessage("Demande d'ami envoyée !");
                }
            } catch (error) {
                console.error("Erreur lors de l'envoi de la demande d'ami:", error);
                if (!isAuto) showMessage("Erreur lors de l'envoi de la demande: " + error.message);
            } finally {
                if (!isAuto) userProfileModalOverlay.classList.add('hidden'); // Close modal after action
            }
        }

        async function acceptFriendRequest(requesterId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, requesterId);
            // Query for the pending request where the current user is the receiver
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id), where("status", "==", "pending"));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await updateDoc(docRef, { status: "accepted", timestamp: serverTimestamp() });
                    showMessage("Demande d'ami acceptée !");
                } else {
                    showMessage("Aucune demande en attente trouvée.");
                }
            } catch (error) {
                console.error("Erreur lors de l'acceptation de la demande d'ami:", error);
                showMessage("Erreur lors de l'acceptation: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
                notificationModalOverlay.classList.add('hidden'); // Also close notification modal
            }
        }

        async function declineFriendRequest(requesterId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, requesterId);
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id), where("status", "==", "pending"));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await deleteDoc(docRef); // Simply delete the pending request
                    showMessage("Demande d'ami refusée.");
                } else {
                    showMessage("Aucune demande en attente trouvée.");
                }
            } catch (error) {
                console.error("Erreur lors du refus de la demande d'ami:", error);
                showMessage("Erreur lors du refus: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
                notificationModalOverlay.classList.add('hidden');
            }
        }

        async function unfriend(targetId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, targetId);
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id), where("status", "==", "accepted"));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await deleteDoc(docRef);
                    showMessage(`Vous n'êtes plus ami avec ${allUserProfiles[targetId]?.username || targetId}.`);
                } else {
                    showMessage("Vous n'êtes pas ami avec cet utilisateur.");
                }
            } catch (error) {
                console.error("Erreur lors du défriending:", error);
                showMessage("Erreur lors du défriending: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
            }
        }

        async function blockUser(targetId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, targetId);
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await updateDoc(docRef, { status: "blocked", senderId: currentUserId, timestamp: serverTimestamp() });
                    showMessage(`Vous avez bloqué ${allUserProfiles[targetId]?.username || targetId}.`);
                } else {
                    // If no existing friendship, create a new one with blocked status
                    await addDoc(collection(db, "friendships"), {
                        user1Id: user1Id,
                        user2Id: user2Id,
                        status: "blocked",
                        senderId: currentUserId, // Store who initiated the block
                        timestamp: serverTimestamp()
                    });
                    showMessage(`Vous avez bloqué ${allUserProfiles[targetId]?.username || targetId}.`);
                }
            } catch (error) {
                console.error("Erreur lors du blocage de l'utilisateur:", error);
                showMessage("Erreur lors du blocage: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
            }
        }

        async function unblockUser(targetId) {
            if (!db || !currentUserId || !isAuthReady) { showMessage("Erreur: Firebase non prêt ou utilisateur non connecté."); return; }
            const { user1Id, user2Id } = getOrderedUserIds(currentUserId, targetId);
            // Only unblock if current user was the one who blocked
            const q = query(collection(db, "friendships"), where("user1Id", "==", user1Id), where("user2Id", "==", user2Id), where("status", "==", "blocked"), where("senderId", "==", currentUserId));

            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const docRef = querySnapshot.docs[0].ref;
                    await deleteDoc(docRef); // Remove the block entry
                    showMessage(`Vous avez débloqué ${allUserProfiles[targetId]?.username || targetId}.`);
                } else {
                    showMessage("Cet utilisateur n'est pas bloqué par vous.");
                }
            } catch (error) {
                console.error("Erreur lors du déblocage de l'utilisateur:", error);
                showMessage("Erreur lors du déblocage: " + error.message);
            } finally {
                userProfileModalOverlay.classList.add('hidden');
            }
        }

        // --- Friend List and Search UI ---

        function showFriendsScreen() {
            hideAllScreens();
            friendsScreen.classList.remove('hidden');
            renderFriendsList(); // Render current friends
            userSearchResults.classList.add('hidden'); // Hide search results initially
            userSearchInput.value = ''; // Clear search input
            // Enable/Disable share button based on auth status
            if (isAuthReady && currentUserId) {
                shareAppButton.disabled = false;
                shareAppButton.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                shareAppButton.disabled = true;
                shareAppButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        async function renderFriendsList() {
            if (!db || !currentUserId || !isAuthReady) {
                friendsListElement.innerHTML = '<p class="p-4 text-red-500 text-center">Connexion Firebase non établie.</p>';
                return;
            }

            friendsListElement.innerHTML = '<p class="p-4 text-gray-500 text-center">Chargement de vos amis...</p>';

            try {
                // Query for friendships where current user is either user1Id or user2Id AND status is 'accepted'
                const q = query(
                    collection(db, "friendships"),
                    and(
                        or(
                            where("user1Id", "==", currentUserId),
                            where("user2Id", "==", currentUserId)
                        ),
                        where("status", "==", "accepted")
                    )
                );
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    friendsListElement.innerHTML = '<p class="p-4 text-gray-500 text-center">Vous n\'avez pas encore d\'amis.</p>';
                    return;
                }

                friendsListElement.innerHTML = ''; // Clear loading message

                const friends = [];
                for (const docSnap of querySnapshot.docs) {
                    const data = docSnap.data();
                    const friendId = data.user1Id === currentUserId ? data.user2Id : data.user1Id;
                    // Try to get friend profile from cached allUserProfiles, otherwise fetch
                    const friendProfile = allUserProfiles[friendId] || await fetchUserProfile(friendId);
                    if (friendProfile) {
                        friends.push({ id: friendId, username: friendProfile.username, lastOnline: friendProfile.lastOnline, isInGame: friendProfile.isInGame }); // Include isInGame
                    }
                }

                // Sort friends: online first, then in-game, then alphabetically by username
                friends.sort((a, b) => {
                    const fiveMinutesAgo = new Date().getTime() - (5 * 60 * 1000);
                    const onlineA = a.lastOnline && typeof a.lastOnline.toDate === 'function' && (a.lastOnline.toDate().getTime() > fiveMinutesAgo);
                    const onlineB = b.lastOnline && typeof b.lastOnline.toDate === 'function' && (b.lastOnline.toDate().getTime() > fiveMinutesAgo);

                    // Prioritize online status
                    if (onlineA && !onlineB) return -1;
                    if (!onlineA && onlineB) return 1;

                    // If both are online or both offline, prioritize in-game status
                    if (a.isInGame && !b.isInGame) return -1;
                    if (!a.isInGame && b.isInGame) return 1;

                    // If same online/in-game status, sort alphabetically
                    return (a.username || '').localeCompare(b.username || '');
                });


                friends.forEach(friend => {
                    const friendItem = document.createElement('div');
                    friendItem.classList.add('user-list-item');
                    friendItem.dataset.userId = friend.id;
                    friendItem.addEventListener('click', () => showUserProfileModal(friend.id));

                    let statusIndicatorClass = '';
                    let statusText = '';
                    const fiveMinutesAgo = new Date().getTime() - (5 * 60 * 1000);

                    if (friend.lastOnline && typeof friend.lastOnline.toDate === 'function' && (new Date().getTime() - friend.lastOnline.toDate().getTime() < 5 * 60 * 1000)) {
                        statusIndicatorClass = 'online';
                        statusText = 'En ligne';
                        if (friend.isInGame) {
                            statusText = 'En partie'; // Override if in game
                            statusIndicatorClass = 'bg-yellow-500'; // Yellow for in-game
                        }
                    } else if (friend.lastOnline && typeof friend.lastOnline.toDate === 'function') {
                        const lastOnlineDate = friend.lastOnline.toDate();
                        const diffMs = new Date().getTime() - lastOnlineDate.getTime();
                        const minutes = Math.floor(diffMs / (1000 * 60));
                        const hours = Math.floor(minutes / 60);
                        const days = Math.floor(hours / 24);

                        if (minutes < 60) {
                            statusText = `Il y a ${minutes} min`;
                        } else if (hours < 24) {
                            statusText = `Il y a ${hours} h`;
                        } else {
                            statusText = `Il y a ${days} j`;
                        }
                        statusIndicatorClass = 'bg-gray-400'; // Grey for offline
                    } else {
                        statusText = 'Hors ligne';
                        statusIndicatorClass = 'bg-gray-400'; // Grey for offline
                    }

                    friendItem.innerHTML = `
                        <span class="status-indicator ${statusIndicatorClass}"></span>
                        <span class="username-display">${friend.username || 'Inconnu'}</span>
                        <span class="text-xs text-gray-500 ml-auto">${statusText}</span>
                    `;
                    friendsListElement.appendChild(friendItem);
                });

            } catch (error) {
                console.error("Erreur lors du rendu de la liste d'amis:", error);
                friendsListElement.innerHTML = '<p class="p-4 text-red-500 text-center">Erreur lors du chargement des amis.</p>';
            }
        }

        async function searchUsers() {
            if (!db || !currentUserId || !isAuthReady) {
                userSearchResults.innerHTML = '<p class="p-4 text-red-500 text-center">Connexion Firebase non établie.</p>';
                userSearchResults.classList.remove('hidden');
                return;
            }

            const searchTerm = userSearchInput.value.trim().toLowerCase();
            userSearchResults.innerHTML = ''; // Clear previous results
            userSearchResults.classList.remove('hidden');

            if (searchTerm.length < 3) {
                userSearchResults.innerHTML = '<p class="p-4 text-gray-500 text-center">Tapez au moins 3 caractères.</p>';
                return;
            }

            // Filter from the cached allUserProfiles
            const results = Object.values(allUserProfiles).filter(profile =>
                profile.id !== currentUserId && // Exclude current user from search results
                (profile.username.toLowerCase().includes(searchTerm) || profile.id.toLowerCase().includes(searchTerm))
            );

            if (results.length === 0) {
                userSearchResults.innerHTML = '<p class="p-4 text-gray-500 text-center">Aucun utilisateur trouvé.</p>';
                return;
            }

            results.forEach(user => {
                const userItem = document.createElement('div');
                userItem.classList.add('user-list-item');
                userItem.dataset.userId = user.id;
                userItem.addEventListener('click', () => showUserProfileModal(user.id));

                userItem.innerHTML = `
                    <span class="username-display">${user.username}</span>
                    <span class="user-id-display">${user.id}</span>
                `;
                userSearchResults.appendChild(userItem);
            });
        }

        // --- Notification System ---

        let pendingFriendRequests = [];
        // gameProposals is already declared globally above.

        function setupFriendshipListeners() {
            if (!db || !currentUserId) return;

            // Unsubscribe existing listeners if any to prevent duplicates
            if (friendsListenerUnsubscribe) friendsListenerUnsubscribe();
            if (pendingRequestsListenerUnsubscribe) pendingRequestsListenerUnsubscribe();

            // Listener for accepted friends (for friends list)
            friendsListenerUnsubscribe = onSnapshot(
                query(
                    collection(db, "friendships"),
                    and(
                        or(
                            where("user1Id", "==", currentUserId),
                            where("user2Id", "==", currentUserId)
                        ),
                        where("status", "==", "accepted")
                    )
                ),
                (snapshot) => {
                    renderFriendsList(); // Re-render friends list on any change
                },
                (error) => {
                    console.error("Erreur d'écoute des amis:", error);
                }
            );

            // Listener for pending friend requests (for notifications)
            pendingRequestsListenerUnsubscribe = onSnapshot(
                query(
                    collection(db, "friendships"),
                    where("user2Id", "==", currentUserId), // Current user is the receiver
                    where("status", "==", "pending")
                ),
                async (snapshot) => {
                    pendingFriendRequests = []; // Clear previous requests
                    for (const docSnap of snapshot.docs) {
                        const data = docSnap.data();
                        // Fetch sender's profile to get username for display
                        const senderProfile = allUserProfiles[data.senderId] || await fetchUserProfile(data.senderId);
                        if (senderProfile) {
                            pendingFriendRequests.push({
                                id: docSnap.id,
                                senderId: data.senderId,
                                senderUsername: senderProfile.username,
                                type: 'friend_request'
                            });
                        }
                    }
                    updateNotificationCount();
                    if (!notificationModalOverlay.classList.contains('hidden')) {
                        renderNotifications(); // Re-render if modal is open
                    }
                },
                (error) => {
                    console.error("Erreur d'écoute des demandes d'amis:", error);
                }
            );
        }

        // Setup listener for incoming game invites
        function setupGameInviteListener() {
            if (!db || !currentUserId) return;

            if (gameInvitesListenerUnsubscribe) gameInvitesListenerUnsubscribe();

            gameInvitesListenerUnsubscribe = onSnapshot(
                query(
                    collection(db, "game_invites"),
                    where("receiverId", "==", currentUserId),
                    where("status", "==", "pending")
                ),
                async (snapshot) => {
                    gameProposals = [];
                    for (const docSnap of snapshot.docs) {
                        const data = docSnap.data();
                        const senderProfile = allUserProfiles[data.senderId] || await fetchUserProfile(data.senderId);
                        if (senderProfile) {
                            gameProposals.push({
                                id: docSnap.id,
                                senderId: data.senderId,
                                senderUsername: senderProfile.username,
                                type: 'game_invite',
                                gameMode: data.gameMode || 'classic' // Get game mode from invite
                            });
                        }
                    }
                    updateNotificationCount();
                    // If there's a new game proposal and no other game invite is active, show the modal
                    if (gameProposals.length > 0 && !gameInviteModalOverlay.classList.contains('hidden') === false) {
                        showGameInviteModal(gameProposals[0]); // Show the first pending invite
                    } else if (gameProposals.length === 0 && !gameInviteModalOverlay.classList.contains('hidden')) {
                         // If no more proposals and modal is open, close it
                        gameInviteModalOverlay.classList.add('hidden');
                    }
                    if (!notificationModalOverlay.classList.contains('hidden')) {
                        renderNotifications(); // Re-render if notification modal is open
                    }
                },
                (error) => {
                    console.error("Erreur d'écoute des invitations de partie:", error);
                }
            );
        }


        function updateNotificationCount() {
            const totalNotifications = pendingFriendRequests.length + gameProposals.length;
            if (totalNotifications > 0) {
                notificationCount.textContent = totalNotifications;
                notificationCount.classList.remove('hidden');
            } else {
                notificationCount.classList.add('hidden');
            }
        }

        function showNotificationModal() {
            notificationModalOverlay.classList.remove('hidden');
            renderNotifications();
        }

        function renderNotifications() {
            notificationList.innerHTML = ''; // Clear previous notifications
            if (pendingFriendRequests.length === 0 && gameProposals.length === 0) {
                notificationList.innerHTML = '<p class="p-4 text-gray-500 text-center">Aucune notification.</p>';
                return;
            }

            pendingFriendRequests.forEach(request => {
                const item = document.createElement('div');
                item.classList.add('notification-item');
                item.innerHTML = `
                    <span>Demande d'ami de <span class="font-semibold">${request.senderUsername}</span></span>
                    <div class="actions">
                        <button class="accept-button" data-sender-id="${request.senderId}">Accepter</button>
                        <button class="decline-button" data-sender-id="${request.senderId}">Refuser</button>
                    </div>
                `;
                item.querySelector('.accept-button').addEventListener('click', () => acceptFriendRequest(request.senderId));
                item.querySelector('.decline-button').addEventListener('click', () => declineFriendRequest(request.senderId));
                notificationList.appendChild(item);
            });

            gameProposals.forEach(proposal => {
                const item = document.createElement('div');
                item.classList.add('notification-item');
                item.innerHTML = `
                    <span>Invitation de partie ${proposal.gameMode === 'blitz' ? 'Blitz' : 'Classique'} de <span class="font-semibold">${proposal.senderUsername}</span></span>
                    <div class="actions">
                        <button class="accept-button bg-purple-600 hover:bg-purple-700" data-invite-id="${proposal.id}" data-sender-id="${proposal.senderId}" data-game-mode="${proposal.gameMode}">Accepter</button>
                        <button class="decline-button" data-invite-id="${proposal.id}">Refuser</button>
                    </div>
                `;
                item.querySelector('.accept-button').addEventListener('click', () => acceptGameInvitation(proposal.id, proposal.senderId, proposal.gameMode));
                item.querySelector('.decline-button').addEventListener('click', () => declineGameInvitation(proposal.id));
                notificationList.appendChild(item);
            });
        }

        // Game Invitation Logic
        async function sendGameInvitation(receiverId, receiverUsername, gameMode = 'classic') {
            if (!db || !currentUserId || !isAuthReady || !userProfileData) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }

            // Check if sender is already in a game
            if (userProfileData.isInGame) {
                showMessage("Vous êtes déjà en partie. Vous ne pouvez pas envoyer d'invitation.");
                userProfileModalOverlay.classList.add('hidden');
                return;
            }

            // Check if receiver is already in a game
            const receiverProfile = allUserProfiles[receiverId] || await fetchUserProfile(receiverId);
            if (receiverProfile && receiverProfile.isInGame) {
                showMessage(`${receiverUsername} est déjà en train de jouer.`);
                userProfileModalOverlay.classList.add('hidden');
                return;
            }

            try {
                // Check if a pending invitation already exists from sender to receiver for this mode
                const existingInviteQuery = query(
                    collection(db, "game_invites"),
                    where("senderId", "==", currentUserId),
                    where("receiverId", "==", receiverId),
                    where("status", "==", "pending"),
                    where("gameMode", "==", gameMode) // Check for specific game mode
                );
                const existingInviteSnapshot = await getDocs(existingInviteQuery);

                if (!existingInviteSnapshot.empty) {
                    showMessage(`Vous avez déjà envoyé une invitation ${gameMode === 'blitz' ? 'Blitz' : 'Classique'} à ${receiverUsername}.`);
                    userProfileModalOverlay.classList.add('hidden');
                    return;
                }

                // Check if a pending invitation already exists from receiver to sender for this mode
                const reverseInviteQuery = query(
                    collection(db, "game_invites"),
                    where("senderId", "==", receiverId),
                    where("receiverId", "==", currentUserId),
                    where("status", "==", "pending"),
                    where("gameMode", "==", gameMode) // Check for specific game mode
                );
                const reverseInviteSnapshot = await getDocs(reverseInviteQuery);

                if (!reverseInviteSnapshot.empty) {
                    showMessage(`${receiverUsername} vous a déjà envoyé une invitation ${gameMode === 'blitz' ? 'Blitz' : 'Classique'}. Vérifiez vos notifications.`);
                    userProfileModalOverlay.classList.add('hidden');
                    return;
                }

                // Add the new invitation document
                const newInviteRef = await addDoc(collection(db, "game_invites"), {
                    senderId: currentUserId,
                    senderUsername: userProfileData.username,
                    receiverId: receiverId,
                    receiverUsername: receiverUsername,
                    status: "pending",
                    timestamp: serverTimestamp(),
                    gameId: null, // Initialize gameId as null
                    gameMode: gameMode // Store game mode
                });

                showMessage(`Invitation de partie ${gameMode === 'blitz' ? 'Blitz' : 'Classique'} envoyée à ${receiverUsername} ! En attente de réponse...`);
                userProfileModalOverlay.classList.add('hidden');

                // Set isInGame to true for the sender immediately after sending the invite
                await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: true });


                // Set up a listener for this specific sent invitation
                if (currentSentInviteListenerUnsubscribe) {
                    currentSentInviteListenerUnsubscribe(); // Unsubscribe previous listener if any
                }
                currentSentInviteListenerUnsubscribe = onSnapshot(newInviteRef, async (docSnap) => {
                    if (docSnap.exists()) {
                        const inviteData = docSnap.data();
                        if (inviteData.status === 'accepted' && inviteData.gameId) {
                            console.log("Sent invite accepted! Starting game for sender.");
                            if (currentSentInviteListenerUnsubscribe) {
                                currentSentInviteListenerUnsubscribe(); // Unsubscribe once accepted
                                currentSentInviteListenerUnsubscribe = null;
                            }
                            // Start game for the sender (Comte 1) as Player X, opponent is receiver (Comte 2)
                            startGameOnline(inviteData.gameId, 'X', inviteData.receiverId, inviteData.gameMode);
                        } else if (inviteData.status === 'declined') {
                            console.log("Sent invite declined.");
                            if (currentSentInviteListenerUnsubscribe) {
                                currentSentInviteListenerUnsubscribe(); // Unsubscribe once declined
                                currentSentInviteListenerUnsubscribe = null;
                            }
                            showMessage(`${inviteData.receiverUsername} a refusé votre invitation de partie.`);
                            // Set isInGame to false for the sender if they were waiting
                            if (currentUserId) {
                                await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false });
                            }
                        }
                    } else {
                        console.log("Sent invite document deleted or no longer exists.");
                        if (currentSentInviteListenerUnsubscribe) {
                            currentSentInviteListenerUnsubscribe();
                            currentSentInviteListenerUnsubscribe = null;
                        }
                        // Set isInGame to false for the sender if they were waiting
                        if (currentUserId) {
                            await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false });
                        }
                    }
                }, (error) => {
                    console.error("Error listening to sent game invite:", error);
                    showMessage("Erreur lors de l'écoute de l'invitation envoyée: " + error.message);
                });

            } catch (error) {
                console.error("Erreur lors de l'envoi de l'invitation de partie:", error);
                showMessage("Erreur lors de l'envoi de l'invitation: " + error.message);
                // Ensure isInGame is set to false if an error occurs during sending
                if (currentUserId) {
                    await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: false });
                }
            } finally {
                // Modal is closed after showing "En attente de réponse..."
            }
        }

        function showGameInviteModal(invite) {
            currentIncomingGameInvite = invite;
            gameInviteTitle.textContent = "Invitation de Partie";
            gameInviteMessage.textContent = `${invite.senderUsername} vous propose une partie ${invite.gameMode === 'blitz' ? 'Blitz' : 'Classique'} !`;
            gameInviteStatusMessage.classList.add('hidden'); // Hide any previous status message
            gameInviteModalOverlay.classList.remove('hidden');
        }

        // Modified acceptGameInvitation to pass gameMode
        async function acceptGameInvitation(inviteId, senderId, gameMode) {
            if (!db || !currentUserId || !isAuthReady || !userProfileData) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }

            // Check if current user is already in a game
            if (userProfileData.isInGame) {
                gameInviteStatusMessage.textContent = "Vous êtes déjà en partie. Impossible d'accepter.";
                gameInviteStatusMessage.classList.remove('hidden');
                // Automatically decline the invite after showing message
                await declineGameInvitation(inviteId);
                return;
            }

            // Check if sender is still in a game (or if their profile is updated)
            const senderProfile = allUserProfiles[senderId] || await fetchUserProfile(senderId);
            if (!senderProfile || senderProfile.isInGame) {
                gameInviteStatusMessage.textContent = `${senderProfile ? senderProfile.username : 'L\'envoyeur'} est déjà en partie ou n'est plus disponible.`;
                gameInviteStatusMessage.classList.remove('hidden');
                // Automatically decline the invite after showing message
                await declineGameInvitation(inviteId);
                return;
            }

            const inviteRef = doc(db, "game_invites", inviteId);
            try {
                // Create a new game document (similar to matchmaking)
                const gameRef = doc(collection(db, 'games'));
                const gameId = gameRef.id;

                // Sender is always X, Receiver is always O for invited games
                const playerXId = senderId;
                const playerOId = currentUserId;

                const gameDataToSet = {
                    playerXId: playerXId,
                    playerOId: playerOId,
                    board: Array(25).fill(''),
                    currentPlayer: 'X',
                    status: 'active',
                    winner: null,
                    createdAt: serverTimestamp(),
                    lastMoveTime: serverTimestamp(),
                    moves: [],
                    gameMode: gameMode // Store game mode
                };

                // Add initial times for blitz games
                if (gameMode === 'blitz') {
                    gameDataToSet.playerXTime = BLITZ_TIME_LIMIT_MS;
                    gameDataToSet.playerOTime = BLITZ_TIME_LIMIT_MS;
                }

                await setDoc(gameRef, gameDataToSet);

                // Update invite status to accepted AND add gameId
                await updateDoc(inviteRef, { status: "accepted", gameId: gameId, timestamp: serverTimestamp() });

                // Update both players' isInGame status to true
                await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/profile`, 'data'), { isInGame: true });
                await updateDoc(doc(db, `artifacts/${appId}/users/${senderId}/profile`, 'data'), { isInGame: true });

                showMessage("Invitation acceptée ! Démarrage de la partie...", () => {
                    gameInviteModalOverlay.classList.add('hidden');
                    startGameOnline(gameId, 'O', senderId, gameMode); // Current user is O in this case
                });

            } catch (error) {
                console.error("Erreur lors de l'acceptation de l'invitation de partie:", error);
                gameInviteStatusMessage.textContent = "Erreur lors de l'acceptation: " + error.message;
                gameInviteStatusMessage.classList.remove('hidden');
                // If there's an error, try to set the invite status back to pending or delete it to avoid stuck invites
                await updateDoc(inviteRef, { status: "failed_acceptance" }).catch(e => console.error("Failed to update invite status:", e));
            }
        }

        async function declineGameInvitation(inviteId) {
            if (!db || !currentUserId || !isAuthReady) {
                showMessage("Erreur: Firebase non prêt ou utilisateur non connecté.");
                return;
            }
            const inviteRef = doc(db, "game_invites", inviteId);
            try {
                await updateDoc(inviteRef, { status: "declined", timestamp: serverTimestamp() });
                showMessage("Invitation de partie refusée.");
            } catch (error) {
                console.error("Erreur lors du refus de l'invitation de partie:", error);
                showMessage("Erreur lors du refus: " + error.message);
            } finally {
                gameInviteModalOverlay.classList.add('hidden');
                notificationModalOverlay.classList.add('hidden'); // Close notification modal too if open
            }
        }

        // --- Share App Function ---
        async function shareApp() {
            if (!isAuthReady || !currentUserId || !userProfileData) {
                showMessage("Veuillez vous connecter pour partager l'application.");
                return;
            }

            const appUrl = window.location.origin + window.location.pathname; // Get base URL of the app
            const shareUrlWithInvite = `${appUrl}?invite_from=${currentUserId}`;
            const shareTitle = "Rejoins-moi sur OXO Arena !";
            const shareText = `Salut ! Viens jouer à OXO Arena avec moi ! C'est un super jeu de morpion en ligne. Mon pseudo est "${userProfileData.username}" et mon ID est "${currentUserId}". Ajoute-moi en ami en utilisant mon ID une fois que tu es inscrit. Clique ici pour jouer : ${shareUrlWithInvite}`;

            if (navigator.share) {
                try {
                    await navigator.share({
                        title: shareTitle,
                        text: shareText,
                        url: shareUrlWithInvite,
                    });
                    console.log('Partage réussi !');
                } catch (error) {
                    console.error('Erreur de partage:', error);
                    // User cancelled share, or other error
                    if (error.name === 'AbortError') {
                        // User cancelled, no need to show error message
                    } else {
                        showMessage("Impossible de partager l'application. Veuillez copier le texte ci-dessous et le coller manuellement. \n\n" + shareText);
                    }
                }
            } else {
                // Fallback for browsers that do not support Web Share API
                showMessage("Votre navigateur ne supporte pas le partage direct. Veuillez copier le texte ci-dessous et le coller manuellement. \n\n" + shareText);
            }
        }

        // --- NEW: Function to process URL invitation ---
        async function processUrlInvitation(inviteFromId) {
            if (!isAuthReady || !currentUserId || !userProfileData) {
                console.warn("Firebase not ready or user not logged in to process URL invitation.");
                return;
            }

            if (inviteFromId && inviteFromId !== currentUserId) {
                console.log(`Processing URL invitation from: ${inviteFromId}`);
                // Try to fetch the inviter's profile to get their username
                const inviterProfile = allUserProfiles[inviteFromId] || await fetchUserProfile(inviteFromId);
                const inviterUsername = inviterProfile ? inviterProfile.username : inviteFromId;

                // Attempt to send a friend request automatically
                await sendFriendRequest(inviteFromId, true); // Use isAuto = true to suppress redundant messages
                showMessage(`Demande d'ami envoyée automatiquement à ${inviterUsername} (ID: ${inviteFromId}) !`);
            }
        }


        // --- Logique de navigation entre les écrans ---
        document.addEventListener('DOMContentLoaded', function() {
            hideAllScreens();
            homeScreen.classList.remove('hidden');

            // Parse URL parameters immediately on DOMContentLoaded
            const urlParams = new URLSearchParams(window.location.search);
            const inviteFromIdParam = urlParams.get('invite_from');
            if (inviteFromIdParam) {
                urlInviteFromId = inviteFromIdParam; // Store it globally
                // Remove the parameter from the URL to prevent re-processing on refresh
                const newUrl = window.location.origin + window.location.pathname;
                window.history.replaceState({}, document.title, newUrl);
            }


            // Username management event listeners
            if (changeUsernameButton) {
                changeUsernameButton.addEventListener('click', showUsernameEditForm);
            }
            if (saveUsernameButton) {
                saveUsernameButton.addEventListener('click', handleSaveUsername);
            }
            if (cancelUsernameButton) {
                cancelUsernameButton.addEventListener('click', cancelUsernameEdit);
            }

            // Play Online button now shows online mode selection screen
            if (playOnlineButton) {
                playOnlineButton.addEventListener('click', function() {
                    if (isAuthReady && currentUserId) {
                        // Check if current user is already in a game
                        if (userProfileData && userProfileData.isInGame) {
                            showMessage("Vous êtes déjà en partie. Quittez votre partie actuelle avant de chercher un match.");
                            return;
                        }
                        hideAllScreens();
                        onlinePlaySelectionScreen.classList.remove('hidden');
                    } else {
                        showMessage("Veuillez patienter, la connexion à Firebase est en cours...", () => {
                            // Retry after message box is closed
                            if (isAuthReady && currentUserId) {
                                if (userProfileData && userProfileData.isInGame) {
                                    showMessage("Vous êtes déjà en partie. Quittez votre partie actuelle avant de chercher un match.");
                                    return;
                                }
                                hideAllScreens();
                                onlinePlaySelectionScreen.classList.remove('hidden');
                            } else {
                                showMessage("Impossible de se connecter à Firebase. Veuillez vérifier votre connexion.");
                            }
                        });
                    }
                });
            }

            // NEW: Online Mode Selection Buttons
            if (selectClassicOnlineButton) {
                selectClassicOnlineButton.addEventListener('click', () => {
                    findOnlineMatch('classic');
                });
            }
            if (selectBlitzOnlineButton) {
                selectBlitzOnlineButton.addEventListener('click', () => {
                    findOnlineMatch('blitz');
                });
            }
            if (onlineSelectionBackToHomeButton) {
                onlineSelectionBackToHomeButton.addEventListener('click', () => {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
            }

            // Cancel Online Search button
            document.getElementById('cancelSearchButton').addEventListener('click', cancelOnlineSearch);

            // Leave Online Game button
            document.getElementById('online-leave-game-button').addEventListener('click', () => {
                showMessage("Êtes-vous sûr de vouloir quitter la partie ? Cela sera considéré comme une défaite.", () => {
                    leaveOnlineGame();
                });
            });

            // Game End Screen Buttons
            gameEndReplayButton.addEventListener('click', () => {
                gameEndOverlay.classList.add('hidden');
                gameEndBanner.classList.add('hidden');
                if (currentEndGameType === 'local') {
                    resetLocalGame();
                } else if (currentEndGameType === 'ai') {
                    resetAIGame();
                } else if (currentEndGameType === 'online') {
                    resetOnlineGame(); // This will re-trigger matchmaking for the same mode
                }
            });

            gameEndHomeButton.addEventListener('click', () => {
                gameEndOverlay.classList.add('hidden');
                gameEndBanner.classList.add('hidden');
                if (currentEndGameType === 'local') {
                    leaveLocalGame();
                } else if (currentEndGameType === 'ai') {
                    leaveAIGame();
                } else if (currentEndGameType === 'online') {
                    leaveOnlineGame();
                }
            });


            // Play Local button
            if (playLocalButton) {
                playLocalButton.addEventListener('click', function() {
                    hideAllScreens();
                    localGameScreen.classList.remove('hidden');
                    // Passer le gestionnaire de clic lors de la création des cellules
                    createCells('local-board', handleLocalCellClick);
                    resetLocalGame();
                });
            }

            if (localBackToHomeButton) {
                localBackToHomeButton.addEventListener('click', function() {
                    leaveLocalGame();
                });
            }

            if (localResetButton) {
                localResetButton.addEventListener('click', resetLocalGame);
            }

            // Play AI button
            if (playAIButton) {
                playAIButton.addEventListener('click', function() {
                    hideAllScreens();
                    aiGameScreen.classList.remove('hidden');
                    // Passer le gestionnaire de clic lors de la création des cellules
                    createCells('ai-board', handleAICellClick);
                    updateStatus("Sélectionnez une difficulté pour commencer", 'ai');
                    aiGameActive = false;
                    difficultyButtons.forEach(button => button.classList.remove('selected-difficulty'));
                });
            }

            if (aiBackToHomeButton) {
                aiBackToHomeButton.addEventListener('click', function() {
                    leaveAIGame();
                });
            }

            if (easyButton) {
                easyButton.addEventListener('click', () => handleDifficultySelection('easy'));
            }
            if (mediumButton) {
                mediumButton.addEventListener('click', () => handleDifficultySelection('medium'));
            }
            if (hardButton) {
                hardButton.addEventListener('click', () => handleDifficultySelection('hard'));
            }

            if (aiResetButton) {
                aiResetButton.addEventListener('click', resetAIGame);
            }

            // --- Event Listeners for History and Leaderboard ---
            if (showHistoryButton) {
                showHistoryButton.addEventListener('click', showGameHistoryScreen);
            }

            if (showLeaderboardButton) {
                showLeaderboardButton.addEventListener('click', function() {
                    if (isAuthReady && currentUserId) {
                        showLeaderboardScreen();
                    } else {
                        showMessage("Veuillez patienter, la connexion à Firebase est en cours...", () => {
                            if (isAuthReady && currentUserId) {
                                showLeaderboardScreen();
                            } else {
                                showMessage("Impossible de se connecter à Firebase. Veuillez vérifier votre connexion.");
                            }
                        });
                    }
                });
            }

            if (leaderboardBackToHomeButton) {
                leaderboardBackToHomeButton.addEventListener('click', function() {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
            }

            // History screen back button
            if (historyBackButton) {
                historyBackButton.addEventListener('click', function() {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    // Re-display current user's profile on returning to home
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
            }

            // History detail screen buttons
            if (prevMoveButton) {
                prevMoveButton.addEventListener('click', () => {
                    if (currentDetailMoveIndex > -1) {
                        currentDetailMoveIndex--;
                        updateDetailBoardDisplay();
                    }
                });
            }
            if (nextMoveButton) {
                nextMoveButton.addEventListener('click', () => {
                    if (currentDetailMoveIndex < currentDetailGameMoves.length - 1) {
                        currentDetailMoveIndex++;
                        updateDetailBoardDisplay();
                    }
                });
            }
            if (detailBackButton) {
                detailBackButton.addEventListener('click', showGameHistoryScreen); // Go back to history list
            }

            // --- NOUVEAUX LISTENERS POUR LE SYSTÈME D'AMIS ---
            if (showFriendsButton) {
                showFriendsButton.addEventListener('click', showFriendsScreen);
            }
            if (friendsBackToHomeButton) {
                friendsBackToHomeButton.addEventListener('click', function() {
                    hideAllScreens();
                    homeScreen.classList.remove('hidden');
                    if (isAuthReady && currentUserId) {
                        fetchUserProfile(currentUserId).then(profile => displayUserProfile(currentUserId, profile));
                    }
                });
            }

            if (userSearchButton) {
                userSearchButton.addEventListener('click', searchUsers);
                userSearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchUsers();
                    }
                });
            }

            // User Profile Modal Actions
            userProfileModalCloseButton.addEventListener('click', () => userProfileModalOverlay.classList.add('hidden'));

            sendFriendRequestButton.addEventListener('click', () => sendFriendRequest(modalProfileId.textContent));
            cancelFriendRequestButton.addEventListener('click', () => unfriend(modalProfileId.textContent)); // Unfriend also cancels pending
            acceptFriendRequestButton.addEventListener('click', () => acceptFriendRequest(modalProfileId.textContent));
            declineFriendRequestButton.addEventListener('click', () => declineFriendRequest(modalProfileId.textContent));
            unfriendButton.addEventListener('click', () => unfriend(modalProfileId.textContent));
            blockUserButton.addEventListener('click', () => blockUser(modalProfileId.textContent));
            unblockUserButton.addEventListener('click', () => unblockUser(modalProfileId.textContent));

            // Propose Game Button Listener
            // This button should now also allow choosing game mode
            proposeGameButton.addEventListener('click', async () => {
                // For simplicity, let's assume "Proposer Partie" always proposes a classic game for now.
                // If you want to add mode selection here, we'd need another small modal.
                // For now, it will just send a classic invite.
                const targetUserId = modalProfileId.textContent;
                const targetUsername = modalProfileUsername.textContent;

                // Create a temporary modal for game mode selection
                const modeSelectionModal = document.createElement('div');
                modeSelectionModal.classList.add('modal-overlay');
                modeSelectionModal.innerHTML = `
                    <div class="modal-content">
                        <button class="modal-close-button" id="mode-selection-modal-close"><i class="fas fa-times"></i></button>
                        <h2 class="text-3xl font-bold text-center text-[#1A2B3C] mb-4">Proposer une partie à ${targetUsername}</h2>
                        <p class="text-xl text-center text-gray-700 mb-6">Choisissez le mode de jeu :</p>
                        <div class="flex justify-center gap-4">
                            <button id="propose-classic-button" class="game-button px-6 py-3 bg-[#1A2B3C] hover:bg-gray-800">Classique</button>
                            <button id="propose-blitz-button" class="game-button px-6 py-3 bg-[#FFD700] text-[#1A2B3C] hover:bg-yellow-400">Blitz</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modeSelectionModal);

                // Add event listeners for the new modal buttons
                document.getElementById('mode-selection-modal-close').addEventListener('click', () => modeSelectionModal.remove());
                document.getElementById('propose-classic-button').addEventListener('click', () => {
                    sendGameInvitation(targetUserId, targetUsername, 'classic');
                    modeSelectionModal.remove();
                });
                document.getElementById('propose-blitz-button').addEventListener('click', () => {
                    sendGameInvitation(targetUserId, targetUsername, 'blitz');
                    modeSelectionModal.remove();
                });
            });

            // Notification Modal Actions
            notificationButton.addEventListener('click', showNotificationModal);
            notificationModalCloseButton.addEventListener('click', () => notificationModalOverlay.classList.add('hidden'));

            // Game Invite Modal Actions
            gameInviteModalCloseButton.addEventListener('click', () => {
                gameInviteModalOverlay.classList.add('hidden');
                currentIncomingGameInvite = null; // Clear the active invite
            });
            // acceptGameInviteButton and declineGameInviteButton listeners are now set up in renderNotifications
            // for dynamic buttons, but also need to be here for the direct modal.
            // Ensure they pass the game mode.
            acceptGameInviteButton.addEventListener('click', () => {
                if (currentIncomingGameInvite) {
                    acceptGameInvitation(currentIncomingGameInvite.id, currentIncomingGameInvite.senderId, currentIncomingGameInvite.gameMode);
                }
            });
            declineGameInviteButton.addEventListener('click', () => {
                if (currentIncomingGameInvite) {
                    declineGameInvitation(currentIncomingGameInvite.id);
                }
            });


            // Share App Button Listener
            if (shareAppButton) {
                shareAppButton.addEventListener('click', shareApp);
            }

            // Stats Toggle Buttons
            if (statsToggleClassic) {
                statsToggleClassic.addEventListener('click', () => {
                    currentStatsDisplayMode = 'classic';
                    updateDisplayedStats('classic');
                });
            }
            if (statsToggleBlitz) {
                statsToggleBlitz.addEventListener('click', () => {
                    currentStatsDisplayMode = 'blitz';
                    updateDisplayedStats('blitz');
                });
            }

            // Leaderboard Toggle Buttons
            if (leaderboardToggleClassic) {
                leaderboardToggleClassic.addEventListener('click', () => {
                    currentLeaderboardDisplayMode = 'classic';
                    fetchLeaderboard('classic');
                });
            }
            if (leaderboardToggleBlitz) {
                leaderboardToggleBlitz.addEventListener('click', () => {
                    currentLeaderboardDisplayMode = 'blitz';
                    fetchLeaderboard('blitz');
                });
            }
        });
    </script>
</body>
</html>
